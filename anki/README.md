# MNAB - Neetcode 150 and blind 75 - multi-author

## Questions

| ID | File name / path | Part | Chapter |
| --- | --- | --- | --- |
| **-** | **Arrays and Hashing** | **1** | **-** |
| **-** | **Arrays and Hashing > Contains Duplicate Blind** | **1** | **1** |
| [1](#id1) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/1%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |

### Part I - Arrays and Hashing

#### Chapter 1 - Contains Duplicate (Blind)

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

How many possible pairs of elements are there in an array of size n?

A) log n

B) n

C) n^2

D) 2^n

###### ID1

A:: =============================================  
**Answer**: C

There are exactly n \* (n - 1) / 2 distinct pairs of integers in the array. This is equivalent to (n^2 - n) / 2, and we normally consider the largest term, which in this case is n^2.

#### Chapter 2 - Valid Anagram (Blind)

#### Chapter 3 - Two Sum (Blind)

#### Chapter 4 - Group Anagrams (Blind)

#### Chapter 5 - Top K Frequent Elements (Blind)

#### Chapter 6 - Product of Array Except Self (Blind)

#### Chapter 7 - Valid Sudoku

#### Chapter 8 - Encode and Decode Strings (Blind)

#### Chapter 9 - Longest Consecutive Sequence (Blind)

### Part II - Two Pointers

#### Chapter 1 - Valid Palindrome (Blind)

#### Chapter 2 - Two Sum II

#### Chapter 3 - 3Sum (Blind)

#### Chapter 4 - Container With Most Water (Blind)

#### Chapter 5 - Trapping Rain Water

### Part III - Sliding Window

#### Chapter 1 - Best Time to Buy and Sell Stock (Blind)

#### Chapter 2 - Longest Substring Without Repeating Characters (Blind)

#### Chapter 3 - Longest Repeating Character Replacement (Blind)

#### Chapter 4 - Permutation in String

#### Chapter 5 - Minimum Window Substring (Blind)

#### Chapter 6 - Sliding Window Maximum

### Part IV - Stack

#### Chapter 1 - Valid Parentheses (Blind)

#### Chapter 2 - Min Stack

#### Chapter 3 - Evaluate Reverse Polish Notation

#### Chapter 4 - Generate Parentheses

#### Chapter 5 - Daily Temperatures

#### Chapter 6 - Car Fleet

#### Chapter 7 - Largest Rectangle in Histogram

### Part V - Binary Search

#### Chapter 1 - Binary Search

#### Chapter 2 - Search a 2D Matrix

#### Chapter 3 - Koko Eating Bananas

#### Chapter 4 - Search in Rotated Sorted Array (Blind)

#### Chapter 5 - Find Minimum in Rotated Sorted Array (Blind)

#### Chapter 6 - Time Based Key-Value Store

#### Chapter 7 - Median of Two Sorted Arrays

### Part VI - Linked List

#### Chapter 1 - Reverse Linked List (Blind)

#### Chapter 2 - Merge Two Sorted Lists (Blind)

#### Chapter 3 - Reorder List (Blind)

#### Chapter 4 - Remove Nth Node From End of List (Blind)

#### Chapter 5 - Copy List with Random Pointer

#### Chapter 6 - Add Two Numbers

#### Chapter 7 - Linked List Cycle (Blind)

#### Chapter 8 - Find the Duplicate Number

#### Chapter 9 - LRU Cache

#### Chapter 10 - Merge k Sorted Lists (Blind)

#### Chapter 11 - Reverse Nodes in k-Group

### Part VII - Trees

#### Chapter 1 - Invert Binary Tree (Blind)

#### Chapter 2 - Maximum Depth of Binary Tree (Blind)

#### Chapter 3 - Diameter of Binary Tree

#### Chapter 4 - Balanced Binary Tree

#### Chapter 5 - Same Tree (Blind)

#### Chapter 6 - Subtree of Another Tree (Blind)

#### Chapter 7 - Lowest Common Ancestor of a Binary Search Tree (Blind)

#### Chapter 8 - Binary Tree Level Order Traversal (Blind)

#### Chapter 9 - Binary Tree Right Side View

#### Chapter 10 - Count Good Nodes in Binary Tree

#### Chapter 11 - Validate Binary Search Tree (Blind)

#### Chapter 12 - Kth Smallest Element in a BST (Blind)

#### Chapter 13 - Construct Binary Tree from Preorder and Inorder Traversal (Blind)

#### Chapter 14 - Binary Tree Maximum Path Sum (Blind)

#### Chapter 15 - Serialize and Deserialize Binary Tree (Blind)

### Part VIII - Trie

#### Chapter 1 - Implement Trie (Blind)

#### Chapter 2 - Design Add and Search Words Data Structure (Blind)

#### Chapter 3 - Word Search II (Blind)

### Part IX - Heap and Priority Queue

#### Chapter 1 - Kth Largest Element in a Stream

#### Chapter 2 - Last Stone Weight

#### Chapter 3 - K Closest Points to Origin

#### Chapter 4 - Kth Largest Element in an Array

#### Chapter 5 - Task Scheduler

#### Chapter 6 - Design Twitter

#### Chapter 7 - Find Median from Data Stream (Blind)

### Part X - Backtracking

#### Chapter 1 - Permutations

#### Chapter 2 - Sudoku Solver

#### Chapter 3 - Subsets

#### Chapter 4 - Combination Sum (Blind)

#### Chapter 5 - Subsets II

#### Chapter 6 - Word Search (Blind)

#### Chapter 7 - Palindrome Partitioning

#### Chapter 8 - Letter Combinations of a Phone Number

#### Chapter 9 - N-Queens

### Part XI - Graphs

#### Chapter 1 - Number of Islands (Blind)

#### Chapter 2 - Clone Graph (Blind)

#### Chapter 3 - Max Area of Island

#### Chapter 4 - Pacific Atlantic Water Flow (Blind)

#### Chapter 5 - Surrounded Regions

#### Chapter 6 - Rotting Oranges

#### Chapter 7 - Walls and Gates

#### Chapter 8 - Course Schedule (Blind)

#### Chapter 9 - Course Schedule II

#### Chapter 10 - Redundant Connection

#### Chapter 11 - Number of Connected Components In An Undirected Graph (Blind)

#### Chapter 12 - Graph Valid Tree (Blind)

#### Chapter 13 - Word Ladder

### Part XII - Advance Graphs

#### Chapter 1 - Reconstruct Itinerary

---

DECK INFO

TARGET DECK: Data Structures and Algorithms::Leetcode::MNAB - Neetcode 150 and blind 75 - multi-author

FILE TAGS: #DSA::#Leetcode

Tags:

Reference:

Related:

```dataview
LIST
where file.name = this.file.name
```