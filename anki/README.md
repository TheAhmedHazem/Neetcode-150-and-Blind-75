# MNAB - Neetcode 150 and blind 75 - multi-author

## Questions

| ID | File name / path | Part | Chapter |
| --- | --- | --- | --- |
| **-** | **Arrays and Hashing** | **1** | **-** |
| **-** | **Arrays and Hashing > Contains Duplicate Blind** | **1** | **1** |
| [1](#id1) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/1%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| [2](#id2) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/2%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| [3](#id3) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/3%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| [4](#id4) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/4%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| [5](#id5) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/5%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| **-** | **Arrays and Hashing > Valid Anagram Blind** | **1** | **2** |
| [6](#id6) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/6%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [7](#id7) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/7%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [8](#id8) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/8%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [9](#id9) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/9%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [10](#id10) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/10%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [11](#id11) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/11%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| **-** | **Arrays and Hashing > Two Sum Blind** | **1** | **3** |
| [12](#id12) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/12%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [13](#id13) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/13%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [14](#id14) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/14%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [15](#id15) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/15%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [16](#id16) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/16%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [17](#id17) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/17%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [18](#id18) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/18%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| **-** | **Arrays and Hashing > Encode and Decode Strings Blind** | **1** | **8** |
| [19](#id19) | [Design an algorithm to encode a list of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%208%20-%20Encode%20and%20Decode%20Strings%20Blind/19%20-%20Design%20an%20algorithm%20to%20encode%20a%20list%20of.md) | 1 | 8 |
| [20](#id20) | [Design an algorithm to encode a list of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%208%20-%20Encode%20and%20Decode%20Strings%20Blind/20%20-%20Design%20an%20algorithm%20to%20encode%20a%20list%20of.md) | 1 | 8 |
| [21](#id21) | [Design an algorithm to encode a list of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%208%20-%20Encode%20and%20Decode%20Strings%20Blind/21%20-%20Design%20an%20algorithm%20to%20encode%20a%20list%20of.md) | 1 | 8 |
| [22](#id22) | [Design an algorithm to encode a list of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%208%20-%20Encode%20and%20Decode%20Strings%20Blind/22%20-%20Design%20an%20algorithm%20to%20encode%20a%20list%20of.md) | 1 | 8 |
| **-** | **Arrays and Hashing > Longest Consecutive Sequence Blind** | **1** | **9** |
| [23](#id23) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/23%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [24](#id24) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/24%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [25](#id25) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/25%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [26](#id26) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/26%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [27](#id27) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/27%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [28](#id28) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/28%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| **-** | **Two Pointers** | **2** | **-** |
| **-** | **Two Pointers > Valid Palindrome Blind** | **2** | **1** |
| [29](#id29) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/29%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [30](#id30) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/30%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [31](#id31) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/31%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [32](#id32) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/32%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [33](#id33) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/33%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [34](#id34) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/34%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| **-** | **Two Pointers > 3Sum Blind** | **2** | **3** |
| [35](#id35) | [Given an integer array nums return all th](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20Blind/35%20-%20Given%20an%20integer%20array%20nums%20return%20all%20th.md) | 2 | 3 |
| [36](#id36) | [Given an integer array nums return all th](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20Blind/36%20-%20Given%20an%20integer%20array%20nums%20return%20all%20th.md) | 2 | 3 |
| [37](#id37) | [Given an integer array nums return all th](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20Blind/37%20-%20Given%20an%20integer%20array%20nums%20return%20all%20th.md) | 2 | 3 |
| [38](#id38) | [Given an integer array nums return all th](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20Blind/38%20-%20Given%20an%20integer%20array%20nums%20return%20all%20th.md) | 2 | 3 |
| [39](#id39) | [Given an integer array nums return all th](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20Blind/39%20-%20Given%20an%20integer%20array%20nums%20return%20all%20th.md) | 2 | 3 |
| **-** | **Two Pointers > Container With Most Water Blind** | **2** | **4** |
| [40](#id40) | [You are given an integer array height of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20Blind/40%20-%20You%20are%20given%20an%20integer%20array%20height%20of.md) | 2 | 4 |
| [41](#id41) | [You are given an integer array height of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20Blind/41%20-%20You%20are%20given%20an%20integer%20array%20height%20of.md) | 2 | 4 |
| [42](#id42) | [You are given an integer array height of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20Blind/42%20-%20You%20are%20given%20an%20integer%20array%20height%20of.md) | 2 | 4 |
| [43](#id43) | [You are given an integer array height of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20Blind/43%20-%20You%20are%20given%20an%20integer%20array%20height%20of.md) | 2 | 4 |
| [44](#id44) | [You are given an integer array height of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20Blind/44%20-%20You%20are%20given%20an%20integer%20array%20height%20of.md) | 2 | 4 |
| [45](#id45) | [You are given an integer array height of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20Blind/45%20-%20You%20are%20given%20an%20integer%20array%20height%20of.md) | 2 | 4 |
| **-** | **Sliding Window** | **3** | **-** |
| **-** | **Sliding Window > Best Time to Buy and Sell Stock Blind** | **3** | **1** |
| [46](#id46) | [You are given an array prices where pri](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20Blind/46%20-%20You%20are%20given%20an%20array%20prices%20where%20pri.md) | 3 | 1 |
| [47](#id47) | [You are given an array prices where pri](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20Blind/47%20-%20You%20are%20given%20an%20array%20prices%20where%20pri.md) | 3 | 1 |
| [48](#id48) | [You are given an array prices where pri](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20Blind/48%20-%20You%20are%20given%20an%20array%20prices%20where%20pri.md) | 3 | 1 |
| [49](#id49) | [You are given an array prices where pri](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20Blind/49%20-%20You%20are%20given%20an%20array%20prices%20where%20pri.md) | 3 | 1 |
| [50](#id50) | [You are given an array prices where pri](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20Blind/50%20-%20You%20are%20given%20an%20array%20prices%20where%20pri.md) | 3 | 1 |
| **-** | **Sliding Window > Longest Substring Without Repeating Characters Blind** | **3** | **2** |
| [51](#id51) | [Given a string s find the length of the](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20Blind/51%20-%20Given%20a%20string%20s%20find%20the%20length%20of%20the.md) | 3 | 2 |
| [52](#id52) | [Given a string s find the length of the](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20Blind/52%20-%20Given%20a%20string%20s%20find%20the%20length%20of%20the.md) | 3 | 2 |
| [53](#id53) | [Given a string s find the length of the](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20Blind/53%20-%20Given%20a%20string%20s%20find%20the%20length%20of%20the.md) | 3 | 2 |
| [54](#id54) | [Given a string s find the length of the](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20Blind/54%20-%20Given%20a%20string%20s%20find%20the%20length%20of%20the.md) | 3 | 2 |
| [55](#id55) | [Given a string s find the length of the](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20Blind/55%20-%20Given%20a%20string%20s%20find%20the%20length%20of%20the.md) | 3 | 2 |
| [56](#id56) | [Given a string s find the length of the](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20Blind/56%20-%20Given%20a%20string%20s%20find%20the%20length%20of%20the.md) | 3 | 2 |
| **-** | **Sliding Window > Longest Repeating Character Replacement Blind** | **3** | **3** |
| [57](#id57) | [You are given a string s and an integer](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20Blind/57%20-%20You%20are%20given%20a%20string%20s%20and%20an%20integer.md) | 3 | 3 |
| [58](#id58) | [You are given a string s and an integer](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20Blind/58%20-%20You%20are%20given%20a%20string%20s%20and%20an%20integer.md) | 3 | 3 |
| [59](#id59) | [You are given a string s and an integer](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20Blind/59%20-%20You%20are%20given%20a%20string%20s%20and%20an%20integer.md) | 3 | 3 |
| [60](#id60) | [You are given a string s and an integer](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20Blind/60%20-%20You%20are%20given%20a%20string%20s%20and%20an%20integer.md) | 3 | 3 |
| [61](#id61) | [You are given a string s and an integer](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20Blind/61%20-%20You%20are%20given%20a%20string%20s%20and%20an%20integer.md) | 3 | 3 |
| [62](#id62) | [You are given a string s and an integer](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20Blind/62%20-%20You%20are%20given%20a%20string%20s%20and%20an%20integer.md) | 3 | 3 |
| **-** | **Sliding Window > Minimum Window Substring Blind** | **3** | **5** |
| [63](#id63) | [Given two strings s and t of lengths](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20Blind/63%20-%20Given%20two%20strings%20s%20and%20t%20of%20lengths.md) | 3 | 5 |
| [64](#id64) | [Given two strings s and t of lengths](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20Blind/64%20-%20Given%20two%20strings%20s%20and%20t%20of%20lengths.md) | 3 | 5 |
| [65](#id65) | [Given two strings s and t of lengths](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20Blind/65%20-%20Given%20two%20strings%20s%20and%20t%20of%20lengths.md) | 3 | 5 |
| [66](#id66) | [Given two strings s and t of lengths](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20Blind/66%20-%20Given%20two%20strings%20s%20and%20t%20of%20lengths.md) | 3 | 5 |
| [67](#id67) | [Given two strings s and t of lengths](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20Blind/67%20-%20Given%20two%20strings%20s%20and%20t%20of%20lengths.md) | 3 | 5 |
| [68](#id68) | [Given two strings s and t of lengths](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20Blind/68%20-%20Given%20two%20strings%20s%20and%20t%20of%20lengths.md) | 3 | 5 |
| [69](#id69) | [Given two strings s and t of lengths](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20Blind/69%20-%20Given%20two%20strings%20s%20and%20t%20of%20lengths.md) | 3 | 5 |
| **-** | **Stack** | **4** | **-** |
| **-** | **Stack > Valid Parentheses Blind** | **4** | **1** |
| [70](#id70) | [Given a string s containing just the chara](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20Blind/70%20-%20Given%20a%20string%20s%20containing%20just%20the%20chara.md) | 4 | 1 |
| [71](#id71) | [Given a string s containing just the chara](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20Blind/71%20-%20Given%20a%20string%20s%20containing%20just%20the%20chara.md) | 4 | 1 |
| [72](#id72) | [Given a string s containing just the chara](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20Blind/72%20-%20Given%20a%20string%20s%20containing%20just%20the%20chara.md) | 4 | 1 |
| [73](#id73) | [Given a string s containing just the chara](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20Blind/73%20-%20Given%20a%20string%20s%20containing%20just%20the%20chara.md) | 4 | 1 |
| [74](#id74) | [Given a string s containing just the chara](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20Blind/74%20-%20Given%20a%20string%20s%20containing%20just%20the%20chara.md) | 4 | 1 |
| [75](#id75) | [Given a string s containing just the chara](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20Blind/75%20-%20Given%20a%20string%20s%20containing%20just%20the%20chara.md) | 4 | 1 |
| **-** | **Binary Search** | **5** | **-** |
| **-** | **Binary Search > Search in Rotated Sorted Array Blind** | **5** | **4** |
| [76](#id76) | [There is an integer array nums sorted in](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%204%20-%20Search%20in%20Rotated%20Sorted%20Array%20Blind/76%20-%20There%20is%20an%20integer%20array%20nums%20sorted%20in.md) | 5 | 4 |
| [77](#id77) | [There is an integer array nums sorted in](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%204%20-%20Search%20in%20Rotated%20Sorted%20Array%20Blind/77%20-%20There%20is%20an%20integer%20array%20nums%20sorted%20in.md) | 5 | 4 |
| [78](#id78) | [There is an integer array nums sorted in](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%204%20-%20Search%20in%20Rotated%20Sorted%20Array%20Blind/78%20-%20There%20is%20an%20integer%20array%20nums%20sorted%20in.md) | 5 | 4 |
| [79](#id79) | [There is an integer array nums sorted in](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%204%20-%20Search%20in%20Rotated%20Sorted%20Array%20Blind/79%20-%20There%20is%20an%20integer%20array%20nums%20sorted%20in.md) | 5 | 4 |
| [80](#id80) | [There is an integer array nums sorted in](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%204%20-%20Search%20in%20Rotated%20Sorted%20Array%20Blind/80%20-%20There%20is%20an%20integer%20array%20nums%20sorted%20in.md) | 5 | 4 |
| [81](#id81) | [There is an integer array nums sorted in](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%204%20-%20Search%20in%20Rotated%20Sorted%20Array%20Blind/81%20-%20There%20is%20an%20integer%20array%20nums%20sorted%20in.md) | 5 | 4 |
| [82](#id82) | [There is an integer array nums sorted in](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%204%20-%20Search%20in%20Rotated%20Sorted%20Array%20Blind/82%20-%20There%20is%20an%20integer%20array%20nums%20sorted%20in.md) | 5 | 4 |
| [83](#id83) | [There is an integer array nums sorted in](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%204%20-%20Search%20in%20Rotated%20Sorted%20Array%20Blind/83%20-%20There%20is%20an%20integer%20array%20nums%20sorted%20in.md) | 5 | 4 |
| [84](#id84) | [There is an integer array nums sorted in](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%204%20-%20Search%20in%20Rotated%20Sorted%20Array%20Blind/84%20-%20There%20is%20an%20integer%20array%20nums%20sorted%20in.md) | 5 | 4 |
| **-** | **Binary Search > Find Minimum in Rotated Sorted Array Blind** | **5** | **5** |
| [85](#id85) | [Suppose an array of length n sorted in a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%205%20-%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20Blind/85%20-%20Suppose%20an%20array%20of%20length%20n%20sorted%20in%20a.md) | 5 | 5 |
| [86](#id86) | [Suppose an array of length n sorted in a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%205%20-%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20Blind/86%20-%20Suppose%20an%20array%20of%20length%20n%20sorted%20in%20a.md) | 5 | 5 |
| [87](#id87) | [Suppose an array of length n sorted in a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%205%20-%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20Blind/87%20-%20Suppose%20an%20array%20of%20length%20n%20sorted%20in%20a.md) | 5 | 5 |
| [88](#id88) | [Suppose an array of length n sorted in a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%205%20-%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20Blind/88%20-%20Suppose%20an%20array%20of%20length%20n%20sorted%20in%20a.md) | 5 | 5 |
| [89](#id89) | [Suppose an array of length n sorted in a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%205%20-%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20Blind/89%20-%20Suppose%20an%20array%20of%20length%20n%20sorted%20in%20a.md) | 5 | 5 |
| [90](#id90) | [Suppose an array of length n sorted in a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%205%20-%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20Blind/90%20-%20Suppose%20an%20array%20of%20length%20n%20sorted%20in%20a.md) | 5 | 5 |
| [91](#id91) | [Suppose an array of length n sorted in a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%205%20-%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20Blind/91%20-%20Suppose%20an%20array%20of%20length%20n%20sorted%20in%20a.md) | 5 | 5 |
| [92](#id92) | [Suppose an array of length n sorted in a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Binary%20Search/Chapter%205%20-%20Find%20Minimum%20in%20Rotated%20Sorted%20Array%20Blind/92%20-%20Suppose%20an%20array%20of%20length%20n%20sorted%20in%20a.md) | 5 | 5 |
| **-** | **Linked List** | **6** | **-** |
| **-** | **Linked List > Reverse Linked List Blind** | **6** | **1** |
| [93](#id93) | [Given the head of a singly linked list](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%201%20-%20Reverse%20Linked%20List%20Blind/93%20-%20Given%20the%20head%20of%20a%20singly%20linked%20list.md) | 6 | 1 |
| [94](#id94) | [Given the head of a singly linked list](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%201%20-%20Reverse%20Linked%20List%20Blind/94%20-%20Given%20the%20head%20of%20a%20singly%20linked%20list.md) | 6 | 1 |
| [95](#id95) | [Given the head of a singly linked list](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%201%20-%20Reverse%20Linked%20List%20Blind/95%20-%20Given%20the%20head%20of%20a%20singly%20linked%20list.md) | 6 | 1 |
| [96](#id96) | [Given the head of a singly linked list](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%201%20-%20Reverse%20Linked%20List%20Blind/96%20-%20Given%20the%20head%20of%20a%20singly%20linked%20list.md) | 6 | 1 |
| **-** | **Linked List > Merge Two Sorted Lists Blind** | **6** | **2** |
| [97](#id97) | [You are given the heads of two sorted link](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20Blind/97%20-%20You%20are%20given%20the%20heads%20of%20two%20sorted%20link.md) | 6 | 2 |
| [98](#id98) | [You are given the heads of two sorted link](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20Blind/98%20-%20You%20are%20given%20the%20heads%20of%20two%20sorted%20link.md) | 6 | 2 |
| [99](#id99) | [You are given the heads of two sorted link](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20Blind/99%20-%20You%20are%20given%20the%20heads%20of%20two%20sorted%20link.md) | 6 | 2 |
| [100](#id100) | [You are given the heads of two sorted link](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20Blind/100%20-%20You%20are%20given%20the%20heads%20of%20two%20sorted%20link.md) | 6 | 2 |
| [101](#id101) | [You are given the heads of two sorted link](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20Blind/101%20-%20You%20are%20given%20the%20heads%20of%20two%20sorted%20link.md) | 6 | 2 |
| **-** | **Linked List > Reorder List Blind** | **6** | **3** |
| [102](#id102) | [You are given the head of a singly linked-](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20Blind/102%20-%20You%20are%20given%20the%20head%20of%20a%20singly%20linked-.md) | 6 | 3 |
| [103](#id103) | [You are given the head of a singly linked-](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20Blind/103%20-%20You%20are%20given%20the%20head%20of%20a%20singly%20linked-.md) | 6 | 3 |
| [104](#id104) | [You are given the head of a singly linked-](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20Blind/104%20-%20You%20are%20given%20the%20head%20of%20a%20singly%20linked-.md) | 6 | 3 |
| [105](#id105) | [You are given the head of a singly linked-](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20Blind/105%20-%20You%20are%20given%20the%20head%20of%20a%20singly%20linked-.md) | 6 | 3 |
| [106](#id106) | [You are given the head of a singly linked-](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20Blind/106%20-%20You%20are%20given%20the%20head%20of%20a%20singly%20linked-.md) | 6 | 3 |
| **-** | **Linked List > Remove Nth Node From End of List Blind** | **6** | **4** |
| [107](#id107) | [Given the head of a linked list remove](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20Blind/107%20-%20Given%20the%20head%20of%20a%20linked%20list%20remove.md) | 6 | 4 |
| [108](#id108) | [Given the head of a linked list remove](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20Blind/108%20-%20Given%20the%20head%20of%20a%20linked%20list%20remove.md) | 6 | 4 |
| [109](#id109) | [Given the head of a linked list remove](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20Blind/109%20-%20Given%20the%20head%20of%20a%20linked%20list%20remove.md) | 6 | 4 |
| [110](#id110) | [Given the head of a linked list remove](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20Blind/110%20-%20Given%20the%20head%20of%20a%20linked%20list%20remove.md) | 6 | 4 |
| [111](#id111) | [Given the head of a linked list remove](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20Blind/111%20-%20Given%20the%20head%20of%20a%20linked%20list%20remove.md) | 6 | 4 |
| **-** | **Linked List > Merge k Sorted Lists Blind** | **6** | **10** |
| [112](#id112) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20k%20Sorted%20Lists%20Blind/112%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 6 | 10 |
| [113](#id113) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20k%20Sorted%20Lists%20Blind/113%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 6 | 10 |
| [114](#id114) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20k%20Sorted%20Lists%20Blind/114%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 6 | 10 |
| [115](#id115) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20k%20Sorted%20Lists%20Blind/115%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 6 | 10 |
| [116](#id116) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20k%20Sorted%20Lists%20Blind/116%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 6 | 10 |
| [117](#id117) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20k%20Sorted%20Lists%20Blind/117%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 6 | 10 |
| **-** | **Trees** | **7** | **-** |
| **-** | **Trees > Invert Binary Tree Blind** | **7** | **1** |
| [118](#id118) | [Given the root of a binary tree invert](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20Blind/118%20-%20Given%20the%20root%20of%20a%20binary%20tree%20invert.md) | 7 | 1 |
| [119](#id119) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20Blind/119%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 7 | 1 |
| [120](#id120) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20Blind/120%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 7 | 1 |
| [121](#id121) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20Blind/121%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 7 | 1 |
| [122](#id122) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20Blind/122%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 7 | 1 |
| **-** | **Trees > Maximum Depth of Binary Tree Blind** | **7** | **2** |
| [123](#id123) | [Given the root of a binary tree return](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20Blind/123%20-%20Given%20the%20root%20of%20a%20binary%20tree%20return.md) | 7 | 2 |
| [124](#id124) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20Blind/124%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 7 | 2 |
| [125](#id125) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20Blind/125%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 7 | 2 |
| [126](#id126) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20Blind/126%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 7 | 2 |
| [127](#id127) | [You are given an array of k linked-lists](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20Blind/127%20-%20You%20are%20given%20an%20array%20of%20k%20linked-lists.md) | 7 | 2 |

### Part I - Arrays and Hashing

#### Chapter 1 - Contains Duplicate (Blind)

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

How many possible pairs of elements are there in an array of size n?

A) log n

B) n

C) n^2

D) 2^n

###### ID1

A:: =============================================  
**Answer**: C

There are exactly n \* (n - 1) / 2 distinct pairs of integers in the array. This is equivalent to (n^2 - n) / 2, and we normally consider the largest term, which in this case is n^2.

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

What is the time complexity of a brute force approach, where you compare every possible pair in the array to check if there are any duplicates?

A) O(n)

B) O(n * log n)

C) O(n^2)

D) O(2^n)

###### ID2

A:: =============================================  
**Answer**: C

The brute-force solution using two nested loops has a time complexity of O(n^2) because for each element in the array, you need to iterate over up to n other elements.

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

What data structure can you use to optimize the approach for checking if there are any duplicate elements in the array?

A) Queue

B) Priority Queue

C) Stack

D) Hashmap or HashSet

###### ID3

A:: =============================================  
**Answer**: D

A Hashmap (or Hashtable) and a HashSet allow us to store and retrieve values in constant time, O(1). We can utilize this property to efficiently check for duplicates.

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

How can a HashSet be used to efficiently check for duplicates in the array?

A) Iterate through each element in the array and try to insert it into the HashSet. If an insertion fails (the element already exists in the HashSet), return true to indicate a duplicate was found.

B) Insert all elements from the array into the HashSet without checking for duplicates during this process. After all insertions, compare the size of the HashSet with the size of the array. If the HashSet size is smaller, return true to indicate a duplicate exists.

C) Both A and B

###### ID4

A:: =============================================  
**Answer**: C

A HashSet does not allow duplicate values. So, if you try to insert an element that already exists in the HashSet, it will not add the element and you know you've found a duplicate (choice A). Alternatively, you could add all elements to the HashSet and then compare its size to the size of the array. If the sizes are different, then there must have been a duplicate in the array (choice B). Both these methods will help identify if a duplicate exists in the array.

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

What is the time and space complexity of the solution using a hashmap?

A) Time complexity: O(n)  
Space complexity: O(n)

B) Time complexity: O(n \* log n)  
Space complexity: O(n)

C) Time complexity: O(n^2)  
Space complexity: O(1)

D) Time complexity: O(n)  
Space complexity: O(1)

###### ID5

A:: =============================================  
**Answer**: A

The hashmap solution has a time complexity of O(n) because you need to iterate through the array once. Also, the key lookup operation with hashmaps runs in O(1) time. The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the hashmap.

#### Chapter 2 - Valid Anagram (Blind)

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

What is the primary characteristic of an anagram?

A) Both words have the same length.

B) Both words have the same letters, in the same quantities.

C) Both words have the same first letter.

D) Both words have the same last letter.

###### ID6

A:: =============================================  
**Answer**: B

An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. This means both words have the same letters, in the same quantities. For example, 'Heart' is an anagram of 'Earth'.

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

Given the nature of anagrams, which of the following methods can be used to check if two words are anagrams?

A) Compare the lengths of two words. If they are equal, the words are anagrams.

B) Convert each word to an array, sort the arrays, and then compare them.

C) Check if the first letter of the first word is present in the second word.

###### ID7

A:: =============================================  
**Answer**: B

By converting each word to an array, sorting the arrays, and then comparing them, we can confirm if two words are anagrams. This is because anagrams have the same letters in the same quantities. For example, after sorting either 'heart' and 'earth', the result is 'aehrt'.

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

What is the time complexity of the solution that sorts and then compares the arrays? Note: We are using an efficient sorting algorithm where we can't make any assumptions about the character set.

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID8

A:: =============================================  
**Answer**: B

The time complexity of sorting an array of n elements is O(n log n), and the time complexity of comparing two arrays is O(n). When considering the largest term, the time complexity of the solution becomes O(n log n).

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

Given the nature of anagrams and the constraints of the problem, can you improve upon the overall time complexity of the sorting solution?

A) No, sorting and comparing is the most optimal solution.

B) Yes, by using a hashmap to store the count of letters.

C) Yes, by checking if the first and last letter of both words are the same.

###### ID9

A:: =============================================  
**Answer**: B

Given the constraints of the problem and the nature of anagrams, we can use a hashmap to store the count of letters for each string. This would allow us to compare the frequency of each letter in both strings in a more time-efficient way. The downside is we may need extra memory, compared to an in-place sorting algorithm.

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

If using a hashmap to check if two words are anagrams, what would be the keys and the values in the hashmap?

A) Keys = Words, Values = Count of each word

B) Keys = Letters, Values = Count of each letter

C) Keys = Length of words, Values = Words of that length

###### ID10

A:: =============================================  
**Answer**: B

In this case, the keys would be the letters, and the values would be the count of each letter. This way, we can track the frequency of each letter in the strings and compare them.

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

What is the time and space complexity of the solution using a hashmap to count and compare the frequency of each letter?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID11

A:: =============================================  
**Answer**: A

The time complexity of this solution is O(n) because we iterate over the input strings once. The space complexity is also O(n) because in the worst-case scenario (where each letter is unique), we would need to store each letter in the hashmap.

#### Chapter 3 - Two Sum (Blind)

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

Roughly how many pairs of integers are there within the array? Assume the size of the array is `n`.

A) log n

B) n

C) n^2

D) 2^n

###### ID12

A:: =============================================  
**Answer**: C

There are exactly n \* (n - 1) / 2 distinct pairs of integers in the array. This is equivalent to (n^2 - n) / 2 and we normally care about the largest term, which in this case is n^2.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

How can you find all pairs of elements `x1, x2` within an array, which have a different index?

A) Sorting the array and using binary search to find a pair

B) Using two nested loops to iterate over all pairs of elements

C) Using divide and conquer to recursively find pairs

###### ID13

A:: =============================================  
**Answer**: B

To find all pairs of elements with different indices in the array, you can use two nested loops. The first loop iterates over each element, while the second loop only iterates over the elements to the right of the current element. This allows you to compare all possible pairs without duplicates.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

After finding each pair of elements, we can then easily determine the indices of the elements that sum to the target. What is the time complexity of this brute-force solution?

A) O(n)

B) O(n \* log n)

C) O(n^2)

D) O(2^n)

###### ID14

A:: =============================================  
**Answer**: C

The brute-force solution using two nested loops has a time complexity of O(n^2) because for each element in the array, you need to iterate over up to n other elements.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

For any given element `x` within the array, how many possible unique `y-values` would satisfy `target = x + y`?

A) 1

B) 2

C) n - 1

D) n

###### ID15

A:: =============================================  
**Answer**: A

We can solve this equation for y: y = target - x. For example, if target=9, and x=2, then y = 9 - 2 = 7. In mathematics, this value is known as the complement.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

Can you reduce the time complexity of the algorithm to find the indices of two numbers that add up to the target using a data structure?

A) No, the time complexity cannot be reduced

B) Yes, using a priority queue

C) Yes, using a hashmap

D) Yes, using a balanced binary search tree

###### ID16

A:: =============================================  
**Answer**: C

Yes, you can reduce the time complexity using a hashmap. A hashmap allows you to store and retrieve values in O(1) - constant time, which can help you find the required indices more efficiently than a brute-force solution.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

How can a hashmap be used to efficiently find the indices of two numbers that add up to the target in an array?

A) Key = Index of each element, Value = Difference between the target and the corresponding element;  
then for each element check if the difference between the target and the element exists as a value in the hashmap.

B) Key = Each element in the array, Value = The index of the corresponding element;  
then for each element check if the difference exists in the hashmap as a key, and that it has a different index from the current element.

###### ID17

A:: =============================================  
**Answer**: B

By storing each element in the array as a key and its index as the corresponding value in the hashmap, you can efficiently find the required pair. For each element, you can efficiently calculate the difference and check if it’s a key within the hashmap. If it does, we can get the index from the hashmap. If the index of the difference is different from the index of the current element (remember we are not allowed reuse the same element twice), then you've found the solution.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

What is the time and space complexity of the optimal solution using a hashmap?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n \* log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID18

A:: =============================================  
**Answer**: A

The hashmap solution has a time complexity of O(n) because you need to iterate through the array once. Also, the key lookup operation with hashmaps runs in O(1) time. The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the hashmap.

#### Chapter 4 - Group Anagrams (Blind)

#### Chapter 5 - Top K Frequent Elements (Blind)

#### Chapter 6 - Product of Array Except Self (Blind)

#### Chapter 7 - Valid Sudoku

#### Chapter 8 - Encode and Decode Strings (Blind)


Q:: =============================================  

##### Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example1**

```
Input: dummy_input = ["Hello", "World"]
Output: ["Hello", "World"]
Explanation:
Machine 1:
Codec encoder = new Codec();
String msg = encoder.encode(strs);
Machine 1 ---msg---&gt; Machine 2

Machine 2:
Codec decoder = new Codec();
String[] strs = decoder.decode(msg);
```

**Example2**

```
Input: dummy_input = [""]
Output: [""]
```

**Constraints:**

-   `1 <= strs.length <= 200`
-   `0 <= strs[i].length <= 200`
-   `strs[i] contains any possible characters out of 256 valid ASCII characters`

___

Given the constraint that `strs[i]` can contain any valid ASCII characters, including special ones, which encoding strategy should we use to ensure that our encoded message can be correctly decoded?

A) Separate strings in strs using a special character, such as a comma or a space.

B) Use a length-prefix followed by a special character for each string in strs.

C) Concatenate all the strings in strs directly.

###### ID19

A:: =============================================  
**Answer**: B

If we use a special character to separate the strings, it could be a problem if the string itself contains this special character. If we concatenate the strings directly, we can't distinguish where one string ends and another begins. Therefore, prefixing each string with its length followed by a special character allows us to correctly separate the strings during decoding, even if they contain special characters.

Q:: =============================================  

##### Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example1**

```
Input: dummy_input = ["Hello", "World"]
Output: ["Hello", "World"]
Explanation:
Machine 1:
Codec encoder = new Codec();
String msg = encoder.encode(strs);
Machine 1 ---msg---&gt; Machine 2

Machine 2:
Codec decoder = new Codec();
String[] strs = decoder.decode(msg);
```

**Example2**

```
Input: dummy_input = [""]
Output: [""]
```

**Constraints:**

-   `1 <= strs.length <= 200`
-   `0 <= strs[i].length <= 200`
-   `strs[i] contains any possible characters out of 256 valid ASCII characters`

___

What should the prefix look like to make the encoding efficient?

A) Prefix each string with the length of the entire list strs.

B) Prefix each string with its individual length followed by a delimiter.

C) Prefix each string with the sum of the lengths of all previous strings.

###### ID20

A:: =============================================  
**Answer**: B

Prefixing each string with its own length allows us to know exactly where each string starts and ends in the encoded string, which simplifies the decoding process.

Q:: =============================================  

##### Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example1**

```
Input: dummy_input = ["Hello", "World"]
Output: ["Hello", "World"]
Explanation:
Machine 1:
Codec encoder = new Codec();
String msg = encoder.encode(strs);
Machine 1 ---msg---&gt; Machine 2

Machine 2:
Codec decoder = new Codec();
String[] strs = decoder.decode(msg);
```

**Example2**

```
Input: dummy_input = [""]
Output: [""]
```

**Constraints:**

-   `1 <= strs.length <= 200`
-   `0 <= strs[i].length <= 200`
-   `strs[i] contains any possible characters out of 256 valid ASCII characters`

___

What should be the delimiter between the length prefix and the actual string content?

A) The delimiter can be any character, as it is not important for decoding.

B) The delimiter should be a character that is not allowed in the strings.

C) The delimiter should be a non-integer character.

###### ID21

A:: =============================================  
**Answer**: C

If the delimiter is a number, it could lead to confusion during decoding. Hence, we need to choose a delimiter that cannot be part of the prefix.

Q:: =============================================  

##### Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example1**

```
Input: dummy_input = ["Hello", "World"]
Output: ["Hello", "World"]
Explanation:
Machine 1:
Codec encoder = new Codec();
String msg = encoder.encode(strs);
Machine 1 ---msg---&gt; Machine 2

Machine 2:
Codec decoder = new Codec();
String[] strs = decoder.decode(msg);
```

**Example2**

```
Input: dummy_input = [""]
Output: [""]
```

**Constraints:**

-   `1 <= strs.length <= 200`
-   `0 <= strs[i].length <= 200`
-   `strs[i] contains any possible characters out of 256 valid ASCII characters`

___

We can implement the encode and decode methods using `#` as the delimiter, as follow. What is the time and space complexity of the encode and decode methods? Assume `n` is the total length of the string.


```python
class Codec:
    def encode(self, strs: List[str]) -> str:
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res

    def decode(self, s: str) -> List[str]:
        res, i = [], 0
        while i < len(s):
            j = i
            while s[j] != "#":
                j += 1
            length = int(s[i:j])
            res.append(s[j + 1: j + 1 + length])
            i = j + 1 + length
        return res
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n^2), Space complexity: O(n)

C) Time complexity: O(n log n), Space complexity: O(n)

###### ID22

A:: =============================================  
**Answer**: A

The overall time complexity of the solution is determined by the number of characters in the strings list (strs). We iterate over all characters twice: once when encoding and once when decoding. Therefore, the time complexity is linear. The space complexity is also linear because the encoded string has the same number of characters as the original strings list plus the length of each string and a colon for each string.

#### Chapter 9 - Longest Consecutive Sequence (Blind)

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

For a given array of integers, what is the time complexity of finding the length of the longest consecutive sequence using sorting?

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID23

A:: =============================================  
**Answer**: B

Sorting an array generally takes O(n log n) time. Once the array is sorted, you could iterate through the array once to find the longest consecutive sequence, which would take O(n) time. However, the dominating factor is the sorting time complexity, thus the overall time complexity is O(n log n).

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

Suppose we are counting the length of a sequence starting at an arbitrary value, say `n = 1.` To extend this sequence, we need to efficiently check for the existence of the next integer `(n + 1)`, regardless of its index in the original array. Which data structure would best serve this purpose?

A) Priority Queue

B) HashSet

C) Binary Search Tree

D) Array

###### ID24

A:: =============================================  
**Answer**: B

A HashSet can be used to efficiently check the existence of elements in O(1) average time complexity. When extending a sequence, this property is essential, allowing us to determine if the next integer (n + 1) exists in the original array, regardless of its position.

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

Consider the array `[1, 2, 3, 4, 5, 6]`. If we naively iterate through this array, treating each element `n` as the potential start of a sequence, we would check for the existence of each subsequent number `n + 1`. What would be the time complexity of such an approach?

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID25

A:: =============================================  
**Answer**: C

For every element in the array, except for 6, the follow-up element n + 1 does exist. So for each element, in the worst case, we would iterate n - 1 times to build each sequence, resulting in a time complexity of O(n^2).

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

Consider the array `[100, 4, 200, 1, 3, 2]`. This array contains two sequences: `[1, 2, 3, 4]` and `[100, 200]`. What common trait do the starting elements `1` and `100` share, which suggests they are the beginning of these sequences?

A) They are the smallest numbers in their respective sequences.

B) The element (n - 1) does not exist in the array.

C) The element (n + 1) does exist in the array.

D) They are the largest numbers in their respective sequences.

###### ID26

A:: =============================================  
**Answer**: B

The key observation is that for any number 'n' to be the start of a sequence, the number (n - 1) must not exist in the array. This is because if (n-1) exists, 'n' would be part of a sequence starting at least from (n-1). In this case, for '1' and '100', neither '0' nor '99' exist in the array, indicating that '1' and '100' can indeed be the starting points of their sequences.

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

Knowing that an element 'n' is the start of a sequence if (n - 1) does not exist in the array, how could we efficiently solve this problem using a hashset?

A) Add all elements to the hashset. Then, for each element 'n', if (n - 1) is not in the hashset, check and count the longest sequence starting from 'n'.

B) Add all elements to the hashset. Then, for each element 'n', if (n + 1) is in the hashset, check and count the longest sequence starting from 'n'.

###### ID27

A:: =============================================  
**Answer**: A

We then iterate through each element 'n' and if (n - 1) is not in the hashset, we check for the longest sequence starting from 'n'. This is because if (n-1) does not exist, 'n' must be the starting point of a sequence. We then check for the existence of (n + 1), (n + 2), and so on in the hashset, and count the length of the sequence. This approach ensures that we don't repeatedly check the same sequence and keeps the time complexity to O(n).

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

What is the time and space complexity of the optimal solution using a HashSet and avoiding unnecessary checks?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID28

A:: =============================================  
**Answer**: A

The HashSet solution has a time complexity of O(n) because you need to iterate through the array twice (once for building the HashSet and once for checking the sequences). The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the HashSet.

### Part II - Two Pointers

#### Chapter 1 - Valid Palindrome (Blind)

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

Given a string, what is a crucial step in the initial preprocessing to determine whether it is a palindrome?

A) Reverse the string.

B) Convert the string to lowercase.

C) Check if the string is empty.

D) Split the string into words.

###### ID29

A:: =============================================  
**Answer**: B

A crucial step to check if a string is a palindrome is to convert it to lowercase. This is because palindromes are case-insensitive. However, it's important to note that removing non-alphanumeric characters is another critical preprocessing step not mentioned in this particular question.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

After converting the string to lowercase, what should be the next step?

A) Reverse the string.

B) Check if the string is empty.

C) Remove all non-alphanumeric characters.

D) Convert the string to uppercase.

###### ID30

A:: =============================================  
**Answer**: C

The next step is to remove all non-alphanumeric characters. This is because palindromes only consider alphanumeric characters.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

Once the string has been converted to lowercase and all non-alphanumeric characters have been removed, what is the final step to determine if it's a palindrome?

A) Convert the string to uppercase.

B) Check if the string is equal to its reverse.

C) Check if the string is empty.

D) Split the string into words.

###### ID31

A:: =============================================  
**Answer**: B

The final step to check if a string is a palindrome is to compare it to its reversed version. If they are the same, then the string is a palindrome.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

What is the time and space complexity of the approach where we create a new reversed string to compare?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID32

A:: =============================================  
**Answer**: A

The time complexity is O(n) because all operations (lowercase conversion, removing non-alphanumeric characters, and reversing the string) take linear time. The 'n' here is the length of the string. The space complexity is also O(n) because we are creating a new string for the reversed version, which can be as long as the input string.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

Is there a way to check if a string is a palindrome without creating a new string for the reversed version?

A) No, it's not possible.

B) Yes, by using two pointers.

C) Yes, by sorting the string.

D) Yes, by using a stack.

###### ID33

A:: =============================================  
**Answer**: B

Yes, it is possible. You can use two pointers: one starting from the beginning of the string and the other from the end. If the characters at both pointers are equal, we increment the left pointer and decrement the right pointer. If they are not equal, then the string is not a palindrome. This approach avoids creating a new string for the reversed version, thus saving space.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

What are the time and space complexities of the two-pointer approach to check if a string is a palindrome?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID34

A:: =============================================  
**Answer**: D

The time complexity is O(n) because in the worst case, we would have to compare every character in the string with its counterpart from the end. Here, 'n' is the length of the string. This is still linear time complexity. The space complexity is O(1) because no extra space proportional to the size of the input is used. The two pointers used do not scale with the input size.

#### Chapter 2 - Two Sum II

#### Chapter 3 - 3Sum (Blind)

Q:: =============================================  

##### Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```

**Example 2:**

```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```

**Example 3:**

```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

**Constraints:**

-   `3 <= nums.length <= 3000`
-   `10^5 <= nums[i] <= 10^5`

___

What is a brute-force approach to solving this problem and what is the time complexity of this approach?

A) Iterate through all possible combinations of three elements, O(n^3) time complexity

B) Iterate through all elements, creating pair sums in a hash table, O(n^2) time complexity

C) Sort the array and apply binary search for each element, O(n^2 log n) time complexity

###### ID35

A:: =============================================  
**Answer**: A

The brute force approach would be to iterate through all possible triplets in the list and check if their sum is equal to zero. This would involve three nested loops and thus would have a time complexity of O(n^3).

Q:: =============================================  

##### Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```

**Example 2:**

```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```

**Example 3:**

```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

**Constraints:**

-   `3 <= nums.length <= 3000`
-   `10^5 <= nums[i] <= 10^5`

___

How can we find the optimal solution by using sorting?

A) Sort the array and use two pointers, decreasing the time complexity to O(n^2)

B) Sort the array and use binary search, decreasing the time complexity to O(n^2 log n)

C) Sorting cannot help in optimizing this problem

###### ID36

A:: =============================================  
**Answer**: A

By sorting the array, we can iterate through the array once and then use a two-pointer approach for each iteration. The two pointers can move towards each other until they meet, checking if the sum of the elements at the pointers equals the negative of the current element. This reduces the time complexity to O(n^2). A binary search approach will also work, but is less efficient.

Q:: =============================================  

##### Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```

**Example 2:**

```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```

**Example 3:**

```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

**Constraints:**

-   `3 <= nums.length <= 3000`
-   `10^5 <= nums[i] <= 10^5`

___

How can we ensure that our solution does not contain duplicate triplets?

A) By checking if a triplet has already been added to a hash set

B) By skipping over duplicate elements in the sorted array

C) Both A and B

###### ID37

A:: =============================================  
**Answer**: C

Both methods can be used to avoid duplicate triplets. We can check if a triplet is already in our solution before adding it, or we can skip over duplicate elements in our sorted array, since any triplet containing these duplicates would have already been found.

Q:: =============================================  

##### Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```

**Example 2:**

```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```

**Example 3:**

```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

**Constraints:**

-   `3 <= nums.length <= 3000`
-   `10^5 <= nums[i] <= 10^5`

___

How does the two-pointer approach help in eliminating duplicates in the output?

A) It doesn't, duplicates must be handled separately

B) By skipping over duplicate elements in the sorted array after finding a valid triplet, and also when choosing the first number in the triplet

C) By checking if the current triplet is already in the output before adding it

###### ID38

A:: =============================================  
**Answer**: B

When we find a valid triplet, we increment the left pointer until we find a new value. This ensures that we do not add the same triplet multiple times when the array contains duplicates. Additionally, when choosing the first number for our triplet, if this number is the same as the previous number, we can skip it. This is because any valid triplets including this number would have already been found in the previous iteration. These steps effectively eliminate duplicate solutions in the final result set.

Q:: =============================================  

##### Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation:
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
```

**Example 2:**

```
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
```

**Example 3:**

```
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
```

**Constraints:**

-   `3 <= nums.length <= 3000`
-   `10^5 <= nums[i] <= 10^5`

___

Given the optimized solution using sorting and a two-pointer approach, what is the overall time and space complexity?

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        
        for i, a in enumerate(nums):
            if i > 0 and a == nums[i - 1]:
                # We already used nums[i] as the 
                # first element, so skip it
                continue

            # Use two pointers on the remaining
            # sorted subarray to solve a + b + c = 0
            l, r = i + 1, len(nums) - 1
            while l < r:
                threeSum = a + nums[l] + nums[r]
                if threeSum > 0:
                    r -= 1
                elif threeSum < 0:
                    l += 1
                else:
                    # Solution found
                    res.append([a, nums[l], nums[r]])
                    l += 1
                    while nums[l] == nums[l - 1] and l < r:
                        # Eliminate duplicates by incrementing 
                        # left ptr until new nums[l] is found
                        l += 1
        return res
```

A) Time complexity: O(n^2), Space complexity: O(1)

B) Time complexity: O(n^2), Space complexity: O(n)

C) Time complexity: O(n log n), Space complexity: O(n)

###### ID39

A:: =============================================  
**Answer**: A

The time complexity is O(n^2) because we iterate through the array once (which is O(n)), and for each iteration, we potentially go through the rest of the array using the two-pointer approach (which is also O(n)), thus resulting in O(n^2). The space complexity is O(1) since we aren't using additional space, other than the output.

#### Chapter 4 - Container With Most Water (Blind)

Q:: =============================================  

##### You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/abc2d8fd-6012-4f88-7674-f6302aaf4200/public)

**Example 1:**

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```

**Example 2:**

```
Input: height = [1,1]
Output: 1
```

**Constraints:**

-   `n == height.length`
-   `2 <= n <= 10^5`
-   `0 <= height[i] <= 10^4`

___

The problem is about finding two lines that together with the x-axis form a container such that the container contains the most water. Which of the following is the key factor that determines the amount of water a container can hold?

A) The height of the shortest line

B) The height of the tallest line

C) The distance between the two lines

D) Both A and C

###### ID40

A:: =============================================  
**Answer**: D

The amount of water a container can hold is determined by the height of the shortest line (since water will overflow from the shorter line) and the distance between the two lines (since a wider container can hold more water).

Q:: =============================================  

##### You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/abc2d8fd-6012-4f88-7674-f6302aaf4200/public)

**Example 1:**

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```

**Example 2:**

```
Input: height = [1,1]
Output: 1
```

**Constraints:**

-   `n == height.length`
-   `2 <= n <= 10^5`
-   `0 <= height[i] <= 10^4`

___

Consider a brute-force solution where you calculate the area for all possible pairs of lines. What would be the time complexity of such an approach?

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID41

A:: =============================================  
**Answer**: C

In a brute-force solution, you would have two nested loops to calculate the area for all pairs of lines. There are n\*(n-1)/2 unique pairs, so the time complexity is O(n^2).

Q:: =============================================  

##### You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/abc2d8fd-6012-4f88-7674-f6302aaf4200/public)

**Example 1:**

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```

**Example 2:**

```
Input: height = [1,1]
Output: 1
```

**Constraints:**

-   `n == height.length`
-   `2 <= n <= 10^5`
-   `0 <= height[i] <= 10^4`

___

When considering the parameters that affect the amount of water a container can hold, we know that the distance between the two lines is important. Given this, where should we initially place the two pointers in order to maximize the chance of finding the largest possible area?

A) In the middle of the array

B) At the shortest and tallest lines

C) At the two ends of the array

D) At random positions in the array

###### ID42

A:: =============================================  
**Answer**: C

To maximize the initial area, we should start with the widest possible container, by placing the two pointers at the two ends of the array. This allows us to be greedy and maximize the distance between the two lines. From there, we can move the pointers inward to explore other possible containers.

Q:: =============================================  

##### You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/abc2d8fd-6012-4f88-7674-f6302aaf4200/public)

**Example 1:**

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```

**Example 2:**

```
Input: height = [1,1]
Output: 1
```

**Constraints:**

-   `n == height.length`
-   `2 <= n <= 10^5`
-   `0 <= height[i] <= 10^4`

___

Given the array height = \[1,8,6,2,5,4,8,3,7\], we start with the widest container, i.e., the first and the last line. Why is it impossible for us to find a new maximum area by leaving the left pointer at index = 0, and shifting the right pointer inwards?

A) Because the new container would be narrower but not taller.

B) Because the new container would be both narrower and taller.

C) Because the new container would be wider and not shorter.

###### ID43

A:: =============================================  
**Answer**: A

The amount of water a container can hold is determined by the height of the shorter line. If we move the pointer at the taller line, the new container will be narrower (since the distance between the lines decreases), and it can't be taller (since the height is still limited by the shorter line). Therefore, there’s no need to consider anymore containers where the left pointer is at index = 0, since they will always be smaller than the current maximum.

Q:: =============================================  

##### You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/abc2d8fd-6012-4f88-7674-f6302aaf4200/public)

**Example 1:**

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```

**Example 2:**

```
Input: height = [1,1]
Output: 1
```

**Constraints:**

-   `n == height.length`
-   `2 <= n <= 10^5`
-   `0 <= height[i] <= 10^4`

___

The two-pointer technique ensures that we don't need to enumerate all n^2 combinations of pointers to find the maximal solution. How does the technique achieve this?

A) By ensuring that every element in the array is guaranteed to have a pointer land on it at some point.

B) By skipping combinations that will never lead to a more maximal solution.

C) Both A and B.

D) None of the above.

###### ID44

A:: =============================================  
**Answer**: C

The two-pointer technique starts with the widest possible container and moves the pointers inward, always choosing the pointer at the shorter line to move. This ensures that every element in the array is guaranteed to have a pointer land on it at some point. It also avoids unnecessary combinations by skipping those that won't lead to a larger area (i.e., those where the container would be narrower but not taller). This solution is based on a ‘proof by contradiction’. Since we are being greedy and only skipping combinations that won’t lead to a new maximum, we are guaranteed to find the solution.

Q:: =============================================  

##### You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return _the maximum amount of water a container can store_.

**Notice** that you may not slant the container.

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/abc2d8fd-6012-4f88-7674-f6302aaf4200/public)

**Example 1:**

```
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
```

**Example 2:**

```
Input: height = [1,1]
Output: 1
```

**Constraints:**

-   `n == height.length`
-   `2 <= n <= 10^5`
-   `0 <= height[i] <= 10^4`

___

What is the time and space complexity of the solution using the two-pointer technique?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID45

A:: =============================================  
**Answer**: D

The two-pointer solution has a time complexity of O(n) because you need to iterate through the array once. The space complexity is O(1) as we only use two pointers and a few variables to keep track of the maximum area, regardless of the size of the input array.

#### Chapter 5 - Trapping Rain Water

### Part III - Sliding Window

#### Chapter 1 - Best Time to Buy and Sell Stock (Blind)

Q:: =============================================  

##### You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

_Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`._

Example 1:

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

___

What is the brute-force approach to solving this problem?

A) Sorting the array and running binary search to find the difference between the minimum and maximum prices.

B) Calculating the profit for each valid pair of buying and selling days, and finding the maximum profit.

C) Sorting the array and finding the difference between the minimum and maximum prices.

D) Creating a new array with the differences between consecutive prices and finding the maximum difference.

###### ID46

A:: =============================================  
**Answer**: B

The correct brute-force approach is to calculate the profit for each valid pair of buying and selling days, and then find the maximum profit. For each day, we calculate the profit for every other day in the future. We keep track of the maximum profit seen.

Q:: =============================================  

##### You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

_Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`._

Example 1:

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

___

We can also solve this by iterating through the array once, while keeping track of just two values. What two values should we keep track of to maximize the profit?

A) The maximum and minimum prices in the array.

B) The minimum price found so far and the maximum profit found so far.

C) The difference between each pair of prices and the maximum price found so far.

D) The maximum profit found so far and the index of the minimum price found so far.

###### ID47

A:: =============================================  
**Answer**: B

We should keep track of the minimum price found so far and the maximum profit found so far. By keeping track of these two values, we can calculate the maximum potential profit at each step while iterating through the array.

Q:: =============================================  

##### You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

_Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`._

Example 1:

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

___

How will we use the minimum price found so far and the maximum profit found so far to efficiently solve this problem?

A) Using Kadane’s greedy algorithm.

B) Find the minimum price in the array, and for every other price compute the profit, until we find the maximum profit.

C) Iterate through the prices, if we find a new minimum price then update it. Compute the profit between the current price and the minimum price, if it exceeds the maximum profit, then update it.

###### ID48

A:: =============================================  
**Answer**: C

We iterate through the prices, and for each price, if it is lower than the current minimum price, we update the minimum price. Then, we compute the profit by subtracting the current minimum from the current price. If this profit is greater than the current maximum profit, we update the maximum profit.

Q:: =============================================  

##### You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

_Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`._

Example 1:

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

___

What is the time complexity of the optimal solution?

A) O(1)

B) O(n)

C) O(n^2)

D) O(2^n)

###### ID49

A:: =============================================  
**Answer**: B

The optimal solution has a time complexity of O(n), where n is the number of days (or the length of the input array). This is because we're iterating through the array just once.

Q:: =============================================  

##### You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

_Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`._

Example 1:

```
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
```

___

What is the space complexity of the optimal solution?

A) O(1)

B) O(n)

C) O(n^2)

D) O(2^n)

###### ID50

A:: =============================================  
**Answer**: A

The optimal solution has a constant space complexity, O(1), as we are only keeping track of two variables (minimum price and maximum profit), regardless of the size of the input array.

#### Chapter 2 - Longest Substring Without Repeating Characters (Blind)

Q:: =============================================  

##### Given a string `s`, find the length of the **longest** **substring** without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**

-   `0 <= s.length <= 5 * 104`
-   `s` consists of English letters, digits, symbols and spaces.

___

What is a brute force solution to this problem?

A) Check each character and its subsequent characters for equality.

B) Generate all possible substrings and check each for repeated characters.

###### ID51

A:: =============================================  
**Answer**: B

The brute force solution for this problem would be to generate all possible substrings of the given string and check each of them for repeated characters. We would then keep track of the length of the longest substring without repeated characters.

Q:: =============================================  

##### Given a string `s`, find the length of the **longest** **substring** without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**

-   `0 <= s.length <= 5 * 104`
-   `s` consists of English letters, digits, symbols and spaces.

___

As we build a substring, what kind of data structure can we use to keep track of the characters we have already seen?

A) Stack

B) Queue

C) Hash Set

D) Heap

###### ID52

A:: =============================================  
**Answer**: C

A Set is a data structure that maintains a collection of unique elements. It provides constant-time complexity for search, insertion, and deletion, making it a suitable choice for tracking unique characters in a string.

Q:: =============================================  

##### Given a string `s`, find the length of the **longest** **substring** without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**

-   `0 <= s.length <= 5 * 104`
-   `s` consists of English letters, digits, symbols and spaces.

___

What approach can we use to solve this problem efficiently?

A) Divide and Conquer

B) Sliding Window

C) Recursion

###### ID53

A:: =============================================  
**Answer**: B

The sliding window approach allows us to scan through the string once (linear time complexity) while keeping track of the longest substring without repeating characters. It's an optimal strategy for this problem as it avoids unnecessary repeated computations.

Q:: =============================================  

##### Given a string `s`, find the length of the **longest** **substring** without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**

-   `0 <= s.length <= 5 * 104`
-   `s` consists of English letters, digits, symbols and spaces.

___

What can we do when we encounter a repeating character while expanding our window?

A) Remove the repeating character from our data structure and continue expanding.

B) Shrink the window from the left until the repeating character is no longer in the window.

C) Discard the current window and start a new window from the next character.

###### ID54

A:: =============================================  
**Answer**: B

When we encounter a repeating character, it means we need to shrink the window from the left until the repeating character is no longer in the window, as we are searching for substrings without repeating characters.

Q:: =============================================  

##### Given a string `s`, find the length of the **longest** **substring** without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**

-   `0 <= s.length <= 5 * 104`
-   `s` consists of English letters, digits, symbols and spaces.

___

Considering the constraint that `s` consists of English letters, digits, symbols, and spaces, what is the maximum possible size of our window?

A) 26

B) 52

C) 95

###### ID55

A:: =============================================  
**Answer**: C

In ASCII, there are 95 printable characters: 26 lowercase English letters, 26 uppercase English letters, 10 digits (0-9), 32 special characters and symbols, and the space character. This makes a total of 95 unique characters. Even if you don’t know there are exactly 95, it reasonable that there would be more than 52 (26 uppercase, 26 lowercase).

Q:: =============================================  

##### Given a string `s`, find the length of the **longest** **substring** without repeating characters.

**Example 1:**

```
Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```

**Example 2:**

```
Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```

**Example 3:**

```
Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.
```

**Constraints:**

-   `0 <= s.length <= 5 * 104`
-   `s` consists of English letters, digits, symbols and spaces.

___

What is the time and space complexity of the sliding window approach for this problem? Assume `n` is the length of the string, and `m` is the number of distinct characters in the string.

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        char_set = set()
        l, max_len = 0, 0
        
        for r in range(len(s)):
            while s[r] in char_set:
                # Repeating char detected, shrink window
                char_set.remove(s[l])
                l += 1
            char_set.add(s[r])
            max_len = max(max_len, r - l + 1)
        return max_len
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(m)

C) Time complexity: O(n^2), Space complexity: O(m)

###### ID56

A:: =============================================  
**Answer**: B

Using the sliding window approach, we essentially scan through the string once with two pointers, making the time complexity O(n). The space complexity is O(m) because, in the worst-case scenario, the set used to check for repeating characters can contain all the distinct characters in the string, where m is the number of distinct characters.

#### Chapter 3 - Longest Repeating Character Replacement (Blind)

Q:: =============================================  

##### You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**

```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```

**Example 2:**

```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achive this answer too.
```

**Constraints:**

-   `1 <= s.length <= 105`
-   `s` consists of only uppercase English letters.
-   `0 <= k <= s.length`

___

What is a brute force solution to this problem?

A) Iterate from the end of the string to the beginning, checking for duplicate characters.

B) For each substring, find the frequency of the most common character (maxf) and check if the length of the substring minus maxf is less than or equal to k.

###### ID57

A:: =============================================  
**Answer**: B

The brute force solution would be to generate all possible substrings and for each substring, find the frequency of the most common character. If the length of the substring minus the frequency of the most common character is less than or equal to k, then the substring is valid (since we can change at most k characters to make all characters in the substring the same). We would then keep track of the maximum length of such valid substrings.

Q:: =============================================  

##### You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**

```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```

**Example 2:**

```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achive this answer too.
```

**Constraints:**

-   `1 <= s.length <= 105`
-   `s` consists of only uppercase English letters.
-   `0 <= k <= s.length`

___

What kind of data structure could help us track the frequency of each character in the current window of our string?

A) Queue

B) Array

C) Hash Map

D) Either B or C

###### ID58

A:: =============================================  
**Answer**: D

Both an Array and a Hash Map can be used to efficiently count the frequency of elements. By keeping a frequency count of characters in our current window, we can determine the most frequent character. In the case of an Array, we could use each index to represent a unique character from the string (i.e., 'A' to 'Z' mapped to 0 to 25). In the case of a Hash Map, we would use the character itself as the key and the frequency as the value. Both methods allow us to update and access the frequency of each character in constant time.

Q:: =============================================  

##### You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**

```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```

**Example 2:**

```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achive this answer too.
```

**Constraints:**

-   `1 <= s.length <= 105`
-   `s` consists of only uppercase English letters.
-   `0 <= k <= s.length`

___

Considering an efficient approach, what strategy could we use to solve this problem efficiently?

A) Divide and Conquer

B) Two pointers with sliding window

C) Recursion

###### ID59

A:: =============================================  
**Answer**: B

The two pointers with sliding window strategy allows us to scan through the string in linear time complexity while keeping track of the longest substring with the same letters. The sliding window size changes based on the character frequency and the number of operations allowed.

Q:: =============================================  

##### You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**

```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```

**Example 2:**

```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achive this answer too.
```

**Constraints:**

-   `1 <= s.length <= 105`
-   `s` consists of only uppercase English letters.
-   `0 <= k <= s.length`

___

If our current window size minus the frequency of the most common character is greater than k, what should we do?

A) Expand the window from the right

B) Shrink the window from the left

C) Increase k

D) Change the character at the left of the window

###### ID60

A:: =============================================  
**Answer**: B

If the window size minus the frequency of the most common character is greater than k, it means we cannot make all characters the same in this window by changing k characters. Therefore, we need to shrink the window from the left.

Q:: =============================================  

##### You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**

```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```

**Example 2:**

```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achive this answer too.
```

**Constraints:**

-   `1 <= s.length <= 105`
-   `s` consists of only uppercase English letters.
-   `0 <= k <= s.length`

___

Considering that the given string only contains uppercase English letters (from A to Z), what would be the time complexity of finding the most frequent character in the window?

A) O(1)

B) O(n)

C) O(logn)

###### ID61

A:: =============================================  
**Answer**: A

Since we know that the string only contains uppercase English letters, there can be at most 26 unique characters. Thus, if we were to iterate through each unique character in our frequency dictionary or array to find the most frequent one, the time complexity would be O(26), which is essentially constant time, O(1).

Q:: =============================================  

##### You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.

Return _the length of the longest substring containing the same letter you can get after performing the above operations_.

**Example 1:**

```
Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
```

**Example 2:**

```
Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achive this answer too.
```

**Constraints:**

-   `1 <= s.length <= 105`
-   `s` consists of only uppercase English letters.
-   `0 <= k <= s.length`

___

What is the time and space complexity of the sliding window approach for this problem? Assume `n` is the length of the string.

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        res = 0
        l = 0
        count = [0] * 26
        for r in range(len(s)):
            count[ord(s[r]) - ord('A')] += 1
            while (r - l + 1) - max(count) > k:
                count[ord(s[l]) - ord('A')] -= 1
                l += 1
            res = max(res, r - l + 1)
        return res
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

###### ID62

A:: =============================================  
**Answer**: A

The sliding window approach only scans the string once, and the time complexity is therefore O(n). The space complexity is O(1) because the count array always has a fixed size of 26, corresponding to the number of uppercase English letters. Even though we're dealing with a string of n characters, we're only ever tracking a maximum of 26 different ones.

#### Chapter 4 - Permutation in String

#### Chapter 5 - Minimum Window Substring (Blind)

Q:: =============================================  

##### Given two strings `s` and `t` of lengths `m` and `n` respectively, return the _**minimum window substring**_ of `s` such that every character in `t` (_**including duplicates**_) is included in the window. If there is no such substring, return the empty string `""`.

The testcases will be generated such that the answer is **unique**.

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token string">"aa"</span>
Output: <span class="token string">""</span>
Explanation: Both <span class="token string">'a'</span>s <span class="token keyword">from</span> t must be included <span class="token operator">in</span> the window<span class="token punctuation">.</span>
Since the largest window <span class="token keyword">of</span> s only has one <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">return</span> empty string<span class="token punctuation">.</span>
```

**Constraints:**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 10^5`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

What is a brute force solution for this problem?

A) Check all substrings of s to find if they contain all characters of t

B) Remove each character of s one by one and check if the remaining string contains t

C) Sort both s and t and check if t is a substring of s

###### ID63

A:: =============================================  
**Answer**: A

The brute force solution would be to generate all possible substrings of s and for each substring, check if it contains all characters of t including duplicates. Then we keep the shortest such valid substring.

Q:: =============================================  

##### Given two strings `s` and `t` of lengths `m` and `n` respectively, return the _**minimum window substring**_ of `s` such that every character in `t` (_**including duplicates**_) is included in the window. If there is no such substring, return the empty string `""`.

The testcases will be generated such that the answer is **unique**.

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token string">"aa"</span>
Output: <span class="token string">""</span>
Explanation: Both <span class="token string">'a'</span>s <span class="token keyword">from</span> t must be included <span class="token operator">in</span> the window<span class="token punctuation">.</span>
Since the largest window <span class="token keyword">of</span> s only has one <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">return</span> empty string<span class="token punctuation">.</span>
```

**Constraints:**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 10^5`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

What kind of data structure could help us track the frequency of each character in the current window of our string?

A) Linked List

B) Hash Map

C) Stack

###### ID64

A:: =============================================  
**Answer**: B

A Hash Map is a good data structure to efficiently track the frequency of each character in the current window. By using the character itself as the key and the frequency as the value, we can access and update the frequency of each character in constant time.

Q:: =============================================  

##### Given two strings `s` and `t` of lengths `m` and `n` respectively, return the _**minimum window substring**_ of `s` such that every character in `t` (_**including duplicates**_) is included in the window. If there is no such substring, return the empty string `""`.

The testcases will be generated such that the answer is **unique**.

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token string">"aa"</span>
Output: <span class="token string">""</span>
Explanation: Both <span class="token string">'a'</span>s <span class="token keyword">from</span> t must be included <span class="token operator">in</span> the window<span class="token punctuation">.</span>
Since the largest window <span class="token keyword">of</span> s only has one <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">return</span> empty string<span class="token punctuation">.</span>
```

**Constraints:**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 10^5`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

Considering an efficient approach, what strategy could we use to solve this problem?

A) Divide and Conquer

B) Two Pointers with Sliding Window

C) Binary Search

###### ID65

A:: =============================================  
**Answer**: B

The Two Pointers with Sliding Window strategy allows us to scan through the string in linear time complexity while keeping track of the smallest valid substring. We maintain a sliding window that always satisfies the condition of containing all characters of \`t\`.

Q:: =============================================  

##### Given two strings `s` and `t` of lengths `m` and `n` respectively, return the _**minimum window substring**_ of `s` such that every character in `t` (_**including duplicates**_) is included in the window. If there is no such substring, return the empty string `""`.

The testcases will be generated such that the answer is **unique**.

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token string">"aa"</span>
Output: <span class="token string">""</span>
Explanation: Both <span class="token string">'a'</span>s <span class="token keyword">from</span> t must be included <span class="token operator">in</span> the window<span class="token punctuation">.</span>
Since the largest window <span class="token keyword">of</span> s only has one <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">return</span> empty string<span class="token punctuation">.</span>
```

**Constraints:**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 10^5`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

What should we do if our current window doesn't contain all characters of `t`?

A) Expand the window from the right

B) Shrink the window from the left

C) Remove the window and create a new one

###### ID66

A:: =============================================  
**Answer**: A

If our current window does not contain all characters of \`t\`, it means we need to expand the window from the right in hope of including the missing characters.

Q:: =============================================  

##### Given two strings `s` and `t` of lengths `m` and `n` respectively, return the _**minimum window substring**_ of `s` such that every character in `t` (_**including duplicates**_) is included in the window. If there is no such substring, return the empty string `""`.

The testcases will be generated such that the answer is **unique**.

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token string">"aa"</span>
Output: <span class="token string">""</span>
Explanation: Both <span class="token string">'a'</span>s <span class="token keyword">from</span> t must be included <span class="token operator">in</span> the window<span class="token punctuation">.</span>
Since the largest window <span class="token keyword">of</span> s only has one <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">return</span> empty string<span class="token punctuation">.</span>
```

**Constraints:**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 10^5`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

If our current window contains all characters of `t`, what should we do to find the smallest valid window?

A) Expand the window from the right

B) Shrink the window from the left

C) Expand the window from the left

###### ID67

A:: =============================================  
**Answer**: B

If our current window already contains all characters of \`t\`, we try to shrink the window from the left to find the smallest window that still satisfies the condition. If we can't shrink it without losing a necessary character, we move on to expanding it from the right again.

Q:: =============================================  

##### Given two strings `s` and `t` of lengths `m` and `n` respectively, return the _**minimum window substring**_ of `s` such that every character in `t` (_**including duplicates**_) is included in the window. If there is no such substring, return the empty string `""`.

The testcases will be generated such that the answer is **unique**.

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token string">"aa"</span>
Output: <span class="token string">""</span>
Explanation: Both <span class="token string">'a'</span>s <span class="token keyword">from</span> t must be included <span class="token operator">in</span> the window<span class="token punctuation">.</span>
Since the largest window <span class="token keyword">of</span> s only has one <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">return</span> empty string<span class="token punctuation">.</span>
```

**Constraints:**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 10^5`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

How can we determine if our current window contains all characters of `t` without iterating through the entire hashmap?

A) By checking if the length of the window is greater than or equal to the length of \`t\`

B) By keeping track of two variables: the number of unique characters we have from \`t\` in our current window and the total unique characters needed from \`t\`

C) By sorting the hashmap and comparing it with \`t\`

###### ID68

A:: =============================================  
**Answer**: B

By maintaining two variables, \`have\` and \`need\`, we can efficiently check if our window contains all characters of \`t\`. \`need\` is the number of unique characters in \`t\`, and \`have\` is the number of unique characters in \`t\` that our window currently contains. Each time we add a character to our window that makes the count of that character match what's needed in \`t\`, we increment \`have\`. We know our window contains all characters of \`t\` when \`have\` equals \`need\`.

Q:: =============================================  

##### Given two strings `s` and `t` of lengths `m` and `n` respectively, return the _**minimum window substring**_ of `s` such that every character in `t` (_**including duplicates**_) is included in the window. If there is no such substring, return the empty string `""`.

The testcases will be generated such that the answer is **unique**.

**Example 1:**

```
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
```

**Example 2:**

```
Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
```

**Example 3:**

```
Input: s <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token string">"aa"</span>
Output: <span class="token string">""</span>
Explanation: Both <span class="token string">'a'</span>s <span class="token keyword">from</span> t must be included <span class="token operator">in</span> the window<span class="token punctuation">.</span>
Since the largest window <span class="token keyword">of</span> s only has one <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token keyword">return</span> empty string<span class="token punctuation">.</span>
```

**Constraints:**

-   `m == s.length`
-   `n == t.length`
-   `1 <= m, n <= 10^5`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

Given that the input strings only consist of lowercase or uppercase English characters, what is the time and space complexity of the sliding window approach below? Assume `n` is the length of `s` and `m` is the length of `t`.

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == '': return ''

        countT, window = {}, {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        have, need = 0, len(countT)
        res, resLen = [-1, -1], float('infinity')
        l = 0
        for r in range(len(s)):
            c = s[r]
            window[c] = 1 + window.get(c, 0)

            if c in countT and window[c] == countT[c]:
                have += 1

            while have == need:
                if (r - l + 1) < resLen:
                    res = [l, r]
                    resLen = (r - l + 1)
                window[s[l]] -= 1
                if s[l] in countT and window[s[l]] < countT[s[l]]:
                    have -= 1
                l += 1
        l, r = res
        return s[l:r+1] if resLen != float('infinity') else ''
```

A) Time complexity: O(n+m), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(m)

###### ID69

A:: =============================================  
**Answer**: A

The time complexity is O(n+m) as we go through both s and t once. The space complexity is O(1) because the countT and window dictionaries will at most contain 52 unique keys, corresponding to the 26 lowercase and 26 uppercase English letters, which is a constant number and does not grow with n or m.

#### Chapter 6 - Sliding Window Maximum

### Part IV - Stack

#### Chapter 1 - Valid Parentheses (Blind)

Q:: =============================================  

##### Given a string s containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.  
Open brackets must be closed in the correct order.  
Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

```
Input: s = "()[]{}"
Output: true
```

**Example 2:**

```
Input: s = "(]"
Output: false
```

**Constraints:**

-   `1 <= s.length <= 10^4`
-   `s` consists of parentheses only `'()[]{}'`

___

Consider the string s = "( \[ ) \]" . Is this string valid?

A) Yes

B) No

###### ID70

A:: =============================================  
**Answer**: B

Although every opening bracket has a matching closing bracket of the same type, they are not closed in the correct order. The first opening bracket is '(', but the first closing bracket after that is '\]', which is not the correct matching closing bracket.

Q:: =============================================  

##### Given a string s containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.  
Open brackets must be closed in the correct order.  
Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

```
Input: s = "()[]{}"
Output: true
```

**Example 2:**

```
Input: s = "(]"
Output: false
```

**Constraints:**

-   `1 <= s.length <= 10^4`
-   `s` consists of parentheses only `'()[]{}'`

___

At any point in the string, we can only close the most recent open bracket, and after we close a bracket we then want to close the next most recent open bracket. Which data structure would be most useful here?

A) Hashmap

B) Stack

C) Queue

D) Binary Tree

###### ID71

A:: =============================================  
**Answer**: B

A Stack is a LIFO (Last In First Out) data structure, which aligns well with this problem's requirements. When dealing with nested structures, like brackets, the most recently opened bracket must be the first one to be closed. This 'last opened, first closed' pattern is a characteristic behavior of a Stack, making it a suitable data structure to handle such scenarios.

Q:: =============================================  

##### Given a string s containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.  
Open brackets must be closed in the correct order.  
Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

```
Input: s = "()[]{}"
Output: true
```

**Example 2:**

```
Input: s = "(]"
Output: false
```

**Constraints:**

-   `1 <= s.length <= 10^4`
-   `s` consists of parentheses only `'()[]{}'`

___

Assume we iterate through the string s and we maintain a stack. What should we do when we encounter an open bracket?

A) Ignore it.

B) Check if it matches with the top element of the stack.

C) Push it onto the stack.

D) Pop the top element from the stack.

###### ID72

A:: =============================================  
**Answer**: C

When we encounter an open bracket, we should push it onto the stack. The stack is used to keep track of the open brackets that we have encountered but not yet closed.

Q:: =============================================  

##### Given a string s containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.  
Open brackets must be closed in the correct order.  
Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

```
Input: s = "()[]{}"
Output: true
```

**Example 2:**

```
Input: s = "(]"
Output: false
```

**Constraints:**

-   `1 <= s.length <= 10^4`
-   `s` consists of parentheses only `'()[]{}'`

___

Assume we iterate through the string s and we maintain a stack. What should we do when we encounter a closing bracket?

A) Ignore it.

B) Push it onto the stack.

C) Pop the top element from the stack and check if it matches with the current closing bracket.

D) Check if it matches with the bottom element of the stack.

###### ID73

A:: =============================================  
**Answer**: C

When we encounter a closing bracket, we should pop the top element from the stack and check if it is the matching opening bracket for the current closing bracket. If it is, we can continue; if it's not, or if the stack is empty, then the string is not valid.

Q:: =============================================  

##### Given a string s containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.  
Open brackets must be closed in the correct order.  
Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

```
Input: s = "()[]{}"
Output: true
```

**Example 2:**

```
Input: s = "(]"
Output: false
```

**Constraints:**

-   `1 <= s.length <= 10^4`
-   `s` consists of parentheses only `'()[]{}'`

___

After reaching the end of s, how do we know if the string is valid?

A) If the stack is empty.

B) If the stack is not empty.

C) If the last element in the stack is an open bracket.

D) If the last element in the stack is a closing bracket.

###### ID74

A:: =============================================  
**Answer**: A

If we have managed to close all open brackets while iterating through the string, the stack should be empty at the end. If the stack is not empty, it means there are some open brackets that were not closed, so the string is not valid.

Q:: =============================================  

##### Given a string s containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.  
Open brackets must be closed in the correct order.  
Every close bracket has a corresponding open bracket of the same type.

**Example 1:**

```
Input: s = "()[]{}"
Output: true
```

**Example 2:**

```
Input: s = "(]"
Output: false
```

**Constraints:**

-   `1 <= s.length <= 10^4`
-   `s` consists of parentheses only `'()[]{}'`

___

What is the time and space complexity of the solution using a stack? Assume the length of the input string is n.

A) Time: O(n), Space: O(1)

B) Time: O(n), Space: O(n)

C) Time: O(n), Space: O(n^2)

D) Time: O(n^2), Space: O(n)

###### ID75

A:: =============================================  
**Answer**: B

We are iterating through the string only once, where n is the length of the string. For each character, we are performing a constant amount of work (either pushing onto the stack or popping from it). Hence, the time complexity is O(n). In the worst-case scenario, all characters in the string are opening brackets, and we push all of them onto the stack. Hence, the space complexity is O(n), where n is the length of the string.

#### Chapter 2 - Min Stack

#### Chapter 3 - Evaluate Reverse Polish Notation

#### Chapter 4 - Generate Parentheses

#### Chapter 5 - Daily Temperatures

#### Chapter 6 - Car Fleet

#### Chapter 7 - Largest Rectangle in Histogram

### Part V - Binary Search

#### Chapter 1 - Binary Search

#### Chapter 2 - Search a 2D Matrix

#### Chapter 3 - Koko Eating Bananas

#### Chapter 4 - Search in Rotated Sorted Array (Blind)

Q:: =============================================  

##### There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 5000`
-   `-10^4 <= nums[i] <= 10^4`
-   `All values of nums are unique.`
-   `nums is an ascending array that is possibly rotated.`
-   `-10^4 <= target <= 10^4`

___

Suppose we have a normal sorted integer array. What is normally the optimal time complexity to find an element in it?

A) O(n)

B) O(log n)

C) O(n^2)

D) O(1)

###### ID76

A:: =============================================  
**Answer**: B

For a sorted array, binary search can be applied to find an element. The time complexity of binary search is O(log n).

Q:: =============================================  

##### There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 5000`
-   `-10^4 <= nums[i] <= 10^4`
-   `All values of nums are unique.`
-   `nums is an ascending array that is possibly rotated.`
-   `-10^4 <= target <= 10^4`

___

Now consider a sorted array that has been rotated at an unknown index. What is the time complexity of the _simplest_ (but non-optimal) solution to find an element in this array?

A) O(n)

B) O(log n)

C) O(n^2)

D) O(1)

###### ID77

A:: =============================================  
**Answer**: A

The simplest solution would be to perform a linear search, which has a time complexity of O(n).

Q:: =============================================  

##### There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 5000`
-   `-10^4 <= nums[i] <= 10^4`
-   `All values of nums are unique.`
-   `nums is an ascending array that is possibly rotated.`
-   `-10^4 <= target <= 10^4`

___

In a typical binary search, what is the first element we check to see if it's equal to the target?

A) The first element in the array

B) The last element in the array

C) The middle element in the array

D) The element at a random position in the array

###### ID78

A:: =============================================  
**Answer**: C

In a binary search, we first check the middle element of the array. If the target is equal to it, we're done. If the target is greater, we know our target must be in the right portion of the array, and if it's less, the target must be in the left portion.

Q:: =============================================  

##### There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 5000`
-   `-10^4 <= nums[i] <= 10^4`
-   `All values of nums are unique.`
-   `nums is an ascending array that is possibly rotated.`
-   `-10^4 <= target <= 10^4`

___

As we search the rotated sorted array, how can we use the current middle element to determine which half of the array we are currently inside?

A) Compare the middle element with nums\[0\].

B) Compare the middle element with nums\[length - 1\].

C) Compare the middle element with nums\[mid - 1\].

D) Either A or B.

###### ID79

A:: =============================================  
**Answer**: D

We can determine which half of the array we are currently inside by comparing the middle element with the first element (nums\[0\]) or the last element (nums\[length - 1\]). If the middle element is greater than or equal to nums\[0\], we are in the left portion of the array; otherwise, we are in the right sorted portion. Alternatively, if the middle element is less than or equal to nums\[length - 1\] we are in the right sorted portion, otherwise we are in the left portion.

Q:: =============================================  

##### There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 5000`
-   `-10^4 <= nums[i] <= 10^4`
-   `All values of nums are unique.`
-   `nums is an ascending array that is possibly rotated.`
-   `-10^4 <= target <= 10^4`

___

How can we determine if the target element belongs to the left or right portion of the array?

A) Compare the target with nums\[mid\].

B) Compare the target with nums\[0\] or nums\[length - 1\].

C) Compare the target with nums\[mid - 1\] and nums\[mid + 1\].

D) None of the above.

###### ID80

A:: =============================================  
**Answer**: B

We can determine if the target element belongs to the left or right portion of the array by comparing the target with the first element (nums\[0\]) or the last element (nums\[length - 1\]). If the target is greater than or equal to the first element, it belongs to the left portion of the array. If the target is less than the first element, it belongs to the right portion of the array.

Q:: =============================================  

##### There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 5000`
-   `-10^4 <= nums[i] <= 10^4`
-   `All values of nums are unique.`
-   `nums is an ascending array that is possibly rotated.`
-   `-10^4 <= target <= 10^4`

___

If we are in the left sorted half of the array, but the target element belongs in the right sorted half, where should we search relative to the mid pointer?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/90bcf494-c8c6-4c8e-5119-349868839200/public)

A) To the left of mid.

B) To the right of mid.

C) At the mid point.

D) This scenario is not possible.

###### ID81

A:: =============================================  
**Answer**: B

If we are in the left sorted half of the array, but the target element belongs to the right sorted half, we should continue our search to the right of the mid pointer.

Q:: =============================================  

##### There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 5000`
-   `-10^4 <= nums[i] <= 10^4`
-   `All values of nums are unique.`
-   `nums is an ascending array that is possibly rotated.`
-   `-10^4 <= target <= 10^4`

___

If we are in the right sorted half of the array, but the target element belongs in the left sorted half, where should we search relative to the mid pointer?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/37e384cf-75a6-4148-d389-0beb27f7ee00/public)

A) To the left of mid.

B) To the right of mid.

C) At the mid point.

D) This scenario is not possible.

###### ID82

A:: =============================================  
**Answer**: A

If we are in the right sorted half of the array, but the target element belongs to the left sorted half, we should continue our search to the left of the mid pointer.

Q:: =============================================  

##### There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 5000`
-   `-10^4 <= nums[i] <= 10^4`
-   `All values of nums are unique.`
-   `nums is an ascending array that is possibly rotated.`
-   `-10^4 <= target <= 10^4`

___

If we are in the appropriate half of the array, can we simply perform a normal binary search?

A) Yes

B) No

###### ID83

A:: =============================================  
**Answer**: A

Yes, if we are in the appropriate half of the array, we can simply perform a normal binary search. The normal binary search process involves comparing the target with the middle element and then deciding whether to continue the search in the left portion or the right portion of the array, depending on whether the target is less or greater than the middle element.

Q:: =============================================  

##### There is an integer array `nums` sorted in ascending order (with **distinct** values).

Prior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.

Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in `nums`, or `-1` if it is not in `nums`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**

```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 5000`
-   `-10^4 <= nums[i] <= 10^4`
-   `All values of nums are unique.`
-   `nums is an ascending array that is possibly rotated.`
-   `-10^4 <= target <= 10^4`

___

To summarize, the below code will solve this problem using an augmented binary search solution. What is the time and space complexity?

```python
def search(self, nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] >= nums[0] and target < nums[0]:
            # We're in left sorted array
            # But target is in right sorted array 
            left = mid + 1
        elif nums[mid] < nums[0] and target >= nums[0]:
            # We're in right sorted array
            # But target is in left sorted array 
            right = mid - 1
        # Otherwise: Normal binary search
        elif target > nums[mid]:
            left = mid + 1
        elif target < nums[mid]:
            right = mid - 1
        else:
            return mid
        
        return -1
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(log n), Space complexity: O(1)

C) Time complexity: O(n log n), Space complexity: O(n)

D) Time complexity: O(n^2), Space complexity: O(n)

###### ID84

A:: =============================================  
**Answer**: B

The binary search approach has a time complexity of O(log n) because in each step, you reduce the problem size by half. The space complexity is O(1) because you are not using any additional space that scales with the input size. You only need a constant amount of space to store the variables left, right, and mid.

#### Chapter 5 - Find Minimum in Rotated Sorted Array (Blind)

Q:: =============================================  

##### Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0, 1, 2, 4, 5, 6, 7]` might become:

-   `[4, 5, 6, 7, 0, 1, 2]` if it was rotated `4` times.
-   `[0, 1, 2, 4, 5, 6, 7]` if it was rotated `7` times.  
    Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```

**Constraints:**

-   `n == nums.length`
-   `1 <= n <= 5000`
-   `-5000 <= nums[i] <= 5000`
-   All the integers of `nums` are unique.
-   `nums` is sorted and rotated between `1` and `n` times.

___

Suppose we have a _normal_ sorted integer array. What is the time complexity to find the minimum element in this array?

A) O(n)

B) O(log n)

C) O(n^2)

D) O(1)

###### ID85

A:: =============================================  
**Answer**: D

In a sorted array, the minimum element is always at the beginning, which can be found in constant time, O(1).

Q:: =============================================  

##### Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0, 1, 2, 4, 5, 6, 7]` might become:

-   `[4, 5, 6, 7, 0, 1, 2]` if it was rotated `4` times.
-   `[0, 1, 2, 4, 5, 6, 7]` if it was rotated `7` times.  
    Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```

**Constraints:**

-   `n == nums.length`
-   `1 <= n <= 5000`
-   `-5000 <= nums[i] <= 5000`
-   All the integers of `nums` are unique.
-   `nums` is sorted and rotated between `1` and `n` times.

___

Now consider a sorted array that has been rotated at an unknown index. What is the time complexity of the _simplest_ (but non-optimal) solution to find the minimum element in this array?

A) O(n)

B) O(log n)

C) O(n^2)

D) O(1)

###### ID86

A:: =============================================  
**Answer**: A

The simplest solution would be to perform a linear search, which has a time complexity of O(n).

Q:: =============================================  

##### Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0, 1, 2, 4, 5, 6, 7]` might become:

-   `[4, 5, 6, 7, 0, 1, 2]` if it was rotated `4` times.
-   `[0, 1, 2, 4, 5, 6, 7]` if it was rotated `7` times.  
    Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```

**Constraints:**

-   `n == nums.length`
-   `1 <= n <= 5000`
-   `-5000 <= nums[i] <= 5000`
-   All the integers of `nums` are unique.
-   `nums` is sorted and rotated between `1` and `n` times.

___

In a typical binary search, what is the first element we check to see if it's the target?

A) The first element in the array

B) The last element in the array

C) The middle element in the array

D) The element at a random position in the array

###### ID87

A:: =============================================  
**Answer**: C

In a binary search, we first check the middle element of the array. Depending on the condition, we decide whether to proceed to the left half or the right half.

Q:: =============================================  

##### Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0, 1, 2, 4, 5, 6, 7]` might become:

-   `[4, 5, 6, 7, 0, 1, 2]` if it was rotated `4` times.
-   `[0, 1, 2, 4, 5, 6, 7]` if it was rotated `7` times.  
    Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```

**Constraints:**

-   `n == nums.length`
-   `1 <= n <= 5000`
-   `-5000 <= nums[i] <= 5000`
-   All the integers of `nums` are unique.
-   `nums` is sorted and rotated between `1` and `n` times.

___

In this case, our target is the minimum element. Which portion of the array will it be found?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/02eaac7f-445e-4d1c-d51b-48c7c6aa2d00/public)

A) The left sorted portion

B) The right sorted portion

###### ID88

A:: =============================================  
**Answer**: B

The minimum element will be found in the right sorted portion since every element in that portion will be less than every element in the left sorted portion. The minimum element will be the leftmost value in the right sorted portion.

Q:: =============================================  

##### Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0, 1, 2, 4, 5, 6, 7]` might become:

-   `[4, 5, 6, 7, 0, 1, 2]` if it was rotated `4` times.
-   `[0, 1, 2, 4, 5, 6, 7]` if it was rotated `7` times.  
    Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```

**Constraints:**

-   `n == nums.length`
-   `1 <= n <= 5000`
-   `-5000 <= nums[i] <= 5000`
-   All the integers of `nums` are unique.
-   `nums` is sorted and rotated between `1` and `n` times.

___

If the current portion of our search range from left to right is already sorted, e.g. `nums[l] < nums[r]`, then which element is the minimum of the current search range?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/958a3861-e7b7-4da8-8561-544714ca8400/public)

A) nums\[m\]

B) nums\[l\]

C) nums\[r\]

D) None of the above.

###### ID89

A:: =============================================  
**Answer**: B

In a normal sorted array, the leftmost element is the minimum. In our case, if the original array is rotated n times, the minimum will be nums\[0\]. Alternatively, as we run binary search, if the current subarray of our search is a normal sorted array, we can end the binary search.

Q:: =============================================  

##### Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0, 1, 2, 4, 5, 6, 7]` might become:

-   `[4, 5, 6, 7, 0, 1, 2]` if it was rotated `4` times.
-   `[0, 1, 2, 4, 5, 6, 7]` if it was rotated `7` times.  
    Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```

**Constraints:**

-   `n == nums.length`
-   `1 <= n <= 5000`
-   `-5000 <= nums[i] <= 5000`
-   All the integers of `nums` are unique.
-   `nums` is sorted and rotated between `1` and `n` times.

___

If the middle element is less than the first element of the array, where is the minimum element?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/33828cf2-4d4e-42d0-e429-b03e49111500/public)

A) At the mid point.

B) At the mid point or to the left of mid.

C) To the right of mid.

###### ID90

A:: =============================================  
**Answer**: B

If the middle element is less than the first element, it means the middle element is in the right sorted portion. The smallest element will always be found in the right sorted portion, so either the middle element is the minimum or the minimum is to the left of mid.

Q:: =============================================  

##### Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0, 1, 2, 4, 5, 6, 7]` might become:

-   `[4, 5, 6, 7, 0, 1, 2]` if it was rotated `4` times.
-   `[0, 1, 2, 4, 5, 6, 7]` if it was rotated `7` times.  
    Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```

**Constraints:**

-   `n == nums.length`
-   `1 <= n <= 5000`
-   `-5000 <= nums[i] <= 5000`
-   All the integers of `nums` are unique.
-   `nums` is sorted and rotated between `1` and `n` times.

___

If the middle element is greater than or equal to the first element of the array, where is the minimum element?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c5da4e6e-997d-4ccc-952d-9dd0360f9200/public)

A) To the left of mid.

B) To the right of mid.

C) At the mid point.

D) This scenario is not possible.

###### ID91

A:: =============================================  
**Answer**: B

If the middle element is greater than the first element, it means the middle element is in the left sorted portion, but the minimum must be found in the right sorted portion.

Q:: =============================================  

##### Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0, 1, 2, 4, 5, 6, 7]` might become:

-   `[4, 5, 6, 7, 0, 1, 2]` if it was rotated `4` times.
-   `[0, 1, 2, 4, 5, 6, 7]` if it was rotated `7` times.  
    Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**

```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```

**Example 2:**

```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```

**Example 3:**

```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
```

**Constraints:**

-   `n == nums.length`
-   `1 <= n <= 5000`
-   `-5000 <= nums[i] <= 5000`
-   All the integers of `nums` are unique.
-   `nums` is sorted and rotated between `1` and `n` times.

___

To summarize, the below code will solve this problem using an augmented binary search solution. What is the time and space complexity?

```python
def findMin(self, nums: List[int]) -> int:
    res = nums[0]
    l, r = 0, len(nums) - 1

    while l <= r:
        if nums[l] < nums[r]:
            return min(res, nums[l])

        m = (l + r) // 2
        res = min(res, nums[m])
        if nums[m] >= nums[l]:
            # We are in the left sorted portion, move right
            l = m + 1
        else:
            # We are in the right sorted portion, move left
            r = m - 1
    return res
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(log n), Space complexity: O(1)

C) Time complexity: O(n log n), Space complexity: O(n)

D) Time complexity: O(n^2), Space complexity: O(n)

###### ID92

A:: =============================================  
**Answer**: B

The binary search approach has a time complexity of O(log n) because in each step, you reduce the problem size by half. The space complexity is O(1) because you are not using any additional space that scales with the input size. You only need a constant amount of space to store the variables left, right, and mid.

#### Chapter 6 - Time Based Key-Value Store

#### Chapter 7 - Median of Two Sorted Arrays

### Part VI - Linked List

#### Chapter 1 - Reverse Linked List (Blind)

Q:: =============================================  

##### Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/b57f05e4-bd0a-4d71-2066-bfad19f84300/public)

```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/21b14354-6a3a-45e0-8d02-ecc7ec7f7300/public)

```
Input: head = [1,2]
Output: [2,1]
```

**Example 3:**

```
Input: head = []
Output: []
```

**Constraints:**

-   The number of nodes in the list is the range `[0, 5000]`.
-   `5000 <= Node.val <= 5000`

___

If we have a linked list with only one node, what will be the result after reversing it?

A) An empty linked list

B) The same linked list

###### ID93

A:: =============================================  
**Answer**: B

Reversing a linked list with only one node doesn't change anything. It remains the same, as there are no other nodes to rearrange.

Q:: =============================================  

##### Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/b57f05e4-bd0a-4d71-2066-bfad19f84300/public)

```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/21b14354-6a3a-45e0-8d02-ecc7ec7f7300/public)

```
Input: head = [1,2]
Output: [2,1]
```

**Example 3:**

```
Input: head = []
Output: []
```

**Constraints:**

-   The number of nodes in the list is the range `[0, 5000]`.
-   `5000 <= Node.val <= 5000`

___

In order to reverse a linked list, we need to change the direction of which part of each node?

A) The node's value

B) The node's 'next' reference

###### ID94

A:: =============================================  
**Answer**: B

In a singly linked list, each node has a value and a 'next' reference pointing to the next node in the list. To reverse the list, we need to change the 'next' reference of each node to point to the previous node.

Q:: =============================================  

##### Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/b57f05e4-bd0a-4d71-2066-bfad19f84300/public)

```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/21b14354-6a3a-45e0-8d02-ecc7ec7f7300/public)

```
Input: head = [1,2]
Output: [2,1]
```

**Example 3:**

```
Input: head = []
Output: []
```

**Constraints:**

-   The number of nodes in the list is the range `[0, 5000]`.
-   `5000 <= Node.val <= 5000`

___

What could be a simple, but also optimal approach to reverse a linked list?

A) Recursively reverse the linked list in-place.

B) Use a stack to reverse the values of the linked list in-place.

C) Traverse the list once, and for each node, set its 'next' to the previous node.

###### ID95

A:: =============================================  
**Answer**: C

Recursion or using a stack would require additional space and isn't necessary. By traversing the list and updating the 'next' reference of each node to point to the previous node, we can achieve the desired result.

Q:: =============================================  

##### Given the `head` of a singly linked list, reverse the list, and return _the reversed list_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/b57f05e4-bd0a-4d71-2066-bfad19f84300/public)

```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/21b14354-6a3a-45e0-8d02-ecc7ec7f7300/public)

```
Input: head = [1,2]
Output: [2,1]
```

**Example 3:**

```
Input: head = []
Output: []
```

**Constraints:**

-   The number of nodes in the list is the range `[0, 5000]`.
-   `5000 <= Node.val <= 5000`

___

What is the time and space complexity of the optimal approach?

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev, curr = None, head
        
        while curr: 
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        return prev
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n), Space complexity: O(1)

C) Time complexity: O(1), Space complexity: O(1)

###### ID96

A:: =============================================  
**Answer**: B

The time complexity is O(n) because we need to traverse the list once, where n is the number of nodes in the list. The space complexity is O(1) because we are not using any additional space that scales with the size of the input. We only use a few variables to keep track of the previous and current nodes during the process.

#### Chapter 2 - Merge Two Sorted Lists (Blind)

Q:: =============================================  

##### You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return _the head of the merged linked list_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6bafdf72-dfb3-4085-9372-f34e7361d700/public)

```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

**Example 2:**

```
Input: list1 = [], list2 = []
Output: []
```

**Example 3:**

```
Input: list1 = [], list2 = [0]
Output: [0]
```

**Constraints:**

-   The number of nodes in both lists is in the range `[0, 50]`.
-   `100 <= Node.val <= 100`
-   Both `list1` and `list2` are sorted in **non-decreasing** order.

___

If we have two sorted linked lists, where should we start comparing elements to begin merging them into a single sorted list?

A) From the middle of each list.

B) From the last element of each list.

C) From the first element of each list.

###### ID97

A:: =============================================  
**Answer**: C

As both lists are sorted in non-decreasing order, the smallest elements are at the heads of the lists. Hence, we should start comparing from the first elements of each list to create the new sorted list.

Q:: =============================================  

##### You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return _the head of the merged linked list_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6bafdf72-dfb3-4085-9372-f34e7361d700/public)

```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

**Example 2:**

```
Input: list1 = [], list2 = []
Output: []
```

**Example 3:**

```
Input: list1 = [], list2 = [0]
Output: [0]
```

**Constraints:**

-   The number of nodes in both lists is in the range `[0, 50]`.
-   `100 <= Node.val <= 100`
-   Both `list1` and `list2` are sorted in **non-decreasing** order.

___

When comparing the first nodes of each list, which node should we insert into the output list?

A) The node with the larger value.

B) The node with the smaller value.

C) Any node, the choice doesn't matter.

###### ID98

A:: =============================================  
**Answer**: B

To maintain the sorted order in the output list, we should always insert the node with the smaller value first. If there’s a tie, we can insert either node. This ensures that we are always adding the smallest remaining element to the merged list.

Q:: =============================================  

##### You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return _the head of the merged linked list_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6bafdf72-dfb3-4085-9372-f34e7361d700/public)

```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

**Example 2:**

```
Input: list1 = [], list2 = []
Output: []
```

**Example 3:**

```
Input: list1 = [], list2 = [0]
Output: [0]
```

**Constraints:**

-   The number of nodes in both lists is in the range `[0, 50]`.
-   `100 <= Node.val <= 100`
-   Both `list1` and `list2` are sorted in **non-decreasing** order.

___

How should we proceed after inserting a node from one of the lists into the output list?

A) Insert the node from the other list into the output list.

B) Shift to the next node in both lists and repeat the comparison.

C) Shift to the next node in the list from which we inserted the node and repeat the comparison.

###### ID99

A:: =============================================  
**Answer**: C

After inserting a node from one of the lists into the output list, we should shift to the next node in the same list. We've already considered the inserted node in the sorting process. Now, it's time to compare the next node from this list with the current node from the other list.

Q:: =============================================  

##### You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return _the head of the merged linked list_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6bafdf72-dfb3-4085-9372-f34e7361d700/public)

```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

**Example 2:**

```
Input: list1 = [], list2 = []
Output: []
```

**Example 3:**

```
Input: list1 = [], list2 = [0]
Output: [0]
```

**Constraints:**

-   The number of nodes in both lists is in the range `[0, 50]`.
-   `100 <= Node.val <= 100`
-   Both `list1` and `list2` are sorted in **non-decreasing** order.

___

What if one list becomes empty (all of its nodes are used up) before the other during the merging process?

A) Discard the remaining nodes in the other list.

B) Append the remaining nodes in the other list to the merged list.

C) Pick nodes from the exhausted list randomly to fill up the merged list.

###### ID100

A:: =============================================  
**Answer**: B

If one list becomes empty before the other, we can safely append the remaining nodes from the other list to the merged list. As both lists are sorted, the remaining nodes will also be in sorted order.

Q:: =============================================  

##### You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists in a one **sorted** list. The list should be made by splicing together the nodes of the first two lists.

Return _the head of the merged linked list_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6bafdf72-dfb3-4085-9372-f34e7361d700/public)

```
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```

**Example 2:**

```
Input: list1 = [], list2 = []
Output: []
```

**Example 3:**

```
Input: list1 = [], list2 = [0]
Output: [0]
```

**Constraints:**

-   The number of nodes in both lists is in the range `[0, 50]`.
-   `100 <= Node.val <= 100`
-   Both `list1` and `list2` are sorted in **non-decreasing** order.

___

What is the time complexity and space complexity of this approach? Assume `m` and `n` are the lengths of list1 and list2 respectively.

```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        current = dummy

        while l1 and l2:
            if l1.val <= l2.val:
                current.next = l1
                l1 = l1.next
            else:
                current.next = l2
                l2 = l2.next
            current = current.next

        current.next = l1 if l1 is not None else l2
        return dummy.next
```

A) Time complexity: O(m+n), Space complexity: O(1)

B) Time complexity: O(m\*n), Space complexity: O(m+n)

C) Time complexity: O(m+n), Space complexity: O(m+n)

###### ID101

A:: =============================================  
**Answer**: A

The time complexity is O(m+n) because in the worst case, we'll have to traverse all nodes of both lists once. The space complexity is O(1) because we're not using any additional space that scales with the input size. We are simply rearranging the existing nodes.

#### Chapter 3 - Reorder List (Blind)

Q:: =============================================  

##### You are given the head of a singly linked-list. The list can be represented as:

```
L0 → L1 → … → Ln - 1 → Ln
```

_Reorder the list to be on the following form:_

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/034d3a04-1ca6-4c81-8a7a-648658944600/public)

```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/80f9be46-c7d9-43bb-b072-3bbfd7942500/public)

```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
```

**Constraints:**

-   The number of nodes in the list is in the range `[1, 5 * 10^4]`.
-   `1 <= Node.val <= 1000`

___

Given the list L0 → L1 → … → Ln - 1 → Ln, what is the first step to reorder the list to the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …?

A) Reversing the entire list.

B) Reversing the second half of the list.

C) Swapping the first and the last node.

###### ID102

A:: =============================================  
**Answer**: B

To get to the required order, we first need to reverse the second half of the list. This is because the second half of the list is to be interweaved with the first half, but in the reverse order.

Q:: =============================================  

##### You are given the head of a singly linked-list. The list can be represented as:

```
L0 → L1 → … → Ln - 1 → Ln
```

_Reorder the list to be on the following form:_

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/034d3a04-1ca6-4c81-8a7a-648658944600/public)

```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/80f9be46-c7d9-43bb-b072-3bbfd7942500/public)

```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
```

**Constraints:**

-   The number of nodes in the list is in the range `[1, 5 * 10^4]`.
-   `1 <= Node.val <= 1000`

___

How can you find the middle node of a singly linked list?

A) Starting from the head, move to the next node until you find the middle node.

B) Use two pointers: a slow pointer moving one step at a time, and a fast pointer moving two steps at a time.

###### ID103

A:: =============================================  
**Answer**: B

We use a technique known as the 'tortoise and the hare' to find the middle of a singly linked list. The slow pointer moves one step at a time while the fast pointer moves two steps at a time. By the time the fast pointer reaches the end of the list, the slow pointer will be at the middle.

Q:: =============================================  

##### You are given the head of a singly linked-list. The list can be represented as:

```
L0 → L1 → … → Ln - 1 → Ln
```

_Reorder the list to be on the following form:_

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/034d3a04-1ca6-4c81-8a7a-648658944600/public)

```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/80f9be46-c7d9-43bb-b072-3bbfd7942500/public)

```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
```

**Constraints:**

-   The number of nodes in the list is in the range `[1, 5 * 10^4]`.
-   `1 <= Node.val <= 1000`

___

After reversing the second half of the list, how do you reorder the list to the required form?

A) By appending the second half of the list to the first half.

B) By alternating nodes from the first and second half of the list.

C) By concatenating the first half of the list to the second half.

###### ID104

A:: =============================================  
**Answer**: B

After reversing the second half of the list, we reorder the list by alternating nodes from the first and second half of the list.

Q:: =============================================  

##### You are given the head of a singly linked-list. The list can be represented as:

```
L0 → L1 → … → Ln - 1 → Ln
```

_Reorder the list to be on the following form:_

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/034d3a04-1ca6-4c81-8a7a-648658944600/public)

```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/80f9be46-c7d9-43bb-b072-3bbfd7942500/public)

```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
```

**Constraints:**

-   The number of nodes in the list is in the range `[1, 5 * 10^4]`.
-   `1 <= Node.val <= 1000`

___

In the code, what approach is used to merge the two halves of the list into the required form?

A) A new list is created and nodes from both halves are added alternately.

B) Corresponding nodes from the first and second half of the list are swapped.

C) At each step, a node is unlinked from the second half and linked into the first half.

###### ID105

A:: =============================================  
**Answer**: C

The provided code merges the two halves by iterating through the first half of the list. At each step, it unlinks a node from the second half and links it into the first half. This results in the desired ordering of nodes.

Q:: =============================================  

##### You are given the head of a singly linked-list. The list can be represented as:

```
L0 → L1 → … → Ln - 1 → Ln
```

_Reorder the list to be on the following form:_

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

You may not modify the values in the list's nodes. Only nodes themselves may be changed.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/034d3a04-1ca6-4c81-8a7a-648658944600/public)

```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/80f9be46-c7d9-43bb-b072-3bbfd7942500/public)

```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
```

**Constraints:**

-   The number of nodes in the list is in the range `[1, 5 * 10^4]`.
-   `1 <= Node.val <= 1000`

___

Consider the following code for reordering a linked list. What is its time complexity and space complexity?

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reorderList(self, head: ListNode) -> None:
        # find middle
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # reverse second half
        second = slow.next
        prev = slow.next = None
        while second:
            tmp = second.next
            second.next = prev
            prev = second
            second = tmp

        # merge two halves
        first, second = head, prev
        while second:
            tmp1, tmp2 = first.next, second.next
            first.next = second
            second.next = tmp1
            first, second = tmp1, tmp2
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

###### ID106

A:: =============================================  
**Answer**: A

This approach has a linear time complexity O(n) because we are making a single pass to find the middle, a single pass to reverse the second half, and a single pass to merge the two halves. The space complexity is O(1) because we are rearranging the nodes in-place without using additional storage proportional to the input size.

#### Chapter 4 - Remove Nth Node From End of List (Blind)

Q:: =============================================  

##### Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/23a28313-7f20-49b4-9781-fcf45a598100/public)

```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```

**Example 2:**

```
Input: head = [1], n = 1
Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 1
Output: [1]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

**Follow up:** Could you do this in one pass?

___

In order to remove a node `x` from a singly linked list, which node do we need access to?

A) Node x

B) Node before x

C) Node after x

###### ID107

A:: =============================================  
**Answer**: B

To remove a node x from a singly linked list, we need access to the node before x. This is because in a singly linked list, we can only navigate in one direction and there's no reference to the previous node from a given node. By having access to the node before x, we can adjust its next reference to bypass x, effectively removing x from the list.

Q:: =============================================  

##### Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/23a28313-7f20-49b4-9781-fcf45a598100/public)

```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```

**Example 2:**

```
Input: head = [1], n = 1
Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 1
Output: [1]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

**Follow up:** Could you do this in one pass?

___

An edge case is where we must remove the first node in the list. What is a simple way to eliminate this edge case?

A) Add a dummy node at the end of the list.

B) Add a dummy node at the beginning of the list.

C) There is no way to eliminate this edge case.

###### ID108

A:: =============================================  
**Answer**: B

To eliminate the edge case of removing the first node in the list, we can add a dummy node at the beginning of the list. This dummy node won't affect the other operations, but allows us to handle the head of the list in a consistent way with other nodes.

Q:: =============================================  

##### Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/23a28313-7f20-49b4-9781-fcf45a598100/public)

```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```

**Example 2:**

```
Input: head = [1], n = 1
Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 1
Output: [1]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

**Follow up:** Could you do this in one pass?

___

If we were to solve this problem without precomputing the length of the list, but instead using two pointers, what should the _offset_ between the two pointers be? Assume we will iterate until the second pointer reaches null.  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c6af2817-4885-47c2-9f04-8e9603192500/public)

A) n

B) n + 1

C) n - 1

###### ID109

A:: =============================================  
**Answer**: B

If we are to solve this problem using two pointers without precomputing the length of the list, the offset between the two pointers should be n + 1. This ensures that the second pointer reaches null right when the first pointer gets to the node before the target node, which is the nth node from the end of the list.

Q:: =============================================  

##### Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/23a28313-7f20-49b4-9781-fcf45a598100/public)

```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```

**Example 2:**

```
Input: head = [1], n = 1
Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 1
Output: [1]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

**Follow up:** Could you do this in one pass?

___

After we have created the offset, by how much should we shift each pointer on each iteration of the loop?

A) First pointer by 1, Second pointer by 2

B) First pointer by 1, Second pointer by 1

###### ID110

A:: =============================================  
**Answer**: B

After we have created the offset, we should shift each pointer by 1 on each iteration of the loop. This ensures that the offset (the gap between the two pointers) remains constant while traversing the list, allowing us to find the node to be removed.

Q:: =============================================  

##### Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/23a28313-7f20-49b4-9781-fcf45a598100/public)

```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```

**Example 2:**

```
Input: head = [1], n = 1
Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 1
Output: [1]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

**Follow up:** Could you do this in one pass?

___

What is the time and space complexity of the two-pointer approach for this problem? Assume `n` is the length of the list.

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = ListNode(0, head)
        left = dummy
        right = head

        while n > 0: // Create offset
            right = right.next
            n -= 1

        while right:
            left = left.next
            right = right.next

        left.next = left.next.next // delete
        return dummy.next
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

###### ID111

A:: =============================================  
**Answer**: A

The two-pointer approach has a linear time complexity of O(n). We perform a constant amount of work for each node (moving the pointers and eventually deleting a node). The space complexity is O(1) as we are not using any extra space that scales with the input size, we're simply using two pointers to navigate the existing list.

#### Chapter 5 - Copy List with Random Pointer

#### Chapter 6 - Add Two Numbers

#### Chapter 7 - Linked List Cycle (Blind)

#### Chapter 8 - Find the Duplicate Number

#### Chapter 9 - LRU Cache

#### Chapter 10 - Merge k Sorted Lists (Blind)

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

What would be a straightforward but not necessarily optimal approach to solve this problem?

A) Sequentially merge the linked lists, starting from the first one

B) Reverse each linked list, and then merge

C) Select the last node from each list and create a new sorted list

D) Randomly pick two lists to merge until one list is left

###### ID112

A:: =============================================  
**Answer**: A

A straightforward approach for this problem would involve sequentially merging the linked lists, starting from the first one. This would involve merging the first two lists, then merging the result with the third list, and so on. While this approach is simple, it may not be the most efficient in terms of time complexity.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

What would be the time complexity of the solution where you merge the linked lists one by one into the first linked list? Assume `n` is the total number of nodes, and `k` is the number of linked lists.

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(kn)

###### ID113

A:: =============================================  
**Answer**: D

When you merge two linked lists, the time complexity is proportional to the total number of nodes in the two lists. If you merge the linked lists one by one, you'll end up with a time complexity of O(kn) because each merge operation can potentially traverse all n nodes, and this operation is repeated k times.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

Given that all individual linked lists are already sorted, how can you take advantage of this to improve the time complexity?

A) By using a sorting algorithm that is more efficient on nearly sorted lists

B) By using a two-pointer technique to find pairs of nodes that sum to a target

C) By merging the linked lists two at a time

D) By using a priority queue to select the next smallest node

###### ID114

A:: =============================================  
**Answer**: D

Since all individual linked lists are sorted, you can use a priority queue (also known as a min-heap) to efficiently select the next smallest node from the heads of all the linked lists.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

If you use a priority queue to keep track of the smallest node in each linked list, what would be the time complexity of inserting an element into the queue?

A) O(1)

B) O(log k)

C) O(k)

D) O(n)

###### ID115

A:: =============================================  
**Answer**: B

The time complexity of inserting an element into a priority queue (or min-heap) is O(log k), where k is the number of linked lists (or the current size of the heap). Each insert operation might need to restructure the heap to maintain its properties, which takes logarithmic time.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

If you use a priority queue to select the smallest node from each linked list, what would be the time complexity for merging all the linked lists into one sorted list?

A) O(n log n)

B) O(n log k)

C) O(k log n)

D) O(n)

###### ID116

A:: =============================================  
**Answer**: B

If you use a priority queue, you are essentially removing the smallest element (head of some linked list) and then adding the next element from the same list. Each operation (insert/remove) would take O(log k) time. Since we are doing these operations for all 'n' nodes, the total time complexity would be O(n log k).

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

If you use a priority queue to select the smallest node from each linked list, what would be the space complexity for merging all the linked lists into one sorted list?

A) O(1)

B) O(n)

C) O(k)

D) O(n + k)

###### ID117

A:: =============================================  
**Answer**: C

In this case, the space complexity is O(k) because at any point, you only need to store the head nodes of each linked list in the priority queue. Here, k is the number of linked lists.

#### Chapter 11 - Reverse Nodes in k-Group

### Part VII - Trees

#### Chapter 1 - Invert Binary Tree (Blind)

Q:: =============================================  

##### Given the `root` of a binary tree, invert the tree, and return _its root_.

![Binary Tree Inverted](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9aeb8e98-e369-4a36-2c82-be3efcab4f00/public)

**Example 1:**

```
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
```

**Constraints:**

-   The number of nodes in the tree is in the range `[0, 100]`.
-   `-100 <= Node.val <= 100`

___

What does this binary tree look like after it has been inverted? ![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/3632af86-32d0-4224-fd47-1a9f311a8f00/public) 

A) ![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/00d65115-0868-4312-8050-b1b039ecda00/public) 

B) ![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/22600c7e-0bb6-4762-9959-370044446b00/public) 

###### ID118

A:: =============================================  
**Answer**: B

Inverting a binary tree means to make all left child nodes become right child nodes and vice versa. This is effectively the same as swapping the left and right child nodes for every node in the tree.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

Which tree traversal can be used to solve this problem?

A) Depth-First Search (DFS)

B) Breadth-First Search (BFS)

C) Neither DFS nor BFS

D) Both DFS and BFS

###### ID119

A:: =============================================  
**Answer**: D

Both Depth-First Search (DFS) and Breadth-First Search (BFS) could be used to solve this problem. Both methods would work because the order in which we visit the nodes doesn't matter in this problem, as long as every node’s children are swapped.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

If we were to use a recursive DFS approach to solve this problem, what would be the base case?

A) When we encounter a null node

B) When we encounter a leaf node

C) Neither A nor B

D) Either one of A or B would be a sufficient base case

###### ID120

A:: =============================================  
**Answer**: D

The base case for a recursive approach to this problem could be when we encounter a null node. This is because we cannot swap the left and right children of a null node. But an alternative base case could be when we encounter a leaf node, since the node doesn’t have any children to swap.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

With the recursive approach in mind, how would we invert a binary tree?

A) Swap the left and right children of the root node, then recursively invert the left and right subtrees

B) Recursively invert the left subtree, then the right subtree, then swap the left and right children of the root node

C) Recursively invert the right subtree, then the left subtree, then swap the left and right children of the root node

D) Any of the above.

###### ID121

A:: =============================================  
**Answer**: D

The recursive approach to inverting a binary tree would involve swapping the left and right children of the root node, as well as recursively inverting the left subtree, and the right subtree. But it doesn’t matter the order we execute these operations because none of them interfere with each other.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

What are the time and space complexities of the recursive solution to this problem? Assume the binary tree is balanced and contains n nodes.

A) Time complexity: O(1), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(log n)

C) Time complexity: O(n), Space complexity: O(n)

D) Time complexity: O(n^2), Space complexity: O(n^2)

###### ID122

A:: =============================================  
**Answer**: B

The time complexity of the recursive solution is O(n), where n is the number of nodes in the tree. This is because we have to visit every node in the tree once in order to swap its left and right children. The space complexity is O(log n) in the average case, because the maximum amount of space we'll need corresponds to the depth of the tree, which in a balanced binary tree is log(n). In the worst case scenario (a completely unbalanced tree), it could be O(n), but generally, we consider the average case for space complexity in recursive solutions.

#### Chapter 2 - Maximum Depth of Binary Tree (Blind)

Q:: =============================================  

##### Given the `root` of a binary tree, return _its maximum depth_.

A binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/4601cb74-8473-4e92-bf42-b0406178d900/public)

```
Input: root = [3,9,20,null,null,15,7]
Output: 3
```

**Example 2:**

```
Input: root = [1,null,2]
Output: 2
```

**Constraints:**

-   The number of nodes in the tree is in the range `[0, 10^4]`.
-   `100 <= Node.val <= 100`

___

What is the maximum depth of a binary tree with a single node?

A) 0

B) 1

C) 2

D) The depth is undefined for a single node tree.

###### ID123

A:: =============================================  
**Answer**: B

A tree with a single node (which is also the root) has a maximum depth of 1. The depth of a tree is the number of nodes along the longest path from the root node down to the farthest leaf node. Here, that path consists only of the root node itself.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

Which tree traversal technique could be utilized to find the maximum depth of a binary tree?

A) Depth-First Search (DFS)

B) Breadth-First Search (BFS)

C) Both DFS and BFS

D) Neither DFS nor BFS

###### ID124

A:: =============================================  
**Answer**: C

Both DFS and BFS can be used to solve this problem. Both methods would work because they both can explore the full depth of the tree. There is no inherent efficiency gain in this particular problem for DFS over BFS or vice versa, as we would need to traverse all nodes to ensure we've found the maximum depth.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

If we use a recursive DFS approach to solve this problem, what would be a sensible base case?

A) When we encounter a null node

B) When we encounter a node with only one child

C) There is no need for a base case

###### ID125

A:: =============================================  
**Answer**: A

A good base case for this problem could be when we encounter a null node. When we reach a null node, it indicates we've traversed all the way down one path of the tree and we've hit a leaf node in the previous step.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

Considering the recursive approach, how would we compute the maximum depth of a binary tree?

A) Compare the depth of the left subtree and the right subtree, then return the maximum plus 1

B) Add the depths of the left subtree and the right subtree

C) Return the depth of the left subtree if it is non-null, else return the depth of the right subtree

###### ID126

A:: =============================================  
**Answer**: A

The maximum depth of a binary tree is one more than the maximum of the depths of its left and right subtrees. So, we recursively compute the maximum depths of the left and right subtrees, and the maximum depth of the tree is the maximum of these two depths plus 1.

Q:: =============================================  

##### You are given an array of `k` linked-lists `lists`, each linked-list is sorted in ascending order.

_Merge all the linked-lists into one sorted linked-list and return it._

**Example 1:**

```
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
merging them into one sorted list:
1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
```

**Example 2:**

```
Input: lists = []
Output: []
```

**Example 3:**

```
Input: lists = [[]]
Output: []
```

**Constraints:**

-   `k == lists.length`
-   `0 <= k <= 10^4`
-   `0 <= lists[i].length <= 500`
-   `10^4 <= lists[i][j] <= 10^4`
-   `lists[i]` is sorted in **ascending order**.
-   The sum of `lists[i].length` will not exceed `10^4`.

___

Given the below Python function to solve the problem, what are the time and space complexities? Assume the binary tree is balanced.

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        return 1 + max(
            self.maxDepth(root.left),
            self.maxDepth(root.right)
        )
```

A) Time complexity: O(1), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(log n)

C) Time complexity: O(n), Space complexity: O(n)

###### ID127

A:: =============================================  
**Answer**: B

The time complexity of the recursive solution is O(n), where n is the number of nodes in the tree. We visit each node once, so the time complexity is proportional to the size of the tree. The space complexity is O(log n) in the average case (for a balanced tree), as we only need to store information up to the depth of the tree, which is log(n) for a balanced binary tree. In the worst case (a completely unbalanced tree), the space complexity could be O(n).

#### Chapter 3 - Diameter of Binary Tree

#### Chapter 4 - Balanced Binary Tree

#### Chapter 5 - Same Tree (Blind)

#### Chapter 6 - Subtree of Another Tree (Blind)

#### Chapter 7 - Lowest Common Ancestor of a Binary Search Tree (Blind)

#### Chapter 8 - Binary Tree Level Order Traversal (Blind)

#### Chapter 9 - Binary Tree Right Side View

#### Chapter 10 - Count Good Nodes in Binary Tree

#### Chapter 11 - Validate Binary Search Tree (Blind)

#### Chapter 12 - Kth Smallest Element in a BST (Blind)

#### Chapter 13 - Construct Binary Tree from Preorder and Inorder Traversal (Blind)

#### Chapter 14 - Binary Tree Maximum Path Sum (Blind)

#### Chapter 15 - Serialize and Deserialize Binary Tree (Blind)

### Part VIII - Trie

#### Chapter 1 - Implement Trie (Blind)

#### Chapter 2 - Design Add and Search Words Data Structure (Blind)

#### Chapter 3 - Word Search II (Blind)

### Part IX - Heap and Priority Queue

#### Chapter 1 - Kth Largest Element in a Stream

#### Chapter 2 - Last Stone Weight

#### Chapter 3 - K Closest Points to Origin

#### Chapter 4 - Kth Largest Element in an Array

#### Chapter 5 - Task Scheduler

#### Chapter 6 - Design Twitter

#### Chapter 7 - Find Median from Data Stream (Blind)

### Part X - Backtracking

#### Chapter 1 - Permutations

#### Chapter 2 - Sudoku Solver

#### Chapter 3 - Subsets

#### Chapter 4 - Combination Sum (Blind)

#### Chapter 5 - Subsets II

#### Chapter 6 - Word Search (Blind)

#### Chapter 7 - Palindrome Partitioning

#### Chapter 8 - Letter Combinations of a Phone Number

#### Chapter 9 - N-Queens

### Part XI - Graphs

#### Chapter 1 - Number of Islands (Blind)

#### Chapter 2 - Clone Graph (Blind)

#### Chapter 3 - Max Area of Island

#### Chapter 4 - Pacific Atlantic Water Flow (Blind)

#### Chapter 5 - Surrounded Regions

#### Chapter 6 - Rotting Oranges

#### Chapter 7 - Walls and Gates

#### Chapter 8 - Course Schedule (Blind)

#### Chapter 9 - Course Schedule II

#### Chapter 10 - Redundant Connection

#### Chapter 11 - Number of Connected Components In An Undirected Graph (Blind)

#### Chapter 12 - Graph Valid Tree (Blind)

#### Chapter 13 - Word Ladder

### Part XII - Advance Graphs

#### Chapter 1 - Reconstruct Itinerary

---

DECK INFO

TARGET DECK: Data Structures and Algorithms::Leetcode::MNAB - Neetcode 150 and blind 75 - multi-author

FILE TAGS: #DSA::#Leetcode

Tags:

Reference:

Related:

```dataview
LIST
where file.name = this.file.name
```