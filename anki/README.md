# MNAB - Neetcode 150 and blind 75 - multi-author

## Questions

| ID | File name / path | Part | Chapter |
| --- | --- | --- | --- |
| **-** | **Arrays and Hashing** | **1** | **-** |
| **-** | **Arrays and Hashing > Contains Duplicate Blind** | **1** | **1** |
| [1](#id1) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/1%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| [2](#id2) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/2%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| [3](#id3) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/3%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| [4](#id4) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/4%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| [5](#id5) | [Given an integer array nums return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20Blind/5%20-%20Given%20an%20integer%20array%20nums%20return%20tru.md) | 1 | 1 |
| **-** | **Arrays and Hashing > Valid Anagram Blind** | **1** | **2** |
| [6](#id6) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/6%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [7](#id7) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/7%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [8](#id8) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/8%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [9](#id9) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/9%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [10](#id10) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/10%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| [11](#id11) | [Given two strings s and t return tru](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%202%20-%20Valid%20Anagram%20Blind/11%20-%20Given%20two%20strings%20s%20and%20t%20return%20tru.md) | 1 | 2 |
| **-** | **Arrays and Hashing > Two Sum Blind** | **1** | **3** |
| [12](#id12) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/12%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [13](#id13) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/13%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [14](#id14) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/14%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [15](#id15) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/15%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [16](#id16) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/16%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [17](#id17) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/17%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| [18](#id18) | [Given an array of integers nums and an i](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%203%20-%20Two%20Sum%20Blind/18%20-%20Given%20an%20array%20of%20integers%20nums%20and%20an%20i.md) | 1 | 3 |
| **-** | **Arrays and Hashing > Encode and Decode Strings Blind** | **1** | **8** |
| [19](#id19) | [Design an algorithm to encode a list of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%208%20-%20Encode%20and%20Decode%20Strings%20Blind/19%20-%20Design%20an%20algorithm%20to%20encode%20a%20list%20of.md) | 1 | 8 |
| [20](#id20) | [Design an algorithm to encode a list of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%208%20-%20Encode%20and%20Decode%20Strings%20Blind/20%20-%20Design%20an%20algorithm%20to%20encode%20a%20list%20of.md) | 1 | 8 |
| [21](#id21) | [Design an algorithm to encode a list of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%208%20-%20Encode%20and%20Decode%20Strings%20Blind/21%20-%20Design%20an%20algorithm%20to%20encode%20a%20list%20of.md) | 1 | 8 |
| [22](#id22) | [Design an algorithm to encode a list of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%208%20-%20Encode%20and%20Decode%20Strings%20Blind/22%20-%20Design%20an%20algorithm%20to%20encode%20a%20list%20of.md) | 1 | 8 |
| **-** | **Arrays and Hashing > Longest Consecutive Sequence Blind** | **1** | **9** |
| [23](#id23) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/23%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [24](#id24) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/24%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [25](#id25) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/25%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [26](#id26) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/26%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [27](#id27) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/27%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| [28](#id28) | [Given an unsorted array of integers nums](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20and%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20Blind/28%20-%20Given%20an%20unsorted%20array%20of%20integers%20nums.md) | 1 | 9 |
| **-** | **Two Pointers** | **2** | **-** |
| **-** | **Two Pointers > Valid Palindrome Blind** | **2** | **1** |
| [29](#id29) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/29%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [30](#id30) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/30%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [31](#id31) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/31%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [32](#id32) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/32%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [33](#id33) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/33%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |
| [34](#id34) | [A phrase is a palindrome if after con](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20Blind/34%20-%20A%20phrase%20is%20a%20palindrome%20if%20after%20con.md) | 2 | 1 |

### Part I - Arrays and Hashing

#### Chapter 1 - Contains Duplicate (Blind)

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

How many possible pairs of elements are there in an array of size n?

A) log n

B) n

C) n^2

D) 2^n

###### ID1

A:: =============================================  
**Answer**: C

There are exactly n \* (n - 1) / 2 distinct pairs of integers in the array. This is equivalent to (n^2 - n) / 2, and we normally consider the largest term, which in this case is n^2.

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

What is the time complexity of a brute force approach, where you compare every possible pair in the array to check if there are any duplicates?

A) O(n)

B) O(n * log n)

C) O(n^2)

D) O(2^n)

###### ID2

A:: =============================================  
**Answer**: C

The brute-force solution using two nested loops has a time complexity of O(n^2) because for each element in the array, you need to iterate over up to n other elements.

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

What data structure can you use to optimize the approach for checking if there are any duplicate elements in the array?

A) Queue

B) Priority Queue

C) Stack

D) Hashmap or HashSet

###### ID3

A:: =============================================  
**Answer**: D

A Hashmap (or Hashtable) and a HashSet allow us to store and retrieve values in constant time, O(1). We can utilize this property to efficiently check for duplicates.

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

How can a HashSet be used to efficiently check for duplicates in the array?

A) Iterate through each element in the array and try to insert it into the HashSet. If an insertion fails (the element already exists in the HashSet), return true to indicate a duplicate was found.

B) Insert all elements from the array into the HashSet without checking for duplicates during this process. After all insertions, compare the size of the HashSet with the size of the array. If the HashSet size is smaller, return true to indicate a duplicate exists.

C) Both A and B

###### ID4

A:: =============================================  
**Answer**: C

A HashSet does not allow duplicate values. So, if you try to insert an element that already exists in the HashSet, it will not add the element and you know you've found a duplicate (choice A). Alternatively, you could add all elements to the HashSet and then compare its size to the size of the array. If the sizes are different, then there must have been a duplicate in the array (choice B). Both these methods will help identify if a duplicate exists in the array.

Q:: =============================================  

##### Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: true
```

**Example 2:**

```
Input: nums = [1,2,3,4]
Output: false
```

**Constraints:**

-   `1 <= nums.length <= 10^5`
-   `10^9 <= nums[i] <= 10^9`

___

What is the time and space complexity of the solution using a hashmap?

A) Time complexity: O(n)  
Space complexity: O(n)

B) Time complexity: O(n \* log n)  
Space complexity: O(n)

C) Time complexity: O(n^2)  
Space complexity: O(1)

D) Time complexity: O(n)  
Space complexity: O(1)

###### ID5

A:: =============================================  
**Answer**: A

The hashmap solution has a time complexity of O(n) because you need to iterate through the array once. Also, the key lookup operation with hashmaps runs in O(1) time. The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the hashmap.

#### Chapter 2 - Valid Anagram (Blind)

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

What is the primary characteristic of an anagram?

A) Both words have the same length.

B) Both words have the same letters, in the same quantities.

C) Both words have the same first letter.

D) Both words have the same last letter.

###### ID6

A:: =============================================  
**Answer**: B

An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. This means both words have the same letters, in the same quantities. For example, 'Heart' is an anagram of 'Earth'.

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

Given the nature of anagrams, which of the following methods can be used to check if two words are anagrams?

A) Compare the lengths of two words. If they are equal, the words are anagrams.

B) Convert each word to an array, sort the arrays, and then compare them.

C) Check if the first letter of the first word is present in the second word.

###### ID7

A:: =============================================  
**Answer**: B

By converting each word to an array, sorting the arrays, and then comparing them, we can confirm if two words are anagrams. This is because anagrams have the same letters in the same quantities. For example, after sorting either 'heart' and 'earth', the result is 'aehrt'.

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

What is the time complexity of the solution that sorts and then compares the arrays? Note: We are using an efficient sorting algorithm where we can't make any assumptions about the character set.

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID8

A:: =============================================  
**Answer**: B

The time complexity of sorting an array of n elements is O(n log n), and the time complexity of comparing two arrays is O(n). When considering the largest term, the time complexity of the solution becomes O(n log n).

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

Given the nature of anagrams and the constraints of the problem, can you improve upon the overall time complexity of the sorting solution?

A) No, sorting and comparing is the most optimal solution.

B) Yes, by using a hashmap to store the count of letters.

C) Yes, by checking if the first and last letter of both words are the same.

###### ID9

A:: =============================================  
**Answer**: B

Given the constraints of the problem and the nature of anagrams, we can use a hashmap to store the count of letters for each string. This would allow us to compare the frequency of each letter in both strings in a more time-efficient way. The downside is we may need extra memory, compared to an in-place sorting algorithm.

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

If using a hashmap to check if two words are anagrams, what would be the keys and the values in the hashmap?

A) Keys = Words, Values = Count of each word

B) Keys = Letters, Values = Count of each letter

C) Keys = Length of words, Values = Words of that length

###### ID10

A:: =============================================  
**Answer**: B

In this case, the keys would be the letters, and the values would be the count of each letter. This way, we can track the frequency of each letter in the strings and compare them.

Q:: =============================================  

##### Given two strings `s` and `t`, return `true` _if `t` is an anagram of `s`, and `false` otherwise_.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

```
Input: s = "anagram", t = "nagaram"
Output: true
```

**Example 2:**

```
Input: s = "rat", t = "car"
Output: false
```

**Constraints:**

-   `1 <= s.length, t.length <= 5 * 10^4`
-   `s` and `t` consist of lowercase English letters.

___

What is the time and space complexity of the solution using a hashmap to count and compare the frequency of each letter?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID11

A:: =============================================  
**Answer**: A

The time complexity of this solution is O(n) because we iterate over the input strings once. The space complexity is also O(n) because in the worst-case scenario (where each letter is unique), we would need to store each letter in the hashmap.

#### Chapter 3 - Two Sum (Blind)

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

Roughly how many pairs of integers are there within the array? Assume the size of the array is `n`.

A) log n

B) n

C) n^2

D) 2^n

###### ID12

A:: =============================================  
**Answer**: C

There are exactly n \* (n - 1) / 2 distinct pairs of integers in the array. This is equivalent to (n^2 - n) / 2 and we normally care about the largest term, which in this case is n^2.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

How can you find all pairs of elements `x1, x2` within an array, which have a different index?

A) Sorting the array and using binary search to find a pair

B) Using two nested loops to iterate over all pairs of elements

C) Using divide and conquer to recursively find pairs

###### ID13

A:: =============================================  
**Answer**: B

To find all pairs of elements with different indices in the array, you can use two nested loops. The first loop iterates over each element, while the second loop only iterates over the elements to the right of the current element. This allows you to compare all possible pairs without duplicates.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

After finding each pair of elements, we can then easily determine the indices of the elements that sum to the target. What is the time complexity of this brute-force solution?

A) O(n)

B) O(n \* log n)

C) O(n^2)

D) O(2^n)

###### ID14

A:: =============================================  
**Answer**: C

The brute-force solution using two nested loops has a time complexity of O(n^2) because for each element in the array, you need to iterate over up to n other elements.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

For any given element `x` within the array, how many possible unique `y-values` would satisfy `target = x + y`?

A) 1

B) 2

C) n - 1

D) n

###### ID15

A:: =============================================  
**Answer**: A

We can solve this equation for y: y = target - x. For example, if target=9, and x=2, then y = 9 - 2 = 7. In mathematics, this value is known as the complement.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

Can you reduce the time complexity of the algorithm to find the indices of two numbers that add up to the target using a data structure?

A) No, the time complexity cannot be reduced

B) Yes, using a priority queue

C) Yes, using a hashmap

D) Yes, using a balanced binary search tree

###### ID16

A:: =============================================  
**Answer**: C

Yes, you can reduce the time complexity using a hashmap. A hashmap allows you to store and retrieve values in O(1) - constant time, which can help you find the required indices more efficiently than a brute-force solution.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

How can a hashmap be used to efficiently find the indices of two numbers that add up to the target in an array?

A) Key = Index of each element, Value = Difference between the target and the corresponding element;  
then for each element check if the difference between the target and the element exists as a value in the hashmap.

B) Key = Each element in the array, Value = The index of the corresponding element;  
then for each element check if the difference exists in the hashmap as a key, and that it has a different index from the current element.

###### ID17

A:: =============================================  
**Answer**: B

By storing each element in the array as a key and its index as the corresponding value in the hashmap, you can efficiently find the required pair. For each element, you can efficiently calculate the difference and check if it’s a key within the hashmap. If it does, we can get the index from the hashmap. If the index of the difference is different from the index of the current element (remember we are not allowed reuse the same element twice), then you've found the solution.

Q:: =============================================  

##### Given an array of integers `nums` and an integer `target`, _return indices of the two numbers such that they add up to `target`_.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

___

What is the time and space complexity of the optimal solution using a hashmap?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n \* log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID18

A:: =============================================  
**Answer**: A

The hashmap solution has a time complexity of O(n) because you need to iterate through the array once. Also, the key lookup operation with hashmaps runs in O(1) time. The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the hashmap.

#### Chapter 4 - Group Anagrams (Blind)

#### Chapter 5 - Top K Frequent Elements (Blind)

#### Chapter 6 - Product of Array Except Self (Blind)

#### Chapter 7 - Valid Sudoku

#### Chapter 8 - Encode and Decode Strings (Blind)


Q:: =============================================  

##### Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example1**

```
Input: dummy_input = ["Hello", "World"]
Output: ["Hello", "World"]
Explanation:
Machine 1:
Codec encoder = new Codec();
String msg = encoder.encode(strs);
Machine 1 ---msg---&gt; Machine 2

Machine 2:
Codec decoder = new Codec();
String[] strs = decoder.decode(msg);
```

**Example2**

```
Input: dummy_input = [""]
Output: [""]
```

**Constraints:**

-   `1 <= strs.length <= 200`
-   `0 <= strs[i].length <= 200`
-   `strs[i] contains any possible characters out of 256 valid ASCII characters`

___

Given the constraint that `strs[i]` can contain any valid ASCII characters, including special ones, which encoding strategy should we use to ensure that our encoded message can be correctly decoded?

A) Separate strings in strs using a special character, such as a comma or a space.

B) Use a length-prefix followed by a special character for each string in strs.

C) Concatenate all the strings in strs directly.

###### ID19

A:: =============================================  
**Answer**: B

If we use a special character to separate the strings, it could be a problem if the string itself contains this special character. If we concatenate the strings directly, we can't distinguish where one string ends and another begins. Therefore, prefixing each string with its length followed by a special character allows us to correctly separate the strings during decoding, even if they contain special characters.

Q:: =============================================  

##### Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example1**

```
Input: dummy_input = ["Hello", "World"]
Output: ["Hello", "World"]
Explanation:
Machine 1:
Codec encoder = new Codec();
String msg = encoder.encode(strs);
Machine 1 ---msg---&gt; Machine 2

Machine 2:
Codec decoder = new Codec();
String[] strs = decoder.decode(msg);
```

**Example2**

```
Input: dummy_input = [""]
Output: [""]
```

**Constraints:**

-   `1 <= strs.length <= 200`
-   `0 <= strs[i].length <= 200`
-   `strs[i] contains any possible characters out of 256 valid ASCII characters`

___

What should the prefix look like to make the encoding efficient?

A) Prefix each string with the length of the entire list strs.

B) Prefix each string with its individual length followed by a delimiter.

C) Prefix each string with the sum of the lengths of all previous strings.

###### ID20

A:: =============================================  
**Answer**: B

Prefixing each string with its own length allows us to know exactly where each string starts and ends in the encoded string, which simplifies the decoding process.

Q:: =============================================  

##### Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example1**

```
Input: dummy_input = ["Hello", "World"]
Output: ["Hello", "World"]
Explanation:
Machine 1:
Codec encoder = new Codec();
String msg = encoder.encode(strs);
Machine 1 ---msg---&gt; Machine 2

Machine 2:
Codec decoder = new Codec();
String[] strs = decoder.decode(msg);
```

**Example2**

```
Input: dummy_input = [""]
Output: [""]
```

**Constraints:**

-   `1 <= strs.length <= 200`
-   `0 <= strs[i].length <= 200`
-   `strs[i] contains any possible characters out of 256 valid ASCII characters`

___

What should be the delimiter between the length prefix and the actual string content?

A) The delimiter can be any character, as it is not important for decoding.

B) The delimiter should be a character that is not allowed in the strings.

C) The delimiter should be a non-integer character.

###### ID21

A:: =============================================  
**Answer**: C

If the delimiter is a number, it could lead to confusion during decoding. Hence, we need to choose a delimiter that cannot be part of the prefix.

Q:: =============================================  

##### Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example1**

```
Input: dummy_input = ["Hello", "World"]
Output: ["Hello", "World"]
Explanation:
Machine 1:
Codec encoder = new Codec();
String msg = encoder.encode(strs);
Machine 1 ---msg---&gt; Machine 2

Machine 2:
Codec decoder = new Codec();
String[] strs = decoder.decode(msg);
```

**Example2**

```
Input: dummy_input = [""]
Output: [""]
```

**Constraints:**

-   `1 <= strs.length <= 200`
-   `0 <= strs[i].length <= 200`
-   `strs[i] contains any possible characters out of 256 valid ASCII characters`

___

We can implement the encode and decode methods using `#` as the delimiter, as follow. What is the time and space complexity of the encode and decode methods? Assume `n` is the total length of the string.


```python
class Codec:
    def encode(self, strs: List[str]) -> str:
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res

    def decode(self, s: str) -> List[str]:
        res, i = [], 0
        while i < len(s):
            j = i
            while s[j] != "#":
                j += 1
            length = int(s[i:j])
            res.append(s[j + 1: j + 1 + length])
            i = j + 1 + length
        return res
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n^2), Space complexity: O(n)

C) Time complexity: O(n log n), Space complexity: O(n)

###### ID22

A:: =============================================  
**Answer**: A

The overall time complexity of the solution is determined by the number of characters in the strings list (strs). We iterate over all characters twice: once when encoding and once when decoding. Therefore, the time complexity is linear. The space complexity is also linear because the encoded string has the same number of characters as the original strings list plus the length of each string and a colon for each string.

#### Chapter 9 - Longest Consecutive Sequence (Blind)

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

For a given array of integers, what is the time complexity of finding the length of the longest consecutive sequence using sorting?

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID23

A:: =============================================  
**Answer**: B

Sorting an array generally takes O(n log n) time. Once the array is sorted, you could iterate through the array once to find the longest consecutive sequence, which would take O(n) time. However, the dominating factor is the sorting time complexity, thus the overall time complexity is O(n log n).

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

Suppose we are counting the length of a sequence starting at an arbitrary value, say `n = 1.` To extend this sequence, we need to efficiently check for the existence of the next integer `(n + 1)`, regardless of its index in the original array. Which data structure would best serve this purpose?

A) Priority Queue

B) HashSet

C) Binary Search Tree

D) Array

###### ID24

A:: =============================================  
**Answer**: B

A HashSet can be used to efficiently check the existence of elements in O(1) average time complexity. When extending a sequence, this property is essential, allowing us to determine if the next integer (n + 1) exists in the original array, regardless of its position.

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

Consider the array `[1, 2, 3, 4, 5, 6]`. If we naively iterate through this array, treating each element `n` as the potential start of a sequence, we would check for the existence of each subsequent number `n + 1`. What would be the time complexity of such an approach?

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID25

A:: =============================================  
**Answer**: C

For every element in the array, except for 6, the follow-up element n + 1 does exist. So for each element, in the worst case, we would iterate n - 1 times to build each sequence, resulting in a time complexity of O(n^2).

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

Consider the array `[100, 4, 200, 1, 3, 2]`. This array contains two sequences: `[1, 2, 3, 4]` and `[100, 200]`. What common trait do the starting elements `1` and `100` share, which suggests they are the beginning of these sequences?

A) They are the smallest numbers in their respective sequences.

B) The element (n - 1) does not exist in the array.

C) The element (n + 1) does exist in the array.

D) They are the largest numbers in their respective sequences.

###### ID26

A:: =============================================  
**Answer**: B

The key observation is that for any number 'n' to be the start of a sequence, the number (n - 1) must not exist in the array. This is because if (n-1) exists, 'n' would be part of a sequence starting at least from (n-1). In this case, for '1' and '100', neither '0' nor '99' exist in the array, indicating that '1' and '100' can indeed be the starting points of their sequences.

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

Knowing that an element 'n' is the start of a sequence if (n - 1) does not exist in the array, how could we efficiently solve this problem using a hashset?

A) Add all elements to the hashset. Then, for each element 'n', if (n - 1) is not in the hashset, check and count the longest sequence starting from 'n'.

B) Add all elements to the hashset. Then, for each element 'n', if (n + 1) is in the hashset, check and count the longest sequence starting from 'n'.

###### ID27

A:: =============================================  
**Answer**: A

We then iterate through each element 'n' and if (n - 1) is not in the hashset, we check for the longest sequence starting from 'n'. This is because if (n-1) does not exist, 'n' must be the starting point of a sequence. We then check for the existence of (n + 1), (n + 2), and so on in the hashset, and count the length of the sequence. This approach ensures that we don't repeatedly check the same sequence and keeps the time complexity to O(n).

Q:: =============================================  

##### Given an unsorted array of integers `nums`, return the _length of the longest consecutive elements sequence_.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```

**Constraints:**

-   `0 <= nums.length <= 10^5`
-   `-10^9 <= nums[i] <= 10^9`

___

What is the time and space complexity of the optimal solution using a HashSet and avoiding unnecessary checks?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID28

A:: =============================================  
**Answer**: A

The HashSet solution has a time complexity of O(n) because you need to iterate through the array twice (once for building the HashSet and once for checking the sequences). The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the HashSet.

### Part II - Two Pointers

#### Chapter 1 - Valid Palindrome (Blind)

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

Given a string, what is a crucial step in the initial preprocessing to determine whether it is a palindrome?

A) Reverse the string.

B) Convert the string to lowercase.

C) Check if the string is empty.

D) Split the string into words.

###### ID29

A:: =============================================  
**Answer**: B

A crucial step to check if a string is a palindrome is to convert it to lowercase. This is because palindromes are case-insensitive. However, it's important to note that removing non-alphanumeric characters is another critical preprocessing step not mentioned in this particular question.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

After converting the string to lowercase, what should be the next step?

A) Reverse the string.

B) Check if the string is empty.

C) Remove all non-alphanumeric characters.

D) Convert the string to uppercase.

###### ID30

A:: =============================================  
**Answer**: C

The next step is to remove all non-alphanumeric characters. This is because palindromes only consider alphanumeric characters.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

Once the string has been converted to lowercase and all non-alphanumeric characters have been removed, what is the final step to determine if it's a palindrome?

A) Convert the string to uppercase.

B) Check if the string is equal to its reverse.

C) Check if the string is empty.

D) Split the string into words.

###### ID31

A:: =============================================  
**Answer**: B

The final step to check if a string is a palindrome is to compare it to its reversed version. If they are the same, then the string is a palindrome.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

What is the time and space complexity of the approach where we create a new reversed string to compare?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID32

A:: =============================================  
**Answer**: A

The time complexity is O(n) because all operations (lowercase conversion, removing non-alphanumeric characters, and reversing the string) take linear time. The 'n' here is the length of the string. The space complexity is also O(n) because we are creating a new string for the reversed version, which can be as long as the input string.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

Is there a way to check if a string is a palindrome without creating a new string for the reversed version?

A) No, it's not possible.

B) Yes, by using two pointers.

C) Yes, by sorting the string.

D) Yes, by using a stack.

###### ID33

A:: =============================================  
**Answer**: B

Yes, it is possible. You can use two pointers: one starting from the beginning of the string and the other from the end. If the characters at both pointers are equal, we increment the left pointer and decrement the right pointer. If they are not equal, then the string is not a palindrome. This approach avoids creating a new string for the reversed version, thus saving space.

Q:: =============================================  

##### A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string `s`, return `true` if it is a **palindrome,** or `false` otherwise.

**Example 1:**

```
Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.
```

**Example 2:**

```
Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.
```

**Example 3:**

```
Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.
```

**Constraints:**

`1 <= s.length <= 2 * 10^5`  
`s consists only of printable ASCII characters.`

___

What are the time and space complexities of the two-pointer approach to check if a string is a palindrome?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID34

A:: =============================================  
**Answer**: D

The time complexity is O(n) because in the worst case, we would have to compare every character in the string with its counterpart from the end. Here, 'n' is the length of the string. This is still linear time complexity. The space complexity is O(1) because no extra space proportional to the size of the input is used. The two pointers used do not scale with the input size.

#### Chapter 2 - Two Sum II

#### Chapter 3 - 3Sum (Blind)

#### Chapter 4 - Container With Most Water (Blind)

#### Chapter 5 - Trapping Rain Water

### Part III - Sliding Window

#### Chapter 1 - Best Time to Buy and Sell Stock (Blind)

#### Chapter 2 - Longest Substring Without Repeating Characters (Blind)

#### Chapter 3 - Longest Repeating Character Replacement (Blind)

#### Chapter 4 - Permutation in String

#### Chapter 5 - Minimum Window Substring (Blind)

#### Chapter 6 - Sliding Window Maximum

### Part IV - Stack

#### Chapter 1 - Valid Parentheses (Blind)

#### Chapter 2 - Min Stack

#### Chapter 3 - Evaluate Reverse Polish Notation

#### Chapter 4 - Generate Parentheses

#### Chapter 5 - Daily Temperatures

#### Chapter 6 - Car Fleet

#### Chapter 7 - Largest Rectangle in Histogram

### Part V - Binary Search

#### Chapter 1 - Binary Search

#### Chapter 2 - Search a 2D Matrix

#### Chapter 3 - Koko Eating Bananas

#### Chapter 4 - Search in Rotated Sorted Array (Blind)

#### Chapter 5 - Find Minimum in Rotated Sorted Array (Blind)

#### Chapter 6 - Time Based Key-Value Store

#### Chapter 7 - Median of Two Sorted Arrays

### Part VI - Linked List

#### Chapter 1 - Reverse Linked List (Blind)

#### Chapter 2 - Merge Two Sorted Lists (Blind)

#### Chapter 3 - Reorder List (Blind)

#### Chapter 4 - Remove Nth Node From End of List (Blind)

#### Chapter 5 - Copy List with Random Pointer

#### Chapter 6 - Add Two Numbers

#### Chapter 7 - Linked List Cycle (Blind)

#### Chapter 8 - Find the Duplicate Number

#### Chapter 9 - LRU Cache

#### Chapter 10 - Merge k Sorted Lists (Blind)

#### Chapter 11 - Reverse Nodes in k-Group

### Part VII - Trees

#### Chapter 1 - Invert Binary Tree (Blind)

#### Chapter 2 - Maximum Depth of Binary Tree (Blind)

#### Chapter 3 - Diameter of Binary Tree

#### Chapter 4 - Balanced Binary Tree

#### Chapter 5 - Same Tree (Blind)

#### Chapter 6 - Subtree of Another Tree (Blind)

#### Chapter 7 - Lowest Common Ancestor of a Binary Search Tree (Blind)

#### Chapter 8 - Binary Tree Level Order Traversal (Blind)

#### Chapter 9 - Binary Tree Right Side View

#### Chapter 10 - Count Good Nodes in Binary Tree

#### Chapter 11 - Validate Binary Search Tree (Blind)

#### Chapter 12 - Kth Smallest Element in a BST (Blind)

#### Chapter 13 - Construct Binary Tree from Preorder and Inorder Traversal (Blind)

#### Chapter 14 - Binary Tree Maximum Path Sum (Blind)

#### Chapter 15 - Serialize and Deserialize Binary Tree (Blind)

### Part VIII - Trie

#### Chapter 1 - Implement Trie (Blind)

#### Chapter 2 - Design Add and Search Words Data Structure (Blind)

#### Chapter 3 - Word Search II (Blind)

### Part IX - Heap and Priority Queue

#### Chapter 1 - Kth Largest Element in a Stream

#### Chapter 2 - Last Stone Weight

#### Chapter 3 - K Closest Points to Origin

#### Chapter 4 - Kth Largest Element in an Array

#### Chapter 5 - Task Scheduler

#### Chapter 6 - Design Twitter

#### Chapter 7 - Find Median from Data Stream (Blind)

### Part X - Backtracking

#### Chapter 1 - Permutations

#### Chapter 2 - Sudoku Solver

#### Chapter 3 - Subsets

#### Chapter 4 - Combination Sum (Blind)

#### Chapter 5 - Subsets II

#### Chapter 6 - Word Search (Blind)

#### Chapter 7 - Palindrome Partitioning

#### Chapter 8 - Letter Combinations of a Phone Number

#### Chapter 9 - N-Queens

### Part XI - Graphs

#### Chapter 1 - Number of Islands (Blind)

#### Chapter 2 - Clone Graph (Blind)

#### Chapter 3 - Max Area of Island

#### Chapter 4 - Pacific Atlantic Water Flow (Blind)

#### Chapter 5 - Surrounded Regions

#### Chapter 6 - Rotting Oranges

#### Chapter 7 - Walls and Gates

#### Chapter 8 - Course Schedule (Blind)

#### Chapter 9 - Course Schedule II

#### Chapter 10 - Redundant Connection

#### Chapter 11 - Number of Connected Components In An Undirected Graph (Blind)

#### Chapter 12 - Graph Valid Tree (Blind)

#### Chapter 13 - Word Ladder

### Part XII - Advance Graphs

#### Chapter 1 - Reconstruct Itinerary

---

DECK INFO

TARGET DECK: Data Structures and Algorithms::Leetcode::MNAB - Neetcode 150 and blind 75 - multi-author

FILE TAGS: #DSA::#Leetcode

Tags:

Reference:

Related:

```dataview
LIST
where file.name = this.file.name
```