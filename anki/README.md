# MNAB - Neetcode 150 and blind 75 - multi-author

## Questions

| ID | File name / path | Part | Chapter |
| --- | --- | --- | --- |
| **-** | **Arrays Hashing** | **1** | **-** |
| **-** | **Arrays Hashing > Contains Duplicate** | **1** | **1** |
| [1](#id1) | [Duplicate integer given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20-%20Blind/1%20-%20Duplicate%20integer%20given%20an%20integer%20array.md) | 1 | 1 |
| [2](#id2) | [Duplicate integer given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20-%20Blind/2%20-%20Duplicate%20integer%20given%20an%20integer%20array.md) | 1 | 1 |
| [3](#id3) | [Duplicate integer given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20-%20Blind/3%20-%20Duplicate%20integer%20given%20an%20integer%20array.md) | 1 | 1 |
| [4](#id4) | [Duplicate integer given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20-%20Blind/4%20-%20Duplicate%20integer%20given%20an%20integer%20array.md) | 1 | 1 |
| [5](#id5) | [Duplicate integer given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%201%20-%20Contains%20Duplicate%20-%20Blind/5%20-%20Duplicate%20integer%20given%20an%20integer%20array.md) | 1 | 1 |
| **-** | **Arrays Hashing > Valid Anagram** | **1** | **2** |
| [6](#id6) | [Is anagram given two strings s and t](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%202%20-%20Valid%20Anagram%20-%20Blind/6%20-%20Is%20anagram%20given%20two%20strings%20s%20and%20t.md) | 1 | 2 |
| [7](#id7) | [Is anagram given two strings s and t](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%202%20-%20Valid%20Anagram%20-%20Blind/7%20-%20Is%20anagram%20given%20two%20strings%20s%20and%20t.md) | 1 | 2 |
| [8](#id8) | [Is anagram given two strings s and t](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%202%20-%20Valid%20Anagram%20-%20Blind/8%20-%20Is%20anagram%20given%20two%20strings%20s%20and%20t.md) | 1 | 2 |
| [9](#id9) | [Is anagram given two strings s and t](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%202%20-%20Valid%20Anagram%20-%20Blind/9%20-%20Is%20anagram%20given%20two%20strings%20s%20and%20t.md) | 1 | 2 |
| [10](#id10) | [Is anagram given two strings s and t](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%202%20-%20Valid%20Anagram%20-%20Blind/10%20-%20Is%20anagram%20given%20two%20strings%20s%20and%20t.md) | 1 | 2 |
| [11](#id11) | [Is anagram given two strings s and t](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%202%20-%20Valid%20Anagram%20-%20Blind/11%20-%20Is%20anagram%20given%20two%20strings%20s%20and%20t.md) | 1 | 2 |
| **-** | **Arrays Hashing > Two Sum** | **1** | **3** |
| [12](#id12) | [Two integer sum given an array of integers](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%203%20-%20Two%20Sum%20-%20Blind/12%20-%20Two%20integer%20sum%20given%20an%20array%20of%20integers.md) | 1 | 3 |
| [13](#id13) | [Two integer sum given an array of integers](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%203%20-%20Two%20Sum%20-%20Blind/13%20-%20Two%20integer%20sum%20given%20an%20array%20of%20integers.md) | 1 | 3 |
| [14](#id14) | [Two integer sum given an array of integers](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%203%20-%20Two%20Sum%20-%20Blind/14%20-%20Two%20integer%20sum%20given%20an%20array%20of%20integers.md) | 1 | 3 |
| [15](#id15) | [Two integer sum given an array of integers](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%203%20-%20Two%20Sum%20-%20Blind/15%20-%20Two%20integer%20sum%20given%20an%20array%20of%20integers.md) | 1 | 3 |
| [16](#id16) | [Two integer sum given an array of integers](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%203%20-%20Two%20Sum%20-%20Blind/16%20-%20Two%20integer%20sum%20given%20an%20array%20of%20integers.md) | 1 | 3 |
| [17](#id17) | [Two integer sum given an array of integers](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%203%20-%20Two%20Sum%20-%20Blind/17%20-%20Two%20integer%20sum%20given%20an%20array%20of%20integers.md) | 1 | 3 |
| [18](#id18) | [Two integer sum given an array of integers](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%203%20-%20Two%20Sum%20-%20Blind/18%20-%20Two%20integer%20sum%20given%20an%20array%20of%20integers.md) | 1 | 3 |
| **-** | **Arrays Hashing > Group Anagrams** | **1** | **4** |
| [19](#id19) | [Anagram groups given an array of strings](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%204%20-%20Group%20Anagrams%20-%20Blind/19%20-%20Anagram%20groups%20given%20an%20array%20of%20strings.md) | 1 | 4 |
| [20](#id20) | [Anagram groups given an array of strings](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%204%20-%20Group%20Anagrams%20-%20Blind/20%20-%20Anagram%20groups%20given%20an%20array%20of%20strings.md) | 1 | 4 |
| [21](#id21) | [Anagram groups given an array of strings](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%204%20-%20Group%20Anagrams%20-%20Blind/21%20-%20Anagram%20groups%20given%20an%20array%20of%20strings.md) | 1 | 4 |
| [22](#id22) | [Anagram groups given an array of strings](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%204%20-%20Group%20Anagrams%20-%20Blind/22%20-%20Anagram%20groups%20given%20an%20array%20of%20strings.md) | 1 | 4 |
| [23](#id23) | [Anagram groups given an array of strings](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%204%20-%20Group%20Anagrams%20-%20Blind/23%20-%20Anagram%20groups%20given%20an%20array%20of%20strings.md) | 1 | 4 |
| [24](#id24) | [Anagram groups given an array of strings](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%204%20-%20Group%20Anagrams%20-%20Blind/24%20-%20Anagram%20groups%20given%20an%20array%20of%20strings.md) | 1 | 4 |
| **-** | **Arrays Hashing > Top K Frequent Elements** | **1** | **5** |
| [25](#id25) | [Top k elements in list given an integer ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%205%20-%20Top%20K%20Frequent%20Elements%20-%20Blind/25%20-%20Top%20k%20elements%20in%20list%20given%20an%20integer%20ar.md) | 1 | 5 |
| [26](#id26) | [Top k elements in list given an integer ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%205%20-%20Top%20K%20Frequent%20Elements%20-%20Blind/26%20-%20Top%20k%20elements%20in%20list%20given%20an%20integer%20ar.md) | 1 | 5 |
| [27](#id27) | [Top k elements in list given an integer ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%205%20-%20Top%20K%20Frequent%20Elements%20-%20Blind/27%20-%20Top%20k%20elements%20in%20list%20given%20an%20integer%20ar.md) | 1 | 5 |
| [28](#id28) | [Top k elements in list given an integer ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%205%20-%20Top%20K%20Frequent%20Elements%20-%20Blind/28%20-%20Top%20k%20elements%20in%20list%20given%20an%20integer%20ar.md) | 1 | 5 |
| [29](#id29) | [Top k elements in list given an integer ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%205%20-%20Top%20K%20Frequent%20Elements%20-%20Blind/29%20-%20Top%20k%20elements%20in%20list%20given%20an%20integer%20ar.md) | 1 | 5 |
| [30](#id30) | [Top k elements in list given an integer ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%205%20-%20Top%20K%20Frequent%20Elements%20-%20Blind/30%20-%20Top%20k%20elements%20in%20list%20given%20an%20integer%20ar.md) | 1 | 5 |
| **-** | **Arrays Hashing > Encode and Decode Strings** | **1** | **6** |
| [31](#id31) | [String encode and decode design an algorit](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%206%20-%20Encode%20and%20Decode%20Strings%20-%20Blind/31%20-%20String%20encode%20and%20decode%20design%20an%20algorit.md) | 1 | 6 |
| [32](#id32) | [String encode and decode design an algorit](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%206%20-%20Encode%20and%20Decode%20Strings%20-%20Blind/32%20-%20String%20encode%20and%20decode%20design%20an%20algorit.md) | 1 | 6 |
| [33](#id33) | [String encode and decode design an algorit](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%206%20-%20Encode%20and%20Decode%20Strings%20-%20Blind/33%20-%20String%20encode%20and%20decode%20design%20an%20algorit.md) | 1 | 6 |
| [34](#id34) | [String encode and decode design an algorit](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%206%20-%20Encode%20and%20Decode%20Strings%20-%20Blind/34%20-%20String%20encode%20and%20decode%20design%20an%20algorit.md) | 1 | 6 |
| **-** | **Arrays Hashing > Product of Array Except Self** | **1** | **7** |
| [35](#id35) | [Products of array discluding self given an](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%207%20-%20Product%20of%20Array%20Except%20Self%20-%20Blind/35%20-%20Products%20of%20array%20discluding%20self%20given%20an.md) | 1 | 7 |
| [36](#id36) | [Products of array discluding self given an](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%207%20-%20Product%20of%20Array%20Except%20Self%20-%20Blind/36%20-%20Products%20of%20array%20discluding%20self%20given%20an.md) | 1 | 7 |
| [37](#id37) | [Products of array discluding self given an](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%207%20-%20Product%20of%20Array%20Except%20Self%20-%20Blind/37%20-%20Products%20of%20array%20discluding%20self%20given%20an.md) | 1 | 7 |
| [38](#id38) | [Products of array discluding self given an](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%207%20-%20Product%20of%20Array%20Except%20Self%20-%20Blind/38%20-%20Products%20of%20array%20discluding%20self%20given%20an.md) | 1 | 7 |
| [39](#id39) | [Products of array discluding self given an](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%207%20-%20Product%20of%20Array%20Except%20Self%20-%20Blind/39%20-%20Products%20of%20array%20discluding%20self%20given%20an.md) | 1 | 7 |
| [40](#id40) | [Products of array discluding self given an](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%207%20-%20Product%20of%20Array%20Except%20Self%20-%20Blind/40%20-%20Products%20of%20array%20discluding%20self%20given%20an.md) | 1 | 7 |
| [41](#id41) | [Products of array discluding self given an](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%207%20-%20Product%20of%20Array%20Except%20Self%20-%20Blind/41%20-%20Products%20of%20array%20discluding%20self%20given%20an.md) | 1 | 7 |
| **-** | **Arrays Hashing > Valid Sudoku** | **1** | **8** |
| [42](#id42) | [Valid sudoku you are given a a 9 x 9 sud](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%208%20-%20Valid%20Sudoku/42%20-%20Valid%20sudoku%20you%20are%20given%20a%20a%209%20x%209%20sud.md) | 1 | 8 |
| [43](#id43) | [Valid sudoku you are given a a 9 x 9 sud](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%208%20-%20Valid%20Sudoku/43%20-%20Valid%20sudoku%20you%20are%20given%20a%20a%209%20x%209%20sud.md) | 1 | 8 |
| [44](#id44) | [Valid sudoku you are given a a 9 x 9 sud](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%208%20-%20Valid%20Sudoku/44%20-%20Valid%20sudoku%20you%20are%20given%20a%20a%209%20x%209%20sud.md) | 1 | 8 |
| [45](#id45) | [Valid sudoku you are given a a 9 x 9 sud](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%208%20-%20Valid%20Sudoku/45%20-%20Valid%20sudoku%20you%20are%20given%20a%20a%209%20x%209%20sud.md) | 1 | 8 |
| [46](#id46) | [Valid sudoku you are given a a 9 x 9 sud](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%208%20-%20Valid%20Sudoku/46%20-%20Valid%20sudoku%20you%20are%20given%20a%20a%209%20x%209%20sud.md) | 1 | 8 |
| [47](#id47) | [Valid sudoku you are given a a 9 x 9 sud](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%208%20-%20Valid%20Sudoku/47%20-%20Valid%20sudoku%20you%20are%20given%20a%20a%209%20x%209%20sud.md) | 1 | 8 |
| [48](#id48) | [Valid sudoku you are given a a 9 x 9 sud](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%208%20-%20Valid%20Sudoku/48%20-%20Valid%20sudoku%20you%20are%20given%20a%20a%209%20x%209%20sud.md) | 1 | 8 |
| [49](#id49) | [Valid sudoku you are given a a 9 x 9 sud](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%208%20-%20Valid%20Sudoku/49%20-%20Valid%20sudoku%20you%20are%20given%20a%20a%209%20x%209%20sud.md) | 1 | 8 |
| **-** | **Arrays Hashing > Longest Consecutive Sequence** | **1** | **9** |
| [50](#id50) | [Longest consecutive sequence given an arra](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20-%20Blind/50%20-%20Longest%20consecutive%20sequence%20given%20an%20arra.md) | 1 | 9 |
| [51](#id51) | [Longest consecutive sequence given an arra](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20-%20Blind/51%20-%20Longest%20consecutive%20sequence%20given%20an%20arra.md) | 1 | 9 |
| [52](#id52) | [Longest consecutive sequence given an arra](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20-%20Blind/52%20-%20Longest%20consecutive%20sequence%20given%20an%20arra.md) | 1 | 9 |
| [53](#id53) | [Longest consecutive sequence given an arra](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20-%20Blind/53%20-%20Longest%20consecutive%20sequence%20given%20an%20arra.md) | 1 | 9 |
| [54](#id54) | [Longest consecutive sequence given an arra](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20-%20Blind/54%20-%20Longest%20consecutive%20sequence%20given%20an%20arra.md) | 1 | 9 |
| [55](#id55) | [Longest consecutive sequence given an arra](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20I%20-%20Arrays%20Hashing/Chapter%209%20-%20Longest%20Consecutive%20Sequence%20-%20Blind/55%20-%20Longest%20consecutive%20sequence%20given%20an%20arra.md) | 1 | 9 |
| **-** | **Two Pointers** | **2** | **-** |
| **-** | **Two Pointers > Valid Palindrome** | **2** | **1** |
| [56](#id56) | [Is palindrome given a string s return](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20-%20Blind/56%20-%20Is%20palindrome%20given%20a%20string%20s%20return.md) | 2 | 1 |
| [57](#id57) | [Is palindrome given a string s return](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20-%20Blind/57%20-%20Is%20palindrome%20given%20a%20string%20s%20return.md) | 2 | 1 |
| [58](#id58) | [Is palindrome given a string s return](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20-%20Blind/58%20-%20Is%20palindrome%20given%20a%20string%20s%20return.md) | 2 | 1 |
| [59](#id59) | [Is palindrome given a string s return](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20-%20Blind/59%20-%20Is%20palindrome%20given%20a%20string%20s%20return.md) | 2 | 1 |
| [60](#id60) | [Is palindrome given a string s return](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20-%20Blind/60%20-%20Is%20palindrome%20given%20a%20string%20s%20return.md) | 2 | 1 |
| [61](#id61) | [Is palindrome given a string s return](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%201%20-%20Valid%20Palindrome%20-%20Blind/61%20-%20Is%20palindrome%20given%20a%20string%20s%20return.md) | 2 | 1 |
| **-** | **Two Pointers > Two Sum II Input Array Is Sorted** | **2** | **2** |
| [62](#id62) | [Two integer sum ii given an array of integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%202%20-%20Two%20Sum%20II%20Input%20Array%20Is%20Sorted/62%20-%20Two%20integer%20sum%20ii%20given%20an%20array%20of%20integ.md) | 2 | 2 |
| [63](#id63) | [Two integer sum ii given an array of integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%202%20-%20Two%20Sum%20II%20Input%20Array%20Is%20Sorted/63%20-%20Two%20integer%20sum%20ii%20given%20an%20array%20of%20integ.md) | 2 | 2 |
| [64](#id64) | [Two integer sum ii given an array of integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%202%20-%20Two%20Sum%20II%20Input%20Array%20Is%20Sorted/64%20-%20Two%20integer%20sum%20ii%20given%20an%20array%20of%20integ.md) | 2 | 2 |
| [65](#id65) | [Two integer sum ii given an array of integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%202%20-%20Two%20Sum%20II%20Input%20Array%20Is%20Sorted/65%20-%20Two%20integer%20sum%20ii%20given%20an%20array%20of%20integ.md) | 2 | 2 |
| [66](#id66) | [Two integer sum ii given an array of integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%202%20-%20Two%20Sum%20II%20Input%20Array%20Is%20Sorted/66%20-%20Two%20integer%20sum%20ii%20given%20an%20array%20of%20integ.md) | 2 | 2 |
| [67](#id67) | [Two integer sum ii given an array of integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%202%20-%20Two%20Sum%20II%20Input%20Array%20Is%20Sorted/67%20-%20Two%20integer%20sum%20ii%20given%20an%20array%20of%20integ.md) | 2 | 2 |
| [68](#id68) | [Two integer sum ii given an array of integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%202%20-%20Two%20Sum%20II%20Input%20Array%20Is%20Sorted/68%20-%20Two%20integer%20sum%20ii%20given%20an%20array%20of%20integ.md) | 2 | 2 |
| [69](#id69) | [Two integer sum ii given an array of integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%202%20-%20Two%20Sum%20II%20Input%20Array%20Is%20Sorted/69%20-%20Two%20integer%20sum%20ii%20given%20an%20array%20of%20integ.md) | 2 | 2 |
| **-** | **Two Pointers > 3Sum** | **2** | **3** |
| [70](#id70) | [Three integer sum given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20-%20Blind/70%20-%20Three%20integer%20sum%20given%20an%20integer%20array.md) | 2 | 3 |
| [71](#id71) | [Three integer sum given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20-%20Blind/71%20-%20Three%20integer%20sum%20given%20an%20integer%20array.md) | 2 | 3 |
| [72](#id72) | [Three integer sum given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20-%20Blind/72%20-%20Three%20integer%20sum%20given%20an%20integer%20array.md) | 2 | 3 |
| [73](#id73) | [Three integer sum given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20-%20Blind/73%20-%20Three%20integer%20sum%20given%20an%20integer%20array.md) | 2 | 3 |
| [74](#id74) | [Three integer sum given an integer array](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%203%20-%203Sum%20-%20Blind/74%20-%20Three%20integer%20sum%20given%20an%20integer%20array.md) | 2 | 3 |
| **-** | **Two Pointers > Container With Most Water** | **2** | **4** |
| [75](#id75) | [Max water container you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20-%20Blind/75%20-%20Max%20water%20container%20you%20are%20given%20an%20integ.md) | 2 | 4 |
| [76](#id76) | [Max water container you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20-%20Blind/76%20-%20Max%20water%20container%20you%20are%20given%20an%20integ.md) | 2 | 4 |
| [77](#id77) | [Max water container you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20-%20Blind/77%20-%20Max%20water%20container%20you%20are%20given%20an%20integ.md) | 2 | 4 |
| [78](#id78) | [Max water container you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20-%20Blind/78%20-%20Max%20water%20container%20you%20are%20given%20an%20integ.md) | 2 | 4 |
| [79](#id79) | [Max water container you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20-%20Blind/79%20-%20Max%20water%20container%20you%20are%20given%20an%20integ.md) | 2 | 4 |
| [80](#id80) | [Max water container you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20II%20-%20Two%20Pointers/Chapter%204%20-%20Container%20With%20Most%20Water%20-%20Blind/80%20-%20Max%20water%20container%20you%20are%20given%20an%20integ.md) | 2 | 4 |
| **-** | **Stack** | **3** | **-** |
| **-** | **Stack > Valid Parentheses** | **3** | **1** |
| [81](#id81) | [Validate parentheses you are given a strin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20-%20Blind/81%20-%20Validate%20parentheses%20you%20are%20given%20a%20strin.md) | 3 | 1 |
| [82](#id82) | [Validate parentheses you are given a strin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20-%20Blind/82%20-%20Validate%20parentheses%20you%20are%20given%20a%20strin.md) | 3 | 1 |
| [83](#id83) | [Validate parentheses you are given a strin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20-%20Blind/83%20-%20Validate%20parentheses%20you%20are%20given%20a%20strin.md) | 3 | 1 |
| [84](#id84) | [Validate parentheses you are given a strin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20-%20Blind/84%20-%20Validate%20parentheses%20you%20are%20given%20a%20strin.md) | 3 | 1 |
| [85](#id85) | [Validate parentheses you are given a strin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20-%20Blind/85%20-%20Validate%20parentheses%20you%20are%20given%20a%20strin.md) | 3 | 1 |
| [86](#id86) | [Validate parentheses you are given a strin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20III%20-%20Stack/Chapter%201%20-%20Valid%20Parentheses%20-%20Blind/86%20-%20Validate%20parentheses%20you%20are%20given%20a%20strin.md) | 3 | 1 |
| **-** | **Binary Search** | **4** | **-** |
| **-** | **Binary Search > Find Minimum In Rotated Sorted Array** | **4** | **4** |
| [87](#id87) | [Find minimum in rotated sorted array you a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%204%20-%20Find%20Minimum%20In%20Rotated%20Sorted%20Array%20-%20Blind/87%20-%20Find%20minimum%20in%20rotated%20sorted%20array%20you%20a.md) | 4 | 4 |
| [88](#id88) | [Find minimum in rotated sorted array you a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%204%20-%20Find%20Minimum%20In%20Rotated%20Sorted%20Array%20-%20Blind/88%20-%20Find%20minimum%20in%20rotated%20sorted%20array%20you%20a.md) | 4 | 4 |
| [89](#id89) | [Find minimum in rotated sorted array you a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%204%20-%20Find%20Minimum%20In%20Rotated%20Sorted%20Array%20-%20Blind/89%20-%20Find%20minimum%20in%20rotated%20sorted%20array%20you%20a.md) | 4 | 4 |
| [90](#id90) | [Find minimum in rotated sorted array you a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%204%20-%20Find%20Minimum%20In%20Rotated%20Sorted%20Array%20-%20Blind/90%20-%20Find%20minimum%20in%20rotated%20sorted%20array%20you%20a.md) | 4 | 4 |
| [91](#id91) | [Find minimum in rotated sorted array you a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%204%20-%20Find%20Minimum%20In%20Rotated%20Sorted%20Array%20-%20Blind/91%20-%20Find%20minimum%20in%20rotated%20sorted%20array%20you%20a.md) | 4 | 4 |
| [92](#id92) | [Find minimum in rotated sorted array you a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%204%20-%20Find%20Minimum%20In%20Rotated%20Sorted%20Array%20-%20Blind/92%20-%20Find%20minimum%20in%20rotated%20sorted%20array%20you%20a.md) | 4 | 4 |
| [93](#id93) | [Find minimum in rotated sorted array you a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%204%20-%20Find%20Minimum%20In%20Rotated%20Sorted%20Array%20-%20Blind/93%20-%20Find%20minimum%20in%20rotated%20sorted%20array%20you%20a.md) | 4 | 4 |
| [94](#id94) | [Find minimum in rotated sorted array you a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%204%20-%20Find%20Minimum%20In%20Rotated%20Sorted%20Array%20-%20Blind/94%20-%20Find%20minimum%20in%20rotated%20sorted%20array%20you%20a.md) | 4 | 4 |
| **-** | **Binary Search > Search In Rotated Sorted Array** | **4** | **5** |
| [95](#id95) | [Find target in rotated sorted array you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%205%20-%20Search%20In%20Rotated%20Sorted%20Array%20-%20Blind/95%20-%20Find%20target%20in%20rotated%20sorted%20array%20you%20ar.md) | 4 | 5 |
| [96](#id96) | [Find target in rotated sorted array you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%205%20-%20Search%20In%20Rotated%20Sorted%20Array%20-%20Blind/96%20-%20Find%20target%20in%20rotated%20sorted%20array%20you%20ar.md) | 4 | 5 |
| [97](#id97) | [Find target in rotated sorted array you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%205%20-%20Search%20In%20Rotated%20Sorted%20Array%20-%20Blind/97%20-%20Find%20target%20in%20rotated%20sorted%20array%20you%20ar.md) | 4 | 5 |
| [98](#id98) | [Find target in rotated sorted array you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%205%20-%20Search%20In%20Rotated%20Sorted%20Array%20-%20Blind/98%20-%20Find%20target%20in%20rotated%20sorted%20array%20you%20ar.md) | 4 | 5 |
| [99](#id99) | [Find target in rotated sorted array you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%205%20-%20Search%20In%20Rotated%20Sorted%20Array%20-%20Blind/99%20-%20Find%20target%20in%20rotated%20sorted%20array%20you%20ar.md) | 4 | 5 |
| [100](#id100) | [Find target in rotated sorted array you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%205%20-%20Search%20In%20Rotated%20Sorted%20Array%20-%20Blind/100%20-%20Find%20target%20in%20rotated%20sorted%20array%20you%20ar.md) | 4 | 5 |
| [101](#id101) | [Find target in rotated sorted array you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%205%20-%20Search%20In%20Rotated%20Sorted%20Array%20-%20Blind/101%20-%20Find%20target%20in%20rotated%20sorted%20array%20you%20ar.md) | 4 | 5 |
| [102](#id102) | [Find target in rotated sorted array you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%205%20-%20Search%20In%20Rotated%20Sorted%20Array%20-%20Blind/102%20-%20Find%20target%20in%20rotated%20sorted%20array%20you%20ar.md) | 4 | 5 |
| [103](#id103) | [Find target in rotated sorted array you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IV%20-%20Binary%20Search/Chapter%205%20-%20Search%20In%20Rotated%20Sorted%20Array%20-%20Blind/103%20-%20Find%20target%20in%20rotated%20sorted%20array%20you%20ar.md) | 4 | 5 |
| **-** | **Sliding Window** | **5** | **-** |
| **-** | **Sliding Window > Best Time to Buy And Sell Stock** | **5** | **1** |
| [104](#id104) | [Buy and sell crypto you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20And%20Sell%20Stock%20-%20Blind/104%20-%20Buy%20and%20sell%20crypto%20you%20are%20given%20an%20integ.md) | 5 | 1 |
| [105](#id105) | [Buy and sell crypto you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20And%20Sell%20Stock%20-%20Blind/105%20-%20Buy%20and%20sell%20crypto%20you%20are%20given%20an%20integ.md) | 5 | 1 |
| [106](#id106) | [Buy and sell crypto you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20And%20Sell%20Stock%20-%20Blind/106%20-%20Buy%20and%20sell%20crypto%20you%20are%20given%20an%20integ.md) | 5 | 1 |
| [107](#id107) | [Buy and sell crypto you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20And%20Sell%20Stock%20-%20Blind/107%20-%20Buy%20and%20sell%20crypto%20you%20are%20given%20an%20integ.md) | 5 | 1 |
| [108](#id108) | [Buy and sell crypto you are given an integ](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%201%20-%20Best%20Time%20to%20Buy%20And%20Sell%20Stock%20-%20Blind/108%20-%20Buy%20and%20sell%20crypto%20you%20are%20given%20an%20integ.md) | 5 | 1 |
| **-** | **Sliding Window > Longest Substring Without Repeating Characters** | **5** | **2** |
| [109](#id109) | [Longest substring without duplicates given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20-%20Blind/109%20-%20Longest%20substring%20without%20duplicates%20given.md) | 5 | 2 |
| [110](#id110) | [Longest substring without duplicates given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20-%20Blind/110%20-%20Longest%20substring%20without%20duplicates%20given.md) | 5 | 2 |
| [111](#id111) | [Longest substring without duplicates given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20-%20Blind/111%20-%20Longest%20substring%20without%20duplicates%20given.md) | 5 | 2 |
| [112](#id112) | [Longest substring without duplicates given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20-%20Blind/112%20-%20Longest%20substring%20without%20duplicates%20given.md) | 5 | 2 |
| [113](#id113) | [Longest substring without duplicates given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20-%20Blind/113%20-%20Longest%20substring%20without%20duplicates%20given.md) | 5 | 2 |
| [114](#id114) | [Longest substring without duplicates given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%202%20-%20Longest%20Substring%20Without%20Repeating%20Characters%20-%20Blind/114%20-%20Longest%20substring%20without%20duplicates%20given.md) | 5 | 2 |
| **-** | **Sliding Window > Longest Repeating Character Replacement** | **5** | **3** |
| [115](#id115) | [Longest repeating substring with replaceme](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20-%20Blind/115%20-%20Longest%20repeating%20substring%20with%20replaceme.md) | 5 | 3 |
| [116](#id116) | [Longest repeating substring with replaceme](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20-%20Blind/116%20-%20Longest%20repeating%20substring%20with%20replaceme.md) | 5 | 3 |
| [117](#id117) | [Longest repeating substring with replaceme](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20-%20Blind/117%20-%20Longest%20repeating%20substring%20with%20replaceme.md) | 5 | 3 |
| [118](#id118) | [Longest repeating substring with replaceme](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20-%20Blind/118%20-%20Longest%20repeating%20substring%20with%20replaceme.md) | 5 | 3 |
| [119](#id119) | [Longest repeating substring with replaceme](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20-%20Blind/119%20-%20Longest%20repeating%20substring%20with%20replaceme.md) | 5 | 3 |
| [120](#id120) | [Longest repeating substring with replaceme](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%203%20-%20Longest%20Repeating%20Character%20Replacement%20-%20Blind/120%20-%20Longest%20repeating%20substring%20with%20replaceme.md) | 5 | 3 |
| **-** | **Sliding Window > Minimum Window Substring** | **5** | **5** |
| [121](#id121) | [Minimum window with characters given two s](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20-%20Blind/121%20-%20Minimum%20window%20with%20characters%20given%20two%20s.md) | 5 | 5 |
| [122](#id122) | [Minimum window with characters given two s](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20-%20Blind/122%20-%20Minimum%20window%20with%20characters%20given%20two%20s.md) | 5 | 5 |
| [123](#id123) | [Minimum window with characters given two s](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20-%20Blind/123%20-%20Minimum%20window%20with%20characters%20given%20two%20s.md) | 5 | 5 |
| [124](#id124) | [Minimum window with characters given two s](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20-%20Blind/124%20-%20Minimum%20window%20with%20characters%20given%20two%20s.md) | 5 | 5 |
| [125](#id125) | [Minimum window with characters given two s](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20-%20Blind/125%20-%20Minimum%20window%20with%20characters%20given%20two%20s.md) | 5 | 5 |
| [126](#id126) | [Minimum window with characters given two s](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20-%20Blind/126%20-%20Minimum%20window%20with%20characters%20given%20two%20s.md) | 5 | 5 |
| [127](#id127) | [Minimum window with characters given two s](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20V%20-%20Sliding%20Window/Chapter%205%20-%20Minimum%20Window%20Substring%20-%20Blind/127%20-%20Minimum%20window%20with%20characters%20given%20two%20s.md) | 5 | 5 |
| **-** | **Linked List** | **6** | **-** |
| **-** | **Linked List > Reverse Linked List** | **6** | **1** |
| [128](#id128) | [Reverse a linked list given the beginning](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%201%20-%20Reverse%20Linked%20List%20-%20Blind/128%20-%20Reverse%20a%20linked%20list%20given%20the%20beginning.md) | 6 | 1 |
| [129](#id129) | [Reverse a linked list given the beginning](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%201%20-%20Reverse%20Linked%20List%20-%20Blind/129%20-%20Reverse%20a%20linked%20list%20given%20the%20beginning.md) | 6 | 1 |
| [130](#id130) | [Reverse a linked list given the beginning](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%201%20-%20Reverse%20Linked%20List%20-%20Blind/130%20-%20Reverse%20a%20linked%20list%20given%20the%20beginning.md) | 6 | 1 |
| [131](#id131) | [Reverse a linked list given the beginning](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%201%20-%20Reverse%20Linked%20List%20-%20Blind/131%20-%20Reverse%20a%20linked%20list%20given%20the%20beginning.md) | 6 | 1 |
| **-** | **Linked List > Merge Two Sorted Lists** | **6** | **2** |
| [132](#id132) | [Merge two sorted linked lists you are give](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20-%20Blind/132%20-%20Merge%20two%20sorted%20linked%20lists%20you%20are%20give.md) | 6 | 2 |
| [133](#id133) | [Merge two sorted linked lists you are give](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20-%20Blind/133%20-%20Merge%20two%20sorted%20linked%20lists%20you%20are%20give.md) | 6 | 2 |
| [134](#id134) | [Merge two sorted linked lists you are give](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20-%20Blind/134%20-%20Merge%20two%20sorted%20linked%20lists%20you%20are%20give.md) | 6 | 2 |
| [135](#id135) | [Merge two sorted linked lists you are give](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20-%20Blind/135%20-%20Merge%20two%20sorted%20linked%20lists%20you%20are%20give.md) | 6 | 2 |
| [136](#id136) | [Merge two sorted linked lists you are give](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%202%20-%20Merge%20Two%20Sorted%20Lists%20-%20Blind/136%20-%20Merge%20two%20sorted%20linked%20lists%20you%20are%20give.md) | 6 | 2 |
| **-** | **Linked List > Reorder List** | **6** | **3** |
| [137](#id137) | [Reorder linked list you are given the head](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20-%20Blind/137%20-%20Reorder%20linked%20list%20you%20are%20given%20the%20head.md) | 6 | 3 |
| [138](#id138) | [Reorder linked list you are given the head](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20-%20Blind/138%20-%20Reorder%20linked%20list%20you%20are%20given%20the%20head.md) | 6 | 3 |
| [139](#id139) | [Reorder linked list you are given the head](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20-%20Blind/139%20-%20Reorder%20linked%20list%20you%20are%20given%20the%20head.md) | 6 | 3 |
| [140](#id140) | [Reorder linked list you are given the head](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20-%20Blind/140%20-%20Reorder%20linked%20list%20you%20are%20given%20the%20head.md) | 6 | 3 |
| [141](#id141) | [Reorder linked list you are given the head](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%203%20-%20Reorder%20List%20-%20Blind/141%20-%20Reorder%20linked%20list%20you%20are%20given%20the%20head.md) | 6 | 3 |
| **-** | **Linked List > Remove Nth Node From End of List** | **6** | **4** |
| [142](#id142) | [Remove node from end of linked list you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20-%20Blind/142%20-%20Remove%20node%20from%20end%20of%20linked%20list%20you%20ar.md) | 6 | 4 |
| [143](#id143) | [Remove node from end of linked list you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20-%20Blind/143%20-%20Remove%20node%20from%20end%20of%20linked%20list%20you%20ar.md) | 6 | 4 |
| [144](#id144) | [Remove node from end of linked list you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20-%20Blind/144%20-%20Remove%20node%20from%20end%20of%20linked%20list%20you%20ar.md) | 6 | 4 |
| [145](#id145) | [Remove node from end of linked list you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20-%20Blind/145%20-%20Remove%20node%20from%20end%20of%20linked%20list%20you%20ar.md) | 6 | 4 |
| [146](#id146) | [Remove node from end of linked list you ar](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%204%20-%20Remove%20Nth%20Node%20From%20End%20of%20List%20-%20Blind/146%20-%20Remove%20node%20from%20end%20of%20linked%20list%20you%20ar.md) | 6 | 4 |
| **-** | **Linked List > Merge K Sorted Lists** | **6** | **10** |
| [147](#id147) | [Merge k sorted linked lists you are given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20K%20Sorted%20Lists%20-%20Blind/147%20-%20Merge%20k%20sorted%20linked%20lists%20you%20are%20given.md) | 6 | 10 |
| [148](#id148) | [Merge k sorted linked lists you are given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20K%20Sorted%20Lists%20-%20Blind/148%20-%20Merge%20k%20sorted%20linked%20lists%20you%20are%20given.md) | 6 | 10 |
| [149](#id149) | [Merge k sorted linked lists you are given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20K%20Sorted%20Lists%20-%20Blind/149%20-%20Merge%20k%20sorted%20linked%20lists%20you%20are%20given.md) | 6 | 10 |
| [150](#id150) | [Merge k sorted linked lists you are given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20K%20Sorted%20Lists%20-%20Blind/150%20-%20Merge%20k%20sorted%20linked%20lists%20you%20are%20given.md) | 6 | 10 |
| [151](#id151) | [Merge k sorted linked lists you are given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20K%20Sorted%20Lists%20-%20Blind/151%20-%20Merge%20k%20sorted%20linked%20lists%20you%20are%20given.md) | 6 | 10 |
| [152](#id152) | [Merge k sorted linked lists you are given](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VI%20-%20Linked%20List/Chapter%2010%20-%20Merge%20K%20Sorted%20Lists%20-%20Blind/152%20-%20Merge%20k%20sorted%20linked%20lists%20you%20are%20given.md) | 6 | 10 |
| **-** | **Trees** | **7** | **-** |
| **-** | **Trees > Invert Binary Tree** | **7** | **1** |
| [153](#id153) | [Invert a binary tree you are given the roo](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20-%20Blind/153%20-%20Invert%20a%20binary%20tree%20you%20are%20given%20the%20roo.md) | 7 | 1 |
| [154](#id154) | [Invert a binary tree you are given the roo](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20-%20Blind/154%20-%20Invert%20a%20binary%20tree%20you%20are%20given%20the%20roo.md) | 7 | 1 |
| [155](#id155) | [Invert a binary tree you are given the roo](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20-%20Blind/155%20-%20Invert%20a%20binary%20tree%20you%20are%20given%20the%20roo.md) | 7 | 1 |
| [156](#id156) | [Invert a binary tree you are given the roo](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20-%20Blind/156%20-%20Invert%20a%20binary%20tree%20you%20are%20given%20the%20roo.md) | 7 | 1 |
| [157](#id157) | [Invert a binary tree you are given the roo](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%201%20-%20Invert%20Binary%20Tree%20-%20Blind/157%20-%20Invert%20a%20binary%20tree%20you%20are%20given%20the%20roo.md) | 7 | 1 |
| **-** | **Trees > Maximum Depth of Binary Tree** | **7** | **2** |
| [158](#id158) | [Depth of binary tree given the root of a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20-%20Blind/158%20-%20Depth%20of%20binary%20tree%20given%20the%20root%20of%20a.md) | 7 | 2 |
| [159](#id159) | [Depth of binary tree given the root of a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20-%20Blind/159%20-%20Depth%20of%20binary%20tree%20given%20the%20root%20of%20a.md) | 7 | 2 |
| [160](#id160) | [Depth of binary tree given the root of a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20-%20Blind/160%20-%20Depth%20of%20binary%20tree%20given%20the%20root%20of%20a.md) | 7 | 2 |
| [161](#id161) | [Depth of binary tree given the root of a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20-%20Blind/161%20-%20Depth%20of%20binary%20tree%20given%20the%20root%20of%20a.md) | 7 | 2 |
| [162](#id162) | [Depth of binary tree given the root of a](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%202%20-%20Maximum%20Depth%20of%20Binary%20Tree%20-%20Blind/162%20-%20Depth%20of%20binary%20tree%20given%20the%20root%20of%20a.md) | 7 | 2 |
| **-** | **Trees > Same Tree** | **7** | **5** |
| [163](#id163) | [Same tree given the roots of two binary tr](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%205%20-%20Same%20Tree%20-%20Blind/163%20-%20Same%20tree%20given%20the%20roots%20of%20two%20binary%20tr.md) | 7 | 5 |
| [164](#id164) | [Same tree given the roots of two binary tr](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%205%20-%20Same%20Tree%20-%20Blind/164%20-%20Same%20tree%20given%20the%20roots%20of%20two%20binary%20tr.md) | 7 | 5 |
| [165](#id165) | [Same tree given the roots of two binary tr](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%205%20-%20Same%20Tree%20-%20Blind/165%20-%20Same%20tree%20given%20the%20roots%20of%20two%20binary%20tr.md) | 7 | 5 |
| [166](#id166) | [Same tree given the roots of two binary tr](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%205%20-%20Same%20Tree%20-%20Blind/166%20-%20Same%20tree%20given%20the%20roots%20of%20two%20binary%20tr.md) | 7 | 5 |
| [167](#id167) | [Same tree given the roots of two binary tr](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%205%20-%20Same%20Tree%20-%20Blind/167%20-%20Same%20tree%20given%20the%20roots%20of%20two%20binary%20tr.md) | 7 | 5 |
| **-** | **Trees > Subtree of Another Tree** | **7** | **6** |
| [168](#id168) | [Subtree of another tree given the roots of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%206%20-%20Subtree%20of%20Another%20Tree%20-%20Blind/168%20-%20Subtree%20of%20another%20tree%20given%20the%20roots%20of.md) | 7 | 6 |
| [169](#id169) | [Subtree of another tree given the roots of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%206%20-%20Subtree%20of%20Another%20Tree%20-%20Blind/169%20-%20Subtree%20of%20another%20tree%20given%20the%20roots%20of.md) | 7 | 6 |
| [170](#id170) | [Subtree of another tree given the roots of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%206%20-%20Subtree%20of%20Another%20Tree%20-%20Blind/170%20-%20Subtree%20of%20another%20tree%20given%20the%20roots%20of.md) | 7 | 6 |
| [171](#id171) | [Subtree of another tree given the roots of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%206%20-%20Subtree%20of%20Another%20Tree%20-%20Blind/171%20-%20Subtree%20of%20another%20tree%20given%20the%20roots%20of.md) | 7 | 6 |
| [172](#id172) | [Subtree of another tree given the roots of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%206%20-%20Subtree%20of%20Another%20Tree%20-%20Blind/172%20-%20Subtree%20of%20another%20tree%20given%20the%20roots%20of.md) | 7 | 6 |
| **-** | **Trees > Lowest Common Ancestor of a Binary Search Tree** | **7** | **7** |
| [173](#id173) | [Lowest common ancestor of a binary search](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%207%20-%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20-%20Blind/173%20-%20Lowest%20common%20ancestor%20of%20a%20binary%20search.md) | 7 | 7 |
| [174](#id174) | [Lowest common ancestor of a binary search](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%207%20-%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20-%20Blind/174%20-%20Lowest%20common%20ancestor%20of%20a%20binary%20search.md) | 7 | 7 |
| [175](#id175) | [Lowest common ancestor of a binary search](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%207%20-%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20-%20Blind/175%20-%20Lowest%20common%20ancestor%20of%20a%20binary%20search.md) | 7 | 7 |
| [176](#id176) | [Lowest common ancestor of a binary search](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%207%20-%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20-%20Blind/176%20-%20Lowest%20common%20ancestor%20of%20a%20binary%20search.md) | 7 | 7 |
| [177](#id177) | [Lowest common ancestor of a binary search](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%207%20-%20Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree%20-%20Blind/177%20-%20Lowest%20common%20ancestor%20of%20a%20binary%20search.md) | 7 | 7 |
| **-** | **Trees > Binary Tree Level Order Traversal** | **7** | **9** |
| [178](#id178) | [Binary tree level order traversal given th](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%209%20-%20Binary%20Tree%20Level%20Order%20Traversal%20-%20Blind/178%20-%20Binary%20tree%20level%20order%20traversal%20given%20th.md) | 7 | 9 |
| [179](#id179) | [Binary tree level order traversal given th](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%209%20-%20Binary%20Tree%20Level%20Order%20Traversal%20-%20Blind/179%20-%20Binary%20tree%20level%20order%20traversal%20given%20th.md) | 7 | 9 |
| [180](#id180) | [Binary tree level order traversal given th](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%209%20-%20Binary%20Tree%20Level%20Order%20Traversal%20-%20Blind/180%20-%20Binary%20tree%20level%20order%20traversal%20given%20th.md) | 7 | 9 |
| [181](#id181) | [Binary tree level order traversal given th](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20VII%20-%20Trees/Chapter%209%20-%20Binary%20Tree%20Level%20Order%20Traversal%20-%20Blind/181%20-%20Binary%20tree%20level%20order%20traversal%20given%20th.md) | 7 | 9 |
| **-** | **Backtracking** | **9** | **-** |
| **-** | **Backtracking > Combination Sum** | **9** | **2** |
| [182](#id182) | [Combination sum given an array of distin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IX%20-%20Backtracking/Chapter%202%20-%20Combination%20Sum%20-%20Blind/182%20-%20Combination%20sum%20given%20an%20array%20of%20distin.md) | 9 | 2 |
| [183](#id183) | [Combination sum given an array of distin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IX%20-%20Backtracking/Chapter%202%20-%20Combination%20Sum%20-%20Blind/183%20-%20Combination%20sum%20given%20an%20array%20of%20distin.md) | 9 | 2 |
| [184](#id184) | [Combination sum given an array of distin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IX%20-%20Backtracking/Chapter%202%20-%20Combination%20Sum%20-%20Blind/184%20-%20Combination%20sum%20given%20an%20array%20of%20distin.md) | 9 | 2 |
| [185](#id185) | [Combination sum given an array of distin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IX%20-%20Backtracking/Chapter%202%20-%20Combination%20Sum%20-%20Blind/185%20-%20Combination%20sum%20given%20an%20array%20of%20distin.md) | 9 | 2 |
| [186](#id186) | [Combination sum given an array of distin](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20IX%20-%20Backtracking/Chapter%202%20-%20Combination%20Sum%20-%20Blind/186%20-%20Combination%20sum%20given%20an%20array%20of%20distin.md) | 9 | 2 |
| **-** | **Graphs** | **11** | **-** |
| **-** | **Graphs > Number of Islands** | **11** | **1** |
| [187](#id187) | [Number of islands given an m x n 2d bina](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XI%20-%20Graphs/Chapter%201%20-%20Number%20of%20Islands%20-%20Blind/187%20-%20Number%20of%20islands%20given%20an%20m%20x%20n%202d%20bina.md) | 11 | 1 |
| [188](#id188) | [Number of islands given an m x n 2d bina](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XI%20-%20Graphs/Chapter%201%20-%20Number%20of%20Islands%20-%20Blind/188%20-%20Number%20of%20islands%20given%20an%20m%20x%20n%202d%20bina.md) | 11 | 1 |
| [189](#id189) | [Number of islands given an m x n 2d bina](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XI%20-%20Graphs/Chapter%201%20-%20Number%20of%20Islands%20-%20Blind/189%20-%20Number%20of%20islands%20given%20an%20m%20x%20n%202d%20bina.md) | 11 | 1 |
| [190](#id190) | [Number of islands given an m x n 2d bina](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XI%20-%20Graphs/Chapter%201%20-%20Number%20of%20Islands%20-%20Blind/190%20-%20Number%20of%20islands%20given%20an%20m%20x%20n%202d%20bina.md) | 11 | 1 |
| [191](#id191) | [Number of islands given an m x n 2d bina](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XI%20-%20Graphs/Chapter%201%20-%20Number%20of%20Islands%20-%20Blind/191%20-%20Number%20of%20islands%20given%20an%20m%20x%20n%202d%20bina.md) | 11 | 1 |
| [192](#id192) | [Number of islands given an m x n 2d bina](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XI%20-%20Graphs/Chapter%201%20-%20Number%20of%20Islands%20-%20Blind/192%20-%20Number%20of%20islands%20given%20an%20m%20x%20n%202d%20bina.md) | 11 | 1 |
| **-** | **1-D DP** | **12** | **-** |
| **-** | **1-D DP > House Robber** | **12** | **3** |
| [193](#id193) | [House robber you are a professional robber](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XII%20-%201-D%20DP/Chapter%203%20-%20House%20Robber%20-%20Blind/193%20-%20House%20robber%20you%20are%20a%20professional%20robber.md) | 12 | 3 |
| [194](#id194) | [House robber you are a professional robber](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XII%20-%201-D%20DP/Chapter%203%20-%20House%20Robber%20-%20Blind/194%20-%20House%20robber%20you%20are%20a%20professional%20robber.md) | 12 | 3 |
| [195](#id195) | [House robber you are a professional robber](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XII%20-%201-D%20DP/Chapter%203%20-%20House%20Robber%20-%20Blind/195%20-%20House%20robber%20you%20are%20a%20professional%20robber.md) | 12 | 3 |
| [196](#id196) | [House robber you are a professional robber](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XII%20-%201-D%20DP/Chapter%203%20-%20House%20Robber%20-%20Blind/196%20-%20House%20robber%20you%20are%20a%20professional%20robber.md) | 12 | 3 |
| [197](#id197) | [House robber you are a professional robber](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XII%20-%201-D%20DP/Chapter%203%20-%20House%20Robber%20-%20Blind/197%20-%20House%20robber%20you%20are%20a%20professional%20robber.md) | 12 | 3 |
| [198](#id198) | [House robber you are a professional robber](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XII%20-%201-D%20DP/Chapter%203%20-%20House%20Robber%20-%20Blind/198%20-%20House%20robber%20you%20are%20a%20professional%20robber.md) | 12 | 3 |
| [199](#id199) | [House robber you are a professional robber](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XII%20-%201-D%20DP/Chapter%203%20-%20House%20Robber%20-%20Blind/199%20-%20House%20robber%20you%20are%20a%20professional%20robber.md) | 12 | 3 |
| [200](#id200) | [House robber you are a professional robber](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XII%20-%201-D%20DP/Chapter%203%20-%20House%20Robber%20-%20Blind/200%20-%20House%20robber%20you%20are%20a%20professional%20robber.md) | 12 | 3 |
| **-** | **Intervals** | **13** | **-** |
| **-** | **Intervals > Insert Interval** | **13** | **1** |
| [201](#id201) | [Insert interval you are given an array of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%201%20-%20Insert%20Interval%20-%20Blind/201%20-%20Insert%20interval%20you%20are%20given%20an%20array%20of.md) | 13 | 1 |
| [202](#id202) | [Insert interval you are given an array of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%201%20-%20Insert%20Interval%20-%20Blind/202%20-%20Insert%20interval%20you%20are%20given%20an%20array%20of.md) | 13 | 1 |
| [203](#id203) | [Insert interval you are given an array of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%201%20-%20Insert%20Interval%20-%20Blind/203%20-%20Insert%20interval%20you%20are%20given%20an%20array%20of.md) | 13 | 1 |
| [204](#id204) | [Insert interval you are given an array of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%201%20-%20Insert%20Interval%20-%20Blind/204%20-%20Insert%20interval%20you%20are%20given%20an%20array%20of.md) | 13 | 1 |
| [205](#id205) | [Insert interval you are given an array of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%201%20-%20Insert%20Interval%20-%20Blind/205%20-%20Insert%20interval%20you%20are%20given%20an%20array%20of.md) | 13 | 1 |
| [206](#id206) | [Insert interval you are given an array of](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%201%20-%20Insert%20Interval%20-%20Blind/206%20-%20Insert%20interval%20you%20are%20given%20an%20array%20of.md) | 13 | 1 |
| **-** | **Intervals > Merge Intervals** | **13** | **2** |
| [207](#id207) | [Merge intervals given an array of interva](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%202%20-%20Merge%20Intervals%20-%20Blind/207%20-%20Merge%20intervals%20given%20an%20array%20of%20interva.md) | 13 | 2 |
| [208](#id208) | [Merge intervals given an array of interva](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%202%20-%20Merge%20Intervals%20-%20Blind/208%20-%20Merge%20intervals%20given%20an%20array%20of%20interva.md) | 13 | 2 |
| [209](#id209) | [Merge intervals given an array of interva](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%202%20-%20Merge%20Intervals%20-%20Blind/209%20-%20Merge%20intervals%20given%20an%20array%20of%20interva.md) | 13 | 2 |
| [210](#id210) | [Merge intervals given an array of interva](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%202%20-%20Merge%20Intervals%20-%20Blind/210%20-%20Merge%20intervals%20given%20an%20array%20of%20interva.md) | 13 | 2 |
| [211](#id211) | [Merge intervals given an array of interva](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%202%20-%20Merge%20Intervals%20-%20Blind/211%20-%20Merge%20intervals%20given%20an%20array%20of%20interva.md) | 13 | 2 |
| **-** | **Intervals > Non Overlapping Intervals** | **13** | **3** |
| [212](#id212) | [Non overlapping intervals given an array o](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%203%20-%20Non%20Overlapping%20Intervals%20-%20Blind/212%20-%20Non%20overlapping%20intervals%20given%20an%20array%20o.md) | 13 | 3 |
| [213](#id213) | [Non overlapping intervals given an array o](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%203%20-%20Non%20Overlapping%20Intervals%20-%20Blind/213%20-%20Non%20overlapping%20intervals%20given%20an%20array%20o.md) | 13 | 3 |
| [214](#id214) | [Non overlapping intervals given an array o](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%203%20-%20Non%20Overlapping%20Intervals%20-%20Blind/214%20-%20Non%20overlapping%20intervals%20given%20an%20array%20o.md) | 13 | 3 |
| [215](#id215) | [Non overlapping intervals given an array o](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%203%20-%20Non%20Overlapping%20Intervals%20-%20Blind/215%20-%20Non%20overlapping%20intervals%20given%20an%20array%20o.md) | 13 | 3 |
| [216](#id216) | [Non overlapping intervals given an array o](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%203%20-%20Non%20Overlapping%20Intervals%20-%20Blind/216%20-%20Non%20overlapping%20intervals%20given%20an%20array%20o.md) | 13 | 3 |
| **-** | **Intervals > Meeting Rooms** | **13** | **4** |
| [217](#id217) | [Meeting rooms given an array of meeting ti](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%204%20-%20Meeting%20Rooms%20-%20Blind/217%20-%20Meeting%20rooms%20given%20an%20array%20of%20meeting%20ti.md) | 13 | 4 |
| [218](#id218) | [Meeting rooms given an array of meeting ti](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%204%20-%20Meeting%20Rooms%20-%20Blind/218%20-%20Meeting%20rooms%20given%20an%20array%20of%20meeting%20ti.md) | 13 | 4 |
| [219](#id219) | [Meeting rooms given an array of meeting ti](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%204%20-%20Meeting%20Rooms%20-%20Blind/219%20-%20Meeting%20rooms%20given%20an%20array%20of%20meeting%20ti.md) | 13 | 4 |
| [220](#id220) | [Meeting rooms given an array of meeting ti](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%204%20-%20Meeting%20Rooms%20-%20Blind/220%20-%20Meeting%20rooms%20given%20an%20array%20of%20meeting%20ti.md) | 13 | 4 |
| **-** | **Intervals > Meeting Rooms II** | **13** | **5** |
| [221](#id221) | [Meeting rooms ii given an array of meeting](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%205%20-%20Meeting%20Rooms%20II%20-%20Blind/221%20-%20Meeting%20rooms%20ii%20given%20an%20array%20of%20meeting.md) | 13 | 5 |
| [222](#id222) | [Meeting rooms ii given an array of meeting](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%205%20-%20Meeting%20Rooms%20II%20-%20Blind/222%20-%20Meeting%20rooms%20ii%20given%20an%20array%20of%20meeting.md) | 13 | 5 |
| [223](#id223) | [Meeting rooms ii given an array of meeting](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%205%20-%20Meeting%20Rooms%20II%20-%20Blind/223%20-%20Meeting%20rooms%20ii%20given%20an%20array%20of%20meeting.md) | 13 | 5 |
| [224](#id224) | [Meeting rooms ii given an array of meeting](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%205%20-%20Meeting%20Rooms%20II%20-%20Blind/224%20-%20Meeting%20rooms%20ii%20given%20an%20array%20of%20meeting.md) | 13 | 5 |
| [225](#id225) | [Meeting rooms ii given an array of meeting](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XIII%20-%20Intervals/Chapter%205%20-%20Meeting%20Rooms%20II%20-%20Blind/225%20-%20Meeting%20rooms%20ii%20given%20an%20array%20of%20meeting.md) | 13 | 5 |
| **-** | **Math Geometry** | **18** | **-** |
| **-** | **Math Geometry > Rotate Image** | **18** | **1** |
| [226](#id226) | [Rotate image you are given an n x n 2d](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%201%20-%20Rotate%20Image%20-%20Blind/226%20-%20Rotate%20image%20you%20are%20given%20an%20n%20x%20n%202d.md) | 18 | 1 |
| [227](#id227) | [Rotate image you are given an n x n 2d](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%201%20-%20Rotate%20Image%20-%20Blind/227%20-%20Rotate%20image%20you%20are%20given%20an%20n%20x%20n%202d.md) | 18 | 1 |
| [228](#id228) | [Rotate image you are given an n x n 2d](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%201%20-%20Rotate%20Image%20-%20Blind/228%20-%20Rotate%20image%20you%20are%20given%20an%20n%20x%20n%202d.md) | 18 | 1 |
| [229](#id229) | [Rotate image you are given an n x n 2d](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%201%20-%20Rotate%20Image%20-%20Blind/229%20-%20Rotate%20image%20you%20are%20given%20an%20n%20x%20n%202d.md) | 18 | 1 |
| [230](#id230) | [Rotate image you are given an n x n 2d](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%201%20-%20Rotate%20Image%20-%20Blind/230%20-%20Rotate%20image%20you%20are%20given%20an%20n%20x%20n%202d.md) | 18 | 1 |
| **-** | **Math Geometry > Spiral Matrix** | **18** | **2** |
| [231](#id231) | [Spiral matrix given an m x n matrix r](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%202%20-%20Spiral%20Matrix%20-%20Blind/231%20-%20Spiral%20matrix%20given%20an%20m%20x%20n%20matrix%20r.md) | 18 | 2 |
| [232](#id232) | [Spiral matrix given an m x n matrix r](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%202%20-%20Spiral%20Matrix%20-%20Blind/232%20-%20Spiral%20matrix%20given%20an%20m%20x%20n%20matrix%20r.md) | 18 | 2 |
| [233](#id233) | [Spiral matrix given an m x n matrix r](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%202%20-%20Spiral%20Matrix%20-%20Blind/233%20-%20Spiral%20matrix%20given%20an%20m%20x%20n%20matrix%20r.md) | 18 | 2 |
| [234](#id234) | [Spiral matrix given an m x n matrix r](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%202%20-%20Spiral%20Matrix%20-%20Blind/234%20-%20Spiral%20matrix%20given%20an%20m%20x%20n%20matrix%20r.md) | 18 | 2 |
| [235](#id235) | [Spiral matrix given an m x n matrix r](./MNAB%20-%20Neetcode%20150%20and%20blind%2075%20-%20multi-author/Part%20XVIII%20-%20Math%20Geometry/Chapter%202%20-%20Spiral%20Matrix%20-%20Blind/235%20-%20Spiral%20matrix%20given%20an%20m%20x%20n%20matrix%20r.md) | 18 | 2 |

### Part I - Arrays & Hashing

#### Chapter 1 - Contains Duplicate - [Blind]

Q:: =============================================  

##### Duplicate Integer

Given an integer array `nums`, return `true` if any value appears **more than once** in the array, otherwise return `false`.

**Example 1:**

```
Input: nums = [1, 2, 3, 3]

Output: true
```

**Example 2:**

```
Input: nums = [1, 2, 3, 4]

Output: false
```

___

How many possible pairs of elements are there in an array of size n?

A) log n

B) n

C) n^2

D) 2^n

###### ID1

A:: =============================================  
**Answer**: C

There are exactly n \* (n - 1) / 2 distinct pairs of integers in the array. This is equivalent to (n^2 - n) / 2, and we normally consider the largest term, which in this case is n^2.

Q:: =============================================  

##### Duplicate Integer

Given an integer array `nums`, return `true` if any value appears **more than once** in the array, otherwise return `false`.

**Example 1:**

```
Input: nums = [1, 2, 3, 3]

Output: true
```

**Example 2:**

```
Input: nums = [1, 2, 3, 4]

Output: false
```

___

What is the time complexity of a brute force approach, where you compare every possible pair in the array to check if there are any duplicates?

A) O(n)

B) O(n \* log n)

C) O(n^2)

D) O(2^n)

###### ID2

A:: =============================================  
**Answer**: C

The brute-force solution using two nested loops has a time complexity of O(n^2) because for each element in the array, you need to iterate over up to n other elements.

Q:: =============================================  

##### Duplicate Integer

Given an integer array `nums`, return `true` if any value appears **more than once** in the array, otherwise return `false`.

**Example 1:**

```
Input: nums = [1, 2, 3, 3]

Output: true
```

**Example 2:**

```
Input: nums = [1, 2, 3, 4]

Output: false
```

___

What data structure can you use to optimize the approach for checking if there are any duplicate elements in the array?

A) Queue

B) Priority Queue

C) Stack

D) Hashmap or HashSet

###### ID3

A:: =============================================  
**Answer**: D

A Hashmap (or Hashtable) and a HashSet allow us to store and retrieve values in constant time, O(1). We can utilize this property to efficiently check for duplicates.

Q:: =============================================  

##### Duplicate Integer

Given an integer array `nums`, return `true` if any value appears **more than once** in the array, otherwise return `false`.

**Example 1:**

```
Input: nums = [1, 2, 3, 3]

Output: true
```

**Example 2:**

```
Input: nums = [1, 2, 3, 4]

Output: false
```

___

How can a HashSet be used to efficiently check for duplicates in the array?

A) Iterate through each element in the array and try to insert it into the HashSet. If an insertion fails (the element already exists in the HashSet), return true to indicate a duplicate was found.

B) Insert all elements from the array into the HashSet without checking for duplicates during this process. After all insertions, compare the size of the HashSet with the size of the array. If the HashSet size is smaller, return true to indicate a duplicate exists.

C) Both A and B

###### ID4

A:: =============================================  
**Answer**: C

A HashSet does not allow duplicate values. So, if you try to insert an element that already exists in the HashSet, it will not add the element and you know you've found a duplicate (choice A). Alternatively, you could add all elements to the HashSet and then compare its size to the size of the array. If the sizes are different, then there must have been a duplicate in the array (choice B). Both these methods will help identify if a duplicate exists in the array.

Q:: =============================================  

##### Duplicate Integer

Given an integer array `nums`, return `true` if any value appears **more than once** in the array, otherwise return `false`.

**Example 1:**

```
Input: nums = [1, 2, 3, 3]

Output: true
```

**Example 2:**

```
Input: nums = [1, 2, 3, 4]

Output: false
```

___

What is the time and space complexity of the solution using a hashmap?

A) Time complexity: O(n)  
Space complexity: O(n)

B) Time complexity: O(n \* log n)  
Space complexity: O(n)

C) Time complexity: O(n^2)  
Space complexity: O(1)

D) Time complexity: O(n)  
Space complexity: O(1)

###### ID5

A:: =============================================  
**Answer**: A

The hashmap solution has a time complexity of O(n) because you need to iterate through the array once. Also, the key lookup operation with hashmaps runs in O(1) time. The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the hashmap.

#### Chapter 2 - Valid Anagram - [Blind]

Q:: =============================================  

##### Is Anagram

Given two strings `s` and `t`, return `true` if the two strings are anagrams of each other, otherwise return `false`.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: s = "racecar", t = "carrace"

Output: true
```

**Example 2:**

```
Input: s = "jar", t = "jam"

Output: false
```

**Constraints:**

-   `s` and `t` consist of lowercase English letters.

___

What is the primary characteristic of an anagram?

A) Both words have the same length.

B) Both words have the same letters, in the same quantities.

C) Both words have the same first letter.

D) Both words have the same last letter.

###### ID6

A:: =============================================  
**Answer**: B

An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. This means both words have the same letters, in the same quantities. For example, 'Heart' is an anagram of 'Earth'.

Q:: =============================================  

##### Is Anagram

Given two strings `s` and `t`, return `true` if the two strings are anagrams of each other, otherwise return `false`.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: s = "racecar", t = "carrace"

Output: true
```

**Example 2:**

```
Input: s = "jar", t = "jam"

Output: false
```

**Constraints:**

-   `s` and `t` consist of lowercase English letters.

___

Given the nature of anagrams, which of the following methods can be used to check if two words are anagrams?

A) Compare the lengths of two words. If they are equal, the words are anagrams.

B) Convert each word to an array, sort the arrays, and then compare them.

C) Check if the first letter of the first word is present in the second word.

###### ID7

A:: =============================================  
**Answer**: B

By converting each word to an array, sorting the arrays, and then comparing them, we can confirm if two words are anagrams. This is because anagrams have the same letters in the same quantities. For example, after sorting either 'heart' and 'earth', the result is 'aehrt'.

Q:: =============================================  

##### Is Anagram

Given two strings `s` and `t`, return `true` if the two strings are anagrams of each other, otherwise return `false`.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: s = "racecar", t = "carrace"

Output: true
```

**Example 2:**

```
Input: s = "jar", t = "jam"

Output: false
```

**Constraints:**

-   `s` and `t` consist of lowercase English letters.

___

What is the time complexity of the solution that sorts and then compares the arrays? Note: We are using an efficient sorting algorithm where we can't make any assumptions about the character set.

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID8

A:: =============================================  
**Answer**: B

The time complexity of sorting an array of n elements is O(n log n), and the time complexity of comparing two arrays is O(n). When considering the largest term, the time complexity of the solution becomes O(n log n).

Q:: =============================================  

##### Is Anagram

Given two strings `s` and `t`, return `true` if the two strings are anagrams of each other, otherwise return `false`.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: s = "racecar", t = "carrace"

Output: true
```

**Example 2:**

```
Input: s = "jar", t = "jam"

Output: false
```

**Constraints:**

-   `s` and `t` consist of lowercase English letters.

___

Given the nature of anagrams and the constraints of the problem, can you improve upon the overall time complexity of the sorting solution?

A) No, sorting and comparing is the most optimal solution.

B) Yes, by using a hashmap to store the count of letters.

C) Yes, by checking if the first and last letter of both words are the same.

###### ID9

A:: =============================================  
**Answer**: B

Given the constraints of the problem and the nature of anagrams, we can use a hashmap to store the count of letters for each string. This would allow us to compare the frequency of each letter in both strings in a more time-efficient way. The downside is we may need extra memory, compared to an in-place sorting algorithm.

Q:: =============================================  

##### Is Anagram

Given two strings `s` and `t`, return `true` if the two strings are anagrams of each other, otherwise return `false`.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: s = "racecar", t = "carrace"

Output: true
```

**Example 2:**

```
Input: s = "jar", t = "jam"

Output: false
```

**Constraints:**

-   `s` and `t` consist of lowercase English letters.

___

If using a hashmap to check if two words are anagrams, what would be the keys and the values in the hashmap?

A) Keys = Words, Values = Count of each word

B) Keys = Letters, Values = Count of each letter

C) Keys = Length of words, Values = Words of that length

###### ID10

A:: =============================================  
**Answer**: B

In this case, the keys would be the letters, and the values would be the count of each letter. This way, we can track the frequency of each letter in the strings and compare them.

Q:: =============================================  

##### Is Anagram

Given two strings `s` and `t`, return `true` if the two strings are anagrams of each other, otherwise return `false`.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: s = "racecar", t = "carrace"

Output: true
```

**Example 2:**

```
Input: s = "jar", t = "jam"

Output: false
```

**Constraints:**

-   `s` and `t` consist of lowercase English letters.

___

What is the time and space complexity of the solution using a hashmap to count and compare the frequency of each letter?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID11

A:: =============================================  
**Answer**: A

The time complexity of this solution is O(n) because we iterate over the input strings once. The space complexity is also O(n) because in the worst-case scenario (where each letter is unique), we would need to store each letter in the hashmap.

#### Chapter 3 - Two Sum - [Blind]

Q:: =============================================  

##### Two Integer Sum

Given an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.

You may assume that _every_ input has exactly one pair of indices `i` and `j` that satisfy the condition.

Return the answer with the smaller index first.

**Example 1:**

```
Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
```

Explanation: `nums[0] + nums[1] == 7`, so we return `[0, 1]`.

**Example 2:**

```
Input: nums = [4,5,6], target = 10

Output: [0,2]
```

**Example 3:**

```
Input: nums = [5,5], target = 10

Output: [0,1]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-10,000,000 <= nums[i] <= 10,000,000`
-   `-10,000,000 <= target <= 10,000,000`

___

Roughly how many pairs of integers are there within the array? Assume the size of the array is `n`.

A) log n

B) n

C) n^2

D) 2^n

###### ID12

A:: =============================================  
**Answer**: C

There are exactly n \* (n - 1) / 2 distinct pairs of integers in the array. This is equivalent to (n^2 - n) / 2 and we normally care about the largest term, which in this case is n^2.

Q:: =============================================  

##### Two Integer Sum

Given an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.

You may assume that _every_ input has exactly one pair of indices `i` and `j` that satisfy the condition.

Return the answer with the smaller index first.

**Example 1:**

```
Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
```

Explanation: `nums[0] + nums[1] == 7`, so we return `[0, 1]`.

**Example 2:**

```
Input: nums = [4,5,6], target = 10

Output: [0,2]
```

**Example 3:**

```
Input: nums = [5,5], target = 10

Output: [0,1]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-10,000,000 <= nums[i] <= 10,000,000`
-   `-10,000,000 <= target <= 10,000,000`

___

How can you find all pairs of elements `x1, x2` within an array, which have a different index?

A) Sorting the array and using binary search to find a pair

B) Using two nested loops to iterate over all pairs of elements

C) Using divide and conquer to recursively find pairs

###### ID13

A:: =============================================  
**Answer**: B

To find all pairs of elements with different indices in the array, you can use two nested loops. The first loop iterates over each element, while the second loop only iterates over the elements to the right of the current element. This allows you to compare all possible pairs without duplicates.

Q:: =============================================  

##### Two Integer Sum

Given an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.

You may assume that _every_ input has exactly one pair of indices `i` and `j` that satisfy the condition.

Return the answer with the smaller index first.

**Example 1:**

```
Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
```

Explanation: `nums[0] + nums[1] == 7`, so we return `[0, 1]`.

**Example 2:**

```
Input: nums = [4,5,6], target = 10

Output: [0,2]
```

**Example 3:**

```
Input: nums = [5,5], target = 10

Output: [0,1]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-10,000,000 <= nums[i] <= 10,000,000`
-   `-10,000,000 <= target <= 10,000,000`

___

After finding each pair of elements, we can then easily determine the indices of the elements that sum to the target. What is the time complexity of this brute-force solution?

A) O(n)

B) O(n \* log n)

C) O(n^2)

D) O(2^n)

###### ID14

A:: =============================================  
**Answer**: C

The brute-force solution using two nested loops has a time complexity of O(n^2) because for each element in the array, you need to iterate over up to n other elements.

Q:: =============================================  

##### Two Integer Sum

Given an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.

You may assume that _every_ input has exactly one pair of indices `i` and `j` that satisfy the condition.

Return the answer with the smaller index first.

**Example 1:**

```
Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
```

Explanation: `nums[0] + nums[1] == 7`, so we return `[0, 1]`.

**Example 2:**

```
Input: nums = [4,5,6], target = 10

Output: [0,2]
```

**Example 3:**

```
Input: nums = [5,5], target = 10

Output: [0,1]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-10,000,000 <= nums[i] <= 10,000,000`
-   `-10,000,000 <= target <= 10,000,000`

___

For any given element `x` within the array, how many possible unique `y-values` would satisfy `target = x + y`?

A) 1

B) 2

C) n - 1

D) n

###### ID15

A:: =============================================  
**Answer**: A

We can solve this equation for y: y = target - x. For example, if target=9, and x=2, then y = 9 - 2 = 7. In mathematics, this value is known as the complement.

Q:: =============================================  

##### Two Integer Sum

Given an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.

You may assume that _every_ input has exactly one pair of indices `i` and `j` that satisfy the condition.

Return the answer with the smaller index first.

**Example 1:**

```
Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
```

Explanation: `nums[0] + nums[1] == 7`, so we return `[0, 1]`.

**Example 2:**

```
Input: nums = [4,5,6], target = 10

Output: [0,2]
```

**Example 3:**

```
Input: nums = [5,5], target = 10

Output: [0,1]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-10,000,000 <= nums[i] <= 10,000,000`
-   `-10,000,000 <= target <= 10,000,000`

___

Can you reduce the time complexity of the algorithm to find the indices of two numbers that add up to the target using a data structure?

A) No, the time complexity cannot be reduced

B) Yes, using a priority queue

C) Yes, using a hashmap

D) Yes, using a balanced binary search tree

###### ID16

A:: =============================================  
**Answer**: C

Yes, you can reduce the time complexity using a hashmap. A hashmap allows you to store and retrieve values in O(1) - constant time, which can help you find the required indices more efficiently than a brute-force solution.

Q:: =============================================  

##### Two Integer Sum

Given an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.

You may assume that _every_ input has exactly one pair of indices `i` and `j` that satisfy the condition.

Return the answer with the smaller index first.

**Example 1:**

```
Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
```

Explanation: `nums[0] + nums[1] == 7`, so we return `[0, 1]`.

**Example 2:**

```
Input: nums = [4,5,6], target = 10

Output: [0,2]
```

**Example 3:**

```
Input: nums = [5,5], target = 10

Output: [0,1]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-10,000,000 <= nums[i] <= 10,000,000`
-   `-10,000,000 <= target <= 10,000,000`

___

How can a hashmap be used to efficiently find the indices of two numbers that add up to the target in an array?

A) Key = Index of each element, Value = Difference between the target and the corresponding element;  
then for each element check if the difference between the target and the element exists as a value in the hashmap.

B) Key = Each element in the array, Value = The index of the corresponding element;  
then for each element check if the difference exists in the hashmap as a key, and that it has a different index from the current element.

###### ID17

A:: =============================================  
**Answer**: B

By storing each element in the array as a key and its index as the corresponding value in the hashmap, you can efficiently find the required pair. For each element, you can efficiently calculate the difference and check if it’s a key within the hashmap. If it does, we can get the index from the hashmap. If the index of the difference is different from the index of the current element (remember we are not allowed reuse the same element twice), then you've found the solution.

Q:: =============================================  

##### Two Integer Sum

Given an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.

You may assume that _every_ input has exactly one pair of indices `i` and `j` that satisfy the condition.

Return the answer with the smaller index first.

**Example 1:**

```
Input: 
nums = [3,4,5,6], target = 7

Output: [0,1]
```

Explanation: `nums[0] + nums[1] == 7`, so we return `[0, 1]`.

**Example 2:**

```
Input: nums = [4,5,6], target = 10

Output: [0,2]
```

**Example 3:**

```
Input: nums = [5,5], target = 10

Output: [0,1]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-10,000,000 <= nums[i] <= 10,000,000`
-   `-10,000,000 <= target <= 10,000,000`

___

What is the time and space complexity of the optimal solution using a hashmap?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n \* log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID18

A:: =============================================  
**Answer**: A

The hashmap solution has a time complexity of O(n) because you need to iterate through the array once. Also, the key lookup operation with hashmaps runs in O(1) time. The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the hashmap.

#### Chapter 4 - Group Anagrams - [Blind]

Q:: =============================================  

##### Anagram Groups

Given an array of strings `strs`, group all _anagrams_ together into sublists. You may return the output in **any order**.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: strs = ["act","pots","tops","cat","stop","hat"]

Output: [["hat"],["act", "cat"],["stop", "pots", "tops"]]
```

**Example 2:**

```
Input: strs = ["x"]

Output: [["x"]]
```

**Example 3:**

```
Input: strs = [""]

Output: [[""]]
```

**Constraints:**

-   `1 <= strs.length <= 1000`.
-   `0 <= strs[i].length <= 100`
-   `strs[i]` is made up of lowercase English letters.

___

What is the time complexity of a brute force approach that compares every pair of strings to check if they are anagrams?

A) O(n)

B) O(n \* log n)

C) O(n^2 \* k), where k is the maximum length of a string

D) O(n^2 \* k \* log k), where k is the maximum length of a string

###### ID19

A:: =============================================  
**Answer**: D

The brute force approach would compare every pair of strings (O(n^2)) and for each comparison, it would need to sort both strings to check if they are anagrams (O(k \* log k) for each string, where k is the length of the string). This results in a total time complexity of O(n^2 \* k \* log k).

Q:: =============================================  

##### Anagram Groups

Given an array of strings `strs`, group all _anagrams_ together into sublists. You may return the output in **any order**.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: strs = ["act","pots","tops","cat","stop","hat"]

Output: [["hat"],["act", "cat"],["stop", "pots", "tops"]]
```

**Example 2:**

```
Input: strs = ["x"]

Output: [["x"]]
```

**Example 3:**

```
Input: strs = [""]

Output: [[""]]
```

**Constraints:**

-   `1 <= strs.length <= 1000`.
-   `0 <= strs[i].length <= 100`
-   `strs[i]` is made up of lowercase English letters.

___

What data structure can be used to optimize the approach for grouping anagrams?

A) Array

B) LinkedList

C) Stack

D) HashMap

###### ID20

A:: =============================================  
**Answer**: D

A HashMap can be used to optimize the approach for grouping anagrams. We can use a sorted version of each string (or a count of its characters) as the key, and a list of all anagrams that match that key as the value. This allows us to group anagrams efficiently.

Q:: =============================================  

##### Anagram Groups

Given an array of strings `strs`, group all _anagrams_ together into sublists. You may return the output in **any order**.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: strs = ["act","pots","tops","cat","stop","hat"]

Output: [["hat"],["act", "cat"],["stop", "pots", "tops"]]
```

**Example 2:**

```
Input: strs = ["x"]

Output: [["x"]]
```

**Example 3:**

```
Input: strs = [""]

Output: [[""]]
```

**Constraints:**

-   `1 <= strs.length <= 1000`.
-   `0 <= strs[i].length <= 100`
-   `strs[i]` is made up of lowercase English letters.

___

What is the time complexity of the optimal solution using a HashMap?

A) O(n \* k), where k is the maximum length of a string

B) O(n \* k \* log k), where k is the maximum length of a string

C) O(n^2)

D) O(n \* log n)

###### ID21

A:: =============================================  
**Answer**: B

The optimal solution using a HashMap has a time complexity of O(n \* k \* log k), where n is the number of strings and k is the maximum length of a string. For each of the n strings, we need to sort it (O(k \* log k)) to create the key for our HashMap. The actual insertion into the HashMap is O(1) on average.

Q:: =============================================  

##### Anagram Groups

Given an array of strings `strs`, group all _anagrams_ together into sublists. You may return the output in **any order**.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: strs = ["act","pots","tops","cat","stop","hat"]

Output: [["hat"],["act", "cat"],["stop", "pots", "tops"]]
```

**Example 2:**

```
Input: strs = ["x"]

Output: [["x"]]
```

**Example 3:**

```
Input: strs = [""]

Output: [[""]]
```

**Constraints:**

-   `1 <= strs.length <= 1000`.
-   `0 <= strs[i].length <= 100`
-   `strs[i]` is made up of lowercase English letters.

___

What is the space complexity of the optimal solution using a HashMap?

A) O(n)

B) O(n \* k), where k is the maximum length of a string

C) O(n^2)

D) O(k), where k is the maximum length of a string

###### ID22

A:: =============================================  
**Answer**: B

The space complexity of the optimal solution using a HashMap is O(n \* k), where n is the number of strings and k is the maximum length of a string. In the worst case, we might need to store all n strings in our HashMap, and each string can be up to k characters long.

Q:: =============================================  

##### Anagram Groups

Given an array of strings `strs`, group all _anagrams_ together into sublists. You may return the output in **any order**.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: strs = ["act","pots","tops","cat","stop","hat"]

Output: [["hat"],["act", "cat"],["stop", "pots", "tops"]]
```

**Example 2:**

```
Input: strs = ["x"]

Output: [["x"]]
```

**Example 3:**

```
Input: strs = [""]

Output: [[""]]
```

**Constraints:**

-   `1 <= strs.length <= 1000`.
-   `0 <= strs[i].length <= 100`
-   `strs[i]` is made up of lowercase English letters.

___

Which of the following is NOT a valid way to generate a key for the HashMap when grouping anagrams?

A) Sorting the characters of the string

B) Creating a count of each character in the string

C) Using the original string as is

D) Using a prime number product based on character counts

###### ID23

A:: =============================================  
**Answer**: C

Using the original string as is would not be a valid way to generate a key for the HashMap when grouping anagrams. This is because anagrams can have different orders of characters, so they would end up as different keys in the HashMap. The other options (sorting, character count, prime number product) all produce the same key for anagrams regardless of the order of characters.

Q:: =============================================  

##### Anagram Groups

Given an array of strings `strs`, group all _anagrams_ together into sublists. You may return the output in **any order**.

An **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.

**Example 1:**

```
Input: strs = ["act","pots","tops","cat","stop","hat"]

Output: [["hat"],["act", "cat"],["stop", "pots", "tops"]]
```

**Example 2:**

```
Input: strs = ["x"]

Output: [["x"]]
```

**Example 3:**

```
Input: strs = [""]

Output: [[""]]
```

**Constraints:**

-   `1 <= strs.length <= 1000`.
-   `0 <= strs[i].length <= 100`
-   `strs[i]` is made up of lowercase English letters.

___

Given the constraint that the strings are made up of lowercase English letters, what is the maximum possible number of unique keys in our HashMap solution?

A) 26

B) 100

C) 26^100

D) 26!

###### ID24

A:: =============================================  
**Answer**: C

Given that the strings are made up of lowercase English letters and the maximum length of a string is 100, the maximum possible number of unique keys in our HashMap solution is 26^100. This is because for each of the 100 positions in the string, we have 26 possible choices of letters. However, in practice, this number is much smaller due to the constraints of actual words and the limited number of input strings.

#### Chapter 5 - Top K Frequent Elements - [Blind]

Q:: =============================================  

##### Top K Elements in List

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements within the array.

The test cases are generated such that the answer is always **unique**.

You may return the output in **any order**.

**Example 1:**

```
Input: nums = [1,2,2,3,3,3], k = 2

Output: [2,3]
```

**Example 2:**

```
Input: nums = [7,7], k = 1

Output: [7]
```

**Constraints:**

-   `1 <= nums.length <= 10^4`.
-   `-1000 <= nums[i] <= 1000`
-   `1 <= k <= number of distinct elements in nums`.

___

What is the first step in solving this problem efficiently?

A) Sort the array

B) Count the frequency of each element using a hashmap

C) Create a min-heap

D) Create a stack

###### ID25

A:: =============================================  
**Answer**: B

Counting the frequency of each element using a hashmap is the crucial first step. This allows us to know how many times each number appears in O(n) time, which we'll need before we can determine the k most frequent elements.

Q:: =============================================  

##### Top K Elements in List

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements within the array.

The test cases are generated such that the answer is always **unique**.

You may return the output in **any order**.

**Example 1:**

```
Input: nums = [1,2,2,3,3,3], k = 2

Output: [2,3]
```

**Example 2:**

```
Input: nums = [7,7], k = 1

Output: [7]
```

**Constraints:**

-   `1 <= nums.length <= 10^4`.
-   `-1000 <= nums[i] <= 1000`
-   `1 <= k <= number of distinct elements in nums`.

___

What is the time complexity of counting the frequency of each element in the array?

A) O(n log n)

B) O(n)

C) O(k)

D) O(n^2)

###### ID26

A:: =============================================  
**Answer**: B

Using a hashmap to count frequencies requires one pass through the array, accessing and updating the hashmap in O(1) time for each element. Therefore, the total time complexity is O(n) where n is the length of the array.

Q:: =============================================  

##### Top K Elements in List

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements within the array.

The test cases are generated such that the answer is always **unique**.

You may return the output in **any order**.

**Example 1:**

```
Input: nums = [1,2,2,3,3,3], k = 2

Output: [2,3]
```

**Example 2:**

```
Input: nums = [7,7], k = 1

Output: [7]
```

**Constraints:**

-   `1 <= nums.length <= 10^4`.
-   `-1000 <= nums[i] <= 1000`
-   `1 <= k <= number of distinct elements in nums`.

___

After counting frequencies, which data structure would be most efficient for finding the k most frequent elements?

A) Array

B) Binary Search Tree

C) Priority Queue (Heap)

D) LinkedList

###### ID27

A:: =============================================  
**Answer**: C

A Priority Queue (Heap) is ideal because we can maintain the k most frequent elements efficiently. We can use a min-heap of size k, which will give us O(n log k) time complexity for finding the k most frequent elements.

Q:: =============================================  

##### Top K Elements in List

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements within the array.

The test cases are generated such that the answer is always **unique**.

You may return the output in **any order**.

**Example 1:**

```
Input: nums = [1,2,2,3,3,3], k = 2

Output: [2,3]
```

**Example 2:**

```
Input: nums = [7,7], k = 1

Output: [7]
```

**Constraints:**

-   `1 <= nums.length <= 10^4`.
-   `-1000 <= nums[i] <= 1000`
-   `1 <= k <= number of distinct elements in nums`.

___

What is the space complexity of the entire solution using a hashmap and a heap?

A) O(1)

B) O(k)

C) O(n)

D) O(n + k)

###### ID28

A:: =============================================  
**Answer**: C

The space complexity is O(n) because:
1. The hashmap stores at most n different elements and their frequencies
2. The heap stores at most k elements, where k ≤ n
Therefore, O(n) dominates O(k), making the total space complexity O(n).

Q:: =============================================  

##### Top K Elements in List

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements within the array.

The test cases are generated such that the answer is always **unique**.

You may return the output in **any order**.

**Example 1:**

```
Input: nums = [1,2,2,3,3,3], k = 2

Output: [2,3]
```

**Example 2:**

```
Input: nums = [7,7], k = 1

Output: [7]
```

**Constraints:**

-   `1 <= nums.length <= 10^4`.
-   `-1000 <= nums[i] <= 1000`
-   `1 <= k <= number of distinct elements in nums`.

___

What is the total time complexity of the optimal solution using a hashmap and heap?

A) O(n)

B) O(n log n)

C) O(n log k)

D) O(k log n)

###### ID29

A:: =============================================  
**Answer**: C

The total time complexity is O(n log k) because:
1. Building the frequency map: O(n)
2. Building and maintaining a heap of size k for n elements: O(n log k)
The dominant term is O(n log k), which becomes the final time complexity.

Q:: =============================================  

##### Top K Elements in List

Given an integer array `nums` and an integer `k`, return the `k` most frequent elements within the array.

The test cases are generated such that the answer is always **unique**.

You may return the output in **any order**.

**Example 1:**

```
Input: nums = [1,2,2,3,3,3], k = 2

Output: [2,3]
```

**Example 2:**

```
Input: nums = [7,7], k = 1

Output: [7]
```

**Constraints:**

-   `1 <= nums.length <= 10^4`.
-   `-1000 <= nums[i] <= 1000`
-   `1 <= k <= number of distinct elements in nums`.

___

If k equals the number of distinct elements in the array, what does the problem reduce to?

A) Finding all elements in sorted order

B) Finding all elements in reverse sorted order by frequency

C) Finding the maximum element

D) Finding the minimum element

###### ID30

A:: =============================================  
**Answer**: B

When k equals the number of distinct elements, we need to return all unique elements sorted by their frequency in descending order, effectively returning all elements in reverse sorted order by frequency.

#### Chapter 6 - Encode and Decode Strings - [Blind]

Q:: =============================================  

##### String Encode and Decode

Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example 1:**

```
Input: ["neet","code","love","you"]

Output:["neet","code","love","you"]
```

**Example 2:**

```
Input: ["we","say",":","yes"]

Output: ["we","say",":","yes"]
```

**Constraints:**

-   `0 <= strs.length < 100`
-   `0 <= strs[i].length < 200`
-   `strs[i]` contains only UTF-8 characters.

___

Given the constraint that `strs[i]` can contain any valid ASCII characters, including special ones, which encoding strategy should we use to ensure that our encoded message can be correctly decoded?

A) Separate strings in strs using a special character, such as a comma or a space.

B) Use a length-prefix followed by a special character for each string in strs.

C) Concatenate all the strings in strs directly.

###### ID31

A:: =============================================  
**Answer**: B

If we use a special character to separate the strings, it could be a problem if the string itself contains this special character. If we concatenate the strings directly, we can't distinguish where one string ends and another begins. Therefore, prefixing each string with its length followed by a special character allows us to correctly separate the strings during decoding, even if they contain special characters.

Q:: =============================================  

##### String Encode and Decode

Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example 1:**

```
Input: ["neet","code","love","you"]

Output:["neet","code","love","you"]
```

**Example 2:**

```
Input: ["we","say",":","yes"]

Output: ["we","say",":","yes"]
```

**Constraints:**

-   `0 <= strs.length < 100`
-   `0 <= strs[i].length < 200`
-   `strs[i]` contains only UTF-8 characters.

___

What should the prefix look like to make the encoding efficient?

A) Prefix each string with the length of the entire list strs.

B) Prefix each string with its individual length followed by a delimiter.

C) Prefix each string with the sum of the lengths of all previous strings.

###### ID32

A:: =============================================  
**Answer**: B

Prefixing each string with its own length allows us to know exactly where each string starts and ends in the encoded string, which simplifies the decoding process.

Q:: =============================================  

##### String Encode and Decode

Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example 1:**

```
Input: ["neet","code","love","you"]

Output:["neet","code","love","you"]
```

**Example 2:**

```
Input: ["we","say",":","yes"]

Output: ["we","say",":","yes"]
```

**Constraints:**

-   `0 <= strs.length < 100`
-   `0 <= strs[i].length < 200`
-   `strs[i]` contains only UTF-8 characters.

___

What should be the delimiter between the length prefix and the actual string content?

A) The delimiter can be any character, as it is not important for decoding.

B) The delimiter should be a character that is not allowed in the strings.

C) The delimiter should be a non-integer character.

###### ID33

A:: =============================================  
**Answer**: C

If the delimiter is a number, it could lead to confusion during decoding. Hence, we need to choose a delimiter that cannot be part of the prefix.

Q:: =============================================  

##### String Encode and Decode

Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.

Please implement `encode` and `decode`

**Example 1:**

```
Input: ["neet","code","love","you"]

Output:["neet","code","love","you"]
```

**Example 2:**

```
Input: ["we","say",":","yes"]

Output: ["we","say",":","yes"]
```

**Constraints:**

-   `0 <= strs.length < 100`
-   `0 <= strs[i].length < 200`
-   `strs[i]` contains only UTF-8 characters.

___

We can implement the encode and decode methods using `#` as the delimiter, as follow. What is the time and space complexity of the encode and decode methods? Assume `n` is the total length of the string.


```python
class Codec:
    def encode(self, strs: List[str]) -> str:
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res

    def decode(self, s: str) -> List[str]:
        res, i = [], 0
        while i < len(s):
            j = i
            while s[j] != "#":
                j += 1
            length = int(s[i:j])
            res.append(s[j + 1: j + 1 + length])
            i = j + 1 + length
        return res
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n^2), Space complexity: O(n)

C) Time complexity: O(n log n), Space complexity: O(n)

###### ID34

A:: =============================================  
**Answer**: A

The overall time complexity of the solution is determined by the number of characters in the strings list (strs). We iterate over all characters twice: once when encoding and once when decoding. Therefore, the time complexity is linear. The space complexity is also linear because the encoded string has the same number of characters as the original strings list plus the length of each string and a colon for each string.

#### Chapter 7 - Product of Array Except Self - [Blind]

Q:: =============================================  

##### Products of Array Discluding Self

Given an integer array `nums`, return an array `output` where `output[i]` is the product of all the elements of `nums` except `nums[i]`.

Each product is **guaranteed** to fit in a **32-bit** integer.

Follow-up: Could you solve it in `O(n)` time without using the division operation?

**Example 1:**

```
Input: nums = [1,2,4,6]

Output: [48,24,12,8]
```

**Example 2:**

```
Input: nums = [-1,0,1,2,3]

Output: [0,-6,0,0,0]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-20 <= nums[i] <= 20`

___

What is the naive approach to solving this problem that would NOT meet the O(n) time requirement?

A) Use nested loops to calculate each output element

B) Use a single pass with division

C) Use two separate arrays to track products

D) Sort the array first

###### ID35

A:: =============================================  
**Answer**: A

A naive approach using nested loops would result in O(n^2) time complexity, which violates the problem's requirement of solving the problem in O(n) time. This would involve calculating the product for each element by iterating through the entire array for each position.

Q:: =============================================  

##### Products of Array Discluding Self

Given an integer array `nums`, return an array `output` where `output[i]` is the product of all the elements of `nums` except `nums[i]`.

Each product is **guaranteed** to fit in a **32-bit** integer.

Follow-up: Could you solve it in `O(n)` time without using the division operation?

**Example 1:**

```
Input: nums = [1,2,4,6]

Output: [48,24,12,8]
```

**Example 2:**

```
Input: nums = [-1,0,1,2,3]

Output: [0,-6,0,0,0]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-20 <= nums[i] <= 20`

___

What is the key insight to solving this problem in O(n) time without division?

A) Using a single pass with running product from left to right

B) Sorting the array first

C) Using two separate passes - left-to-right and right-to-left to compute prefix and suffix products

D) Using a stack to track products

###### ID36

A:: =============================================  
**Answer**: C

The optimal solution involves two passes through the array:
1. First pass (left-to-right): Compute prefix products
2. Second pass (right-to-left): Compute suffix products
This allows calculating the product of all elements except the current one in O(n) time and O(1) extra space (not counting the output array).

Q:: =============================================  

##### Products of Array Discluding Self

Given an integer array `nums`, return an array `output` where `output[i]` is the product of all the elements of `nums` except `nums[i]`.

Each product is **guaranteed** to fit in a **32-bit** integer.

Follow-up: Could you solve it in `O(n)` time without using the division operation?

**Example 1:**

```
Input: nums = [1,2,4,6]

Output: [48,24,12,8]
```

**Example 2:**

```
Input: nums = [-1,0,1,2,3]

Output: [0,-6,0,0,0]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-20 <= nums[i] <= 20`

___

What would be the time and space complexity of the two-pass solution?

A) Time: O(n), Space: O(n)

B) Time: O(n), Space: O(1)

C) Time: O(n^2), Space: O(1)

D) Time: O(log n), Space: O(n)

###### ID37

A:: =============================================  
**Answer**: A

The solution requires:
- First pass to compute left-to-right prefix products: O(n)
- Second pass to compute right-to-left suffix products: O(n)
- Space to store the output array: O(n)
Total time complexity is O(n), and space complexity is O(n) to store the output array.

Q:: =============================================  

##### Products of Array Discluding Self

Given an integer array `nums`, return an array `output` where `output[i]` is the product of all the elements of `nums` except `nums[i]`.

Each product is **guaranteed** to fit in a **32-bit** integer.

Follow-up: Could you solve it in `O(n)` time without using the division operation?

**Example 1:**

```
Input: nums = [1,2,4,6]

Output: [48,24,12,8]
```

**Example 2:**

```
Input: nums = [-1,0,1,2,3]

Output: [0,-6,0,0,0]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-20 <= nums[i] <= 20`

___

How do you handle the case of zero in the input array?

A) The solution automatically handles zero by setting appropriate elements to zero

B) You must add a special check for zero

C) Zero always results in all zeros in the output

D) Zero causes the solution to fail

###### ID38

A:: =============================================  
**Answer**: A

In this solution, if a zero is present in the input:
- If there's one zero: The output will be all zeros except for the position of the zero, which will contain the product of all other elements
- If there are multiple zeros: The entire output will be zeros
The two-pass approach naturally handles this scenario without additional complexity.

Q:: =============================================  

##### Products of Array Discluding Self

Given an integer array `nums`, return an array `output` where `output[i]` is the product of all the elements of `nums` except `nums[i]`.

Each product is **guaranteed** to fit in a **32-bit** integer.

Follow-up: Could you solve it in `O(n)` time without using the division operation?

**Example 1:**

```
Input: nums = [1,2,4,6]

Output: [48,24,12,8]
```

**Example 2:**

```
Input: nums = [-1,0,1,2,3]

Output: [0,-6,0,0,0]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-20 <= nums[i] <= 20`

___

What is the maximum possible value in the output array given the constraints?

A) 400

B) 8000

C) 20 \* 20 \* n

D) 20^n

###### ID39

A:: =============================================  
**Answer**: B

Given the constraints:
- Array length is max 1000
- Each element is between -20 and 20
The maximum possible product would be 20 \* 20 = 400
In the worst case, with multiple elements multiplied, the maximum could approach 8000, which still fits in a 32-bit integer.

Q:: =============================================  

##### Products of Array Discluding Self

Given an integer array `nums`, return an array `output` where `output[i]` is the product of all the elements of `nums` except `nums[i]`.

Each product is **guaranteed** to fit in a **32-bit** integer.

Follow-up: Could you solve it in `O(n)` time without using the division operation?

**Example 1:**

```
Input: nums = [1,2,4,6]

Output: [48,24,12,8]
```

**Example 2:**

```
Input: nums = [-1,0,1,2,3]

Output: [0,-6,0,0,0]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-20 <= nums[i] <= 20`

___

Why is division not allowed as a solution approach?

A) Division is computationally expensive

B) To make the problem more challenging

C) To prevent potential division by zero errors

D) To force a more optimal solution that demonstrates understanding of array manipulation

###### ID40

A:: =============================================  
**Answer**: D

The restriction on division is meant to:
1. Prevent a trivial O(n) solution with total product division
2. Test the candidate's ability to manipulate arrays creatively
3. Demonstrate understanding of prefix and suffix product calculations
4. Explore more advanced array processing techniques

Q:: =============================================  

##### Products of Array Discluding Self

Given an integer array `nums`, return an array `output` where `output[i]` is the product of all the elements of `nums` except `nums[i]`.

Each product is **guaranteed** to fit in a **32-bit** integer.

Follow-up: Could you solve it in `O(n)` time without using the division operation?

**Example 1:**

```
Input: nums = [1,2,4,6]

Output: [48,24,12,8]
```

**Example 2:**

```
Input: nums = [-1,0,1,2,3]

Output: [0,-6,0,0,0]
```

**Constraints:**

-   `2 <= nums.length <= 1000`
-   `-20 <= nums[i] <= 20`

___

What data structure allows for the most efficient implementation of this algorithm?

A) Queue

B) Stack

C) Array

D) Linked List

###### ID41

A:: =============================================  
**Answer**: C

An array is the most efficient data structure for this solution because:
- Allows constant-time access
- Can be modified in-place for prefix/suffix products
- Provides O(1) space for intermediate calculations
- Supports the two-pass approach efficiently

#### Chapter 8 - Valid Sudoku

Q:: =============================================  

##### Valid Sudoku

You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:

1.  Each row must contain the digits `1-9` without duplicates.
2.  Each column must contain the digits `1-9` without duplicates.
3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.

Return `true` if the Sudoku board is valid, otherwise return `false`

Note: A board does not need to be full or be solvable to be valid.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true
```

**Example 2:**

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","1",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: false
```

Explanation: There are two 1's in the top-left 3x3 sub-box.

**Constraints:**

-   `board.length == 9`
-   `board[i].length == 9`
-   `board[i][j]` is a digit `1-9` or `'.'`.

___

What is the most efficient data structure to track seen digits in a row, column, or 3x3 box?

A) Array

B) HashMap

C) HashSet

D) LinkedList

###### ID42

A:: =============================================  
**Answer**: C

A HashSet is ideal because:
1. O(1) lookup time to check if a digit exists
2. O(1) insertion time to add new digits
3. Automatically handles duplicates
4. Easy to clear for checking each new row/column/box

Q:: =============================================  

##### Valid Sudoku

You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:

1.  Each row must contain the digits `1-9` without duplicates.
2.  Each column must contain the digits `1-9` without duplicates.
3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.

Return `true` if the Sudoku board is valid, otherwise return `false`

Note: A board does not need to be full or be solvable to be valid.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true
```

**Example 2:**

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","1",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: false
```

Explanation: There are two 1's in the top-left 3x3 sub-box.

**Constraints:**

-   `board.length == 9`
-   `board[i].length == 9`
-   `board[i][j]` is a digit `1-9` or `'.'`.

___

What is the time complexity of validating a single row in the Sudoku board?

A) O(1)

B) O(n)

C) O(n^2)

D) O(9)

###### ID43

A:: =============================================  
**Answer**: B

The time complexity is O(n) where n is the width of the board (9 in this case) because:
1. We need to check each cell in the row exactly once
2. HashSet operations are O(1)
3. Even though the board is always 9x9, we use O(n) to describe the general case

Q:: =============================================  

##### Valid Sudoku

You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:

1.  Each row must contain the digits `1-9` without duplicates.
2.  Each column must contain the digits `1-9` without duplicates.
3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.

Return `true` if the Sudoku board is valid, otherwise return `false`

Note: A board does not need to be full or be solvable to be valid.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true
```

**Example 2:**

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","1",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: false
```

Explanation: There are two 1's in the top-left 3x3 sub-box.

**Constraints:**

-   `board.length == 9`
-   `board[i].length == 9`
-   `board[i][j]` is a digit `1-9` or `'.'`.

___

How can you efficiently determine which 3x3 sub-box a cell belongs to?

A) Using modulo and division operations on indices

B) Using a separate lookup table

C) Using nested loops

D) Using binary search

###### ID44

A:: =============================================  
**Answer**: A

Using modulo and division operations is most efficient because:
1. box_row = row / 3 (integer division)
2. box_col = col / 3 (integer division)
3. This gives a unique identifier for each 3x3 box in O(1) time
4. No additional space or lookup tables needed

Q:: =============================================  

##### Valid Sudoku

You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:

1.  Each row must contain the digits `1-9` without duplicates.
2.  Each column must contain the digits `1-9` without duplicates.
3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.

Return `true` if the Sudoku board is valid, otherwise return `false`

Note: A board does not need to be full or be solvable to be valid.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true
```

**Example 2:**

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","1",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: false
```

Explanation: There are two 1's in the top-left 3x3 sub-box.

**Constraints:**

-   `board.length == 9`
-   `board[i].length == 9`
-   `board[i][j]` is a digit `1-9` or `'.'`.

___

What is the total time complexity for validating the entire Sudoku board?

A) O(1)

B) O(n)

C) O(n^2)

D) O(n^3)

###### ID45

A:: =============================================  
**Answer**: C

The total time complexity is O(n^2) because:
1. We need to visit each cell once: 9 \* 9 = 81 visits
2. Each visit involves O(1) operations with HashSet
3. Even though the board size is fixed at 9x9, we use O(n^2) to describe the general case
4. The linear scans for rows, columns, and boxes can all be done in one pass

Q:: =============================================  

##### Valid Sudoku

You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:

1.  Each row must contain the digits `1-9` without duplicates.
2.  Each column must contain the digits `1-9` without duplicates.
3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.

Return `true` if the Sudoku board is valid, otherwise return `false`

Note: A board does not need to be full or be solvable to be valid.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true
```

**Example 2:**

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","1",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: false
```

Explanation: There are two 1's in the top-left 3x3 sub-box.

**Constraints:**

-   `board.length == 9`
-   `board[i].length == 9`
-   `board[i][j]` is a digit `1-9` or `'.'`.

___

What is the space complexity of the optimal solution?

A) O(1)

B) O(n)

C) O(n^2)

D) O(n^3)

###### ID46

A:: =============================================  
**Answer**: A

The space complexity is O(1) because:
1. We only need three HashSets (for row, column, and box checking)
2. Each HashSet stores at most 9 digits
3. The board size is fixed at 9x9
4. No additional space scaling with input size is needed

Q:: =============================================  

##### Valid Sudoku

You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:

1.  Each row must contain the digits `1-9` without duplicates.
2.  Each column must contain the digits `1-9` without duplicates.
3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.

Return `true` if the Sudoku board is valid, otherwise return `false`

Note: A board does not need to be full or be solvable to be valid.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true
```

**Example 2:**

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","1",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: false
```

Explanation: There are two 1's in the top-left 3x3 sub-box.

**Constraints:**

-   `board.length == 9`
-   `board[i].length == 9`
-   `board[i][j]` is a digit `1-9` or `'.'`.

___

What is a potential optimization when checking for duplicates in rows, columns, and boxes?

A) Check each separately with three passes

B) Use three HashSets and check all in one pass

C) Sort the board first

D) Use a Queue to track elements

###### ID47

A:: =============================================  
**Answer**: B

Using three HashSets and checking all in one pass is optimal because:
1. Only requires one traversal of the board
2. Can validate row, column, and box constraints simultaneously
3. Maintains O(1) space complexity
4. Reduces the number of times each cell is visited

Q:: =============================================  

##### Valid Sudoku

You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:

1.  Each row must contain the digits `1-9` without duplicates.
2.  Each column must contain the digits `1-9` without duplicates.
3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.

Return `true` if the Sudoku board is valid, otherwise return `false`

Note: A board does not need to be full or be solvable to be valid.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true
```

**Example 2:**

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","1",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: false
```

Explanation: There are two 1's in the top-left 3x3 sub-box.

**Constraints:**

-   `board.length == 9`
-   `board[i].length == 9`
-   `board[i][j]` is a digit `1-9` or `'.'`.

___

How should empty cells (marked as '.') be handled?

A) Treat them as zeros

B) Skip them during validation

C) Replace them with valid numbers

D) Mark them as invalid

###### ID48

A:: =============================================  
**Answer**: B

Empty cells should be skipped during validation because:
1. The problem states a board doesn't need to be full to be valid
2. Only filled cells need to be checked for duplicates
3. Empty cells don't affect the validity of the current board state
4. This matches the requirements that we're only checking validity, not solvability

Q:: =============================================  

##### Valid Sudoku

You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:

1.  Each row must contain the digits `1-9` without duplicates.
2.  Each column must contain the digits `1-9` without duplicates.
3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.

Return `true` if the Sudoku board is valid, otherwise return `false`

Note: A board does not need to be full or be solvable to be valid.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","8",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: true
```

**Example 2:**

```
Input: board = 
[["1","2",".",".","3",".",".",".","."],
 ["4",".",".","5",".",".",".",".","."],
 [".","9","1",".",".",".",".",".","3"],
 ["5",".",".",".","6",".",".",".","4"],
 [".",".",".","8",".","3",".",".","5"],
 ["7",".",".",".","2",".",".",".","6"],
 [".",".",".",".",".",".","2",".","."],
 [".",".",".","4","1","9",".",".","8"],
 [".",".",".",".","8",".",".","7","9"]]

Output: false
```

Explanation: There are two 1's in the top-left 3x3 sub-box.

**Constraints:**

-   `board.length == 9`
-   `board[i].length == 9`
-   `board[i][j]` is a digit `1-9` or `'.'`.

___

What is the key difference between validating a Sudoku board and solving a Sudoku puzzle?

A) Validation requires checking for completeness

B) Validation only checks current state without considering future moves

C) Validation requires backtracking

D) Validation needs to try different numbers

###### ID49

A:: =============================================  
**Answer**: B

Validation only checks the current state because:
1. We only need to verify the existing numbers follow Sudoku rules
2. No need to consider if the puzzle is solvable
3. No need for backtracking or trying different combinations
4. Much simpler than solving, which would require exploring possible solutions

#### Chapter 9 - Longest Consecutive Sequence - [Blind]

Q:: =============================================  

##### Longest Consecutive Sequence

Given an array of integers `nums`, return _the length_ of the longest consecutive sequence of elements.

A _consecutive sequence_ is a sequence of elements in which each element is exactly `1` greater than the previous element.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [2,20,4,10,3,4,5]

Output: 4
```

Explanation: The longest consecutive sequence is `[2, 3, 4, 5]`.

**Example 2:**

```
Input: nums = [0,3,2,5,4,6,1,1]

Output: 7
```

**Constraints:**

-   `0 <= nums.length <= 1000`
-   `-10^9 <= nums[i] <= 10^9`

___

For a given array of integers, what is the time complexity of finding the length of the longest consecutive sequence using sorting?

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID50

A:: =============================================  
**Answer**: B

Sorting an array generally takes O(n log n) time. Once the array is sorted, you could iterate through the array once to find the longest consecutive sequence, which would take O(n) time. However, the dominating factor is the sorting time complexity, thus the overall time complexity is O(n log n).

Q:: =============================================  

##### Longest Consecutive Sequence

Given an array of integers `nums`, return _the length_ of the longest consecutive sequence of elements.

A _consecutive sequence_ is a sequence of elements in which each element is exactly `1` greater than the previous element.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [2,20,4,10,3,4,5]

Output: 4
```

Explanation: The longest consecutive sequence is `[2, 3, 4, 5]`.

**Example 2:**

```
Input: nums = [0,3,2,5,4,6,1,1]

Output: 7
```

**Constraints:**

-   `0 <= nums.length <= 1000`
-   `-10^9 <= nums[i] <= 10^9`

___

Suppose we are counting the length of a sequence starting at an arbitrary value, say `n = 1.` To extend this sequence, we need to efficiently check for the existence of the next integer `(n + 1)`, regardless of its index in the original array. Which data structure would best serve this purpose?

A) Priority Queue

B) HashSet

C) Binary Search Tree

D) Array

###### ID51

A:: =============================================  
**Answer**: B

A HashSet can be used to efficiently check the existence of elements in O(1) average time complexity. When extending a sequence, this property is essential, allowing us to determine if the next integer (n + 1) exists in the original array, regardless of its position.

Q:: =============================================  

##### Longest Consecutive Sequence

Given an array of integers `nums`, return _the length_ of the longest consecutive sequence of elements.

A _consecutive sequence_ is a sequence of elements in which each element is exactly `1` greater than the previous element.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [2,20,4,10,3,4,5]

Output: 4
```

Explanation: The longest consecutive sequence is `[2, 3, 4, 5]`.

**Example 2:**

```
Input: nums = [0,3,2,5,4,6,1,1]

Output: 7
```

**Constraints:**

-   `0 <= nums.length <= 1000`
-   `-10^9 <= nums[i] <= 10^9`

___

Consider the array `[1, 2, 3, 4, 5, 6]`. If we naively iterate through this array, treating each element `n` as the potential start of a sequence, we would check for the existence of each subsequent number `n + 1`. What would be the time complexity of such an approach?

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID52

A:: =============================================  
**Answer**: C

For every element in the array, except for 6, the follow-up element n + 1 does exist. So for each element, in the worst case, we would iterate n - 1 times to build each sequence, resulting in a time complexity of O(n^2).

Q:: =============================================  

##### Longest Consecutive Sequence

Given an array of integers `nums`, return _the length_ of the longest consecutive sequence of elements.

A _consecutive sequence_ is a sequence of elements in which each element is exactly `1` greater than the previous element.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [2,20,4,10,3,4,5]

Output: 4
```

Explanation: The longest consecutive sequence is `[2, 3, 4, 5]`.

**Example 2:**

```
Input: nums = [0,3,2,5,4,6,1,1]

Output: 7
```

**Constraints:**

-   `0 <= nums.length <= 1000`
-   `-10^9 <= nums[i] <= 10^9`

___

Consider the array `[100, 4, 200, 1, 3, 2]`. This array contains two sequences: `[1, 2, 3, 4]` and `[100, 200]`. What common trait do the starting elements `1` and `100` share, which suggests they are the beginning of these sequences?

A) They are the smallest numbers in their respective sequences.

B) The element (n - 1) does not exist in the array.

C) The element (n + 1) does exist in the array.

D) They are the largest numbers in their respective sequences.

###### ID53

A:: =============================================  
**Answer**: B

The key observation is that for any number 'n' to be the start of a sequence, the number (n - 1) must not exist in the array. This is because if (n-1) exists, 'n' would be part of a sequence starting at least from (n-1). In this case, for '1' and '100', neither '0' nor '99' exist in the array, indicating that '1' and '100' can indeed be the starting points of their sequences.

Q:: =============================================  

##### Longest Consecutive Sequence

Given an array of integers `nums`, return _the length_ of the longest consecutive sequence of elements.

A _consecutive sequence_ is a sequence of elements in which each element is exactly `1` greater than the previous element.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [2,20,4,10,3,4,5]

Output: 4
```

Explanation: The longest consecutive sequence is `[2, 3, 4, 5]`.

**Example 2:**

```
Input: nums = [0,3,2,5,4,6,1,1]

Output: 7
```

**Constraints:**

-   `0 <= nums.length <= 1000`
-   `-10^9 <= nums[i] <= 10^9`

___

Knowing that an element 'n' is the start of a sequence if (n - 1) does not exist in the array, how could we efficiently solve this problem using a hashset?

A) Add all elements to the hashset. Then, for each element 'n', if (n - 1) is not in the hashset, check and count the longest sequence starting from 'n'.

B) Add all elements to the hashset. Then, for each element 'n', if (n + 1) is in the hashset, check and count the longest sequence starting from 'n'.

###### ID54

A:: =============================================  
**Answer**: A

We then iterate through each element 'n' and if (n - 1) is not in the hashset, we check for the longest sequence starting from 'n'. This is because if (n-1) does not exist, 'n' must be the starting point of a sequence. We then check for the existence of (n + 1), (n + 2), and so on in the hashset, and count the length of the sequence. This approach ensures that we don't repeatedly check the same sequence and keeps the time complexity to O(n).

Q:: =============================================  

##### Longest Consecutive Sequence

Given an array of integers `nums`, return _the length_ of the longest consecutive sequence of elements.

A _consecutive sequence_ is a sequence of elements in which each element is exactly `1` greater than the previous element.

You must write an algorithm that runs in `O(n)` time.

**Example 1:**

```
Input: nums = [2,20,4,10,3,4,5]

Output: 4
```

Explanation: The longest consecutive sequence is `[2, 3, 4, 5]`.

**Example 2:**

```
Input: nums = [0,3,2,5,4,6,1,1]

Output: 7
```

**Constraints:**

-   `0 <= nums.length <= 1000`
-   `-10^9 <= nums[i] <= 10^9`

___

What is the time and space complexity of the optimal solution using a HashSet and avoiding unnecessary checks?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID55

A:: =============================================  
**Answer**: A

The HashSet solution has a time complexity of O(n) because you need to iterate through the array twice (once for building the HashSet and once for checking the sequences). The space complexity is also O(n) because, in the worst case, you might need to store all n elements in the HashSet.


### Part II - Two Pointers

#### Chapter 1 - Valid Palindrome - [Blind]

Q:: =============================================  

##### Is Palindrome

Given a string `s`, return `true` if it is a **palindrome**, otherwise return `false`.

A **palindrome** is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.

**Example 1:**

```
Input: s = "Was it a car or a cat I saw?"

Output: true
```

Explanation: After considering only alphanumerical characters we have "wasitacaroracatisaw", which is a palindrome.

**Example 2:**

```
Input: s = "tab a cat"

Output: false
```

Explanation: "tabacat" is not a palindrome.

**Constraints:**

-   `1 <= s.length <= 1000`
-   `s` is made up of only printable ASCII characters.

___

Given a string, what is a crucial step in the initial preprocessing to determine whether it is a palindrome?

A) Reverse the string.

B) Convert the string to lowercase.

C) Check if the string is empty.

D) Split the string into words.

###### ID56

A:: =============================================  
**Answer**: B

A crucial step to check if a string is a palindrome is to convert it to lowercase. This is because palindromes are case-insensitive. However, it's important to note that removing non-alphanumeric characters is another critical preprocessing step not mentioned in this particular question.

Q:: =============================================  

##### Is Palindrome

Given a string `s`, return `true` if it is a **palindrome**, otherwise return `false`.

A **palindrome** is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.

**Example 1:**

```
Input: s = "Was it a car or a cat I saw?"

Output: true
```

Explanation: After considering only alphanumerical characters we have "wasitacaroracatisaw", which is a palindrome.

**Example 2:**

```
Input: s = "tab a cat"

Output: false
```

Explanation: "tabacat" is not a palindrome.

**Constraints:**

-   `1 <= s.length <= 1000`
-   `s` is made up of only printable ASCII characters.

___

After converting the string to lowercase, what should be the next step?

A) Reverse the string.

B) Check if the string is empty.

C) Remove all non-alphanumeric characters.

D) Convert the string to uppercase.

###### ID57

A:: =============================================  
**Answer**: C

The next step is to remove all non-alphanumeric characters. This is because palindromes only consider alphanumeric characters.

Q:: =============================================  

##### Is Palindrome

Given a string `s`, return `true` if it is a **palindrome**, otherwise return `false`.

A **palindrome** is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.

**Example 1:**

```
Input: s = "Was it a car or a cat I saw?"

Output: true
```

Explanation: After considering only alphanumerical characters we have "wasitacaroracatisaw", which is a palindrome.

**Example 2:**

```
Input: s = "tab a cat"

Output: false
```

Explanation: "tabacat" is not a palindrome.

**Constraints:**

-   `1 <= s.length <= 1000`
-   `s` is made up of only printable ASCII characters.

___

Once the string has been converted to lowercase and all non-alphanumeric characters have been removed, what is the final step to determine if it's a palindrome?

A) Convert the string to uppercase.

B) Check if the string is equal to its reverse.

C) Check if the string is empty.

D) Split the string into words.

###### ID58

A:: =============================================  
**Answer**: B

The final step to check if a string is a palindrome is to compare it to its reversed version. If they are the same, then the string is a palindrome.

Q:: =============================================  

##### Is Palindrome

Given a string `s`, return `true` if it is a **palindrome**, otherwise return `false`.

A **palindrome** is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.

**Example 1:**

```
Input: s = "Was it a car or a cat I saw?"

Output: true
```

Explanation: After considering only alphanumerical characters we have "wasitacaroracatisaw", which is a palindrome.

**Example 2:**

```
Input: s = "tab a cat"

Output: false
```

Explanation: "tabacat" is not a palindrome.

**Constraints:**

-   `1 <= s.length <= 1000`
-   `s` is made up of only printable ASCII characters.

___

What is the time and space complexity of the approach where we create a new reversed string to compare?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID59

A:: =============================================  
**Answer**: A

The time complexity is O(n) because all operations (lowercase conversion, removing non-alphanumeric characters, and reversing the string) take linear time. The 'n' here is the length of the string. The space complexity is also O(n) because we are creating a new string for the reversed version, which can be as long as the input string.

Q:: =============================================  

##### Is Palindrome

Given a string `s`, return `true` if it is a **palindrome**, otherwise return `false`.

A **palindrome** is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.

**Example 1:**

```
Input: s = "Was it a car or a cat I saw?"

Output: true
```

Explanation: After considering only alphanumerical characters we have "wasitacaroracatisaw", which is a palindrome.

**Example 2:**

```
Input: s = "tab a cat"

Output: false
```

Explanation: "tabacat" is not a palindrome.

**Constraints:**

-   `1 <= s.length <= 1000`
-   `s` is made up of only printable ASCII characters.

___

Is there a way to check if a string is a palindrome without creating a new string for the reversed version?

A) No, it's not possible.

B) Yes, by using two pointers.

C) Yes, by sorting the string.

D) Yes, by using a stack.

###### ID60

A:: =============================================  
**Answer**: B

Yes, it is possible. You can use two pointers: one starting from the beginning of the string and the other from the end. If the characters at both pointers are equal, we increment the left pointer and decrement the right pointer. If they are not equal, then the string is not a palindrome. This approach avoids creating a new string for the reversed version, thus saving space.

Q:: =============================================  

##### Is Palindrome

Given a string `s`, return `true` if it is a **palindrome**, otherwise return `false`.

A **palindrome** is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.

**Example 1:**

```
Input: s = "Was it a car or a cat I saw?"

Output: true
```

Explanation: After considering only alphanumerical characters we have "wasitacaroracatisaw", which is a palindrome.

**Example 2:**

```
Input: s = "tab a cat"

Output: false
```

Explanation: "tabacat" is not a palindrome.

**Constraints:**

-   `1 <= s.length <= 1000`
-   `s` is made up of only printable ASCII characters.

___

What are the time and space complexities of the two-pointer approach to check if a string is a palindrome?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID61

A:: =============================================  
**Answer**: D

The time complexity is O(n) because in the worst case, we would have to compare every character in the string with its counterpart from the end. Here, 'n' is the length of the string. This is still linear time complexity. The space complexity is O(1) because no extra space proportional to the size of the input is used. The two pointers used do not scale with the input size.

#### Chapter 2 - Two Sum II Input Array Is Sorted

Q:: =============================================  

##### Two Integer Sum II

Given an array of integers `numbers` that is sorted in **non-decreasing order**.

Return the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.

There will always be **exactly one valid solution**.

Your solution must use `O(1)` additional space.

**Example 1:**

```
Input: numbers = [1,2,3,4], target = 3

Output: [1,2]
```

Explanation:  
The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.

**Constraints:**

-   `2 <= numbers.length <= 1000`
-   `-1000 <= numbers[i] <= 1000`
-   `-1000 <= target <= 1000`

___

Why is the two-pointer technique particularly effective for this problem compared to other approaches?

A) Because it's always faster than any other solution

B) Because the array is sorted and we need O(1) space

C) Because we need to find exactly two numbers

D) Because we need to handle negative numbers

###### ID62

A:: =============================================  
**Answer**: B

The two-pointer technique is ideal because:
1. The array being sorted allows us to make intelligent decisions about which pointer to move
2. It requires only O(1) additional space as specified in requirements
3. It achieves O(n) time complexity
4. We can systematically explore all possible pairs without using extra space

Q:: =============================================  

##### Two Integer Sum II

Given an array of integers `numbers` that is sorted in **non-decreasing order**.

Return the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.

There will always be **exactly one valid solution**.

Your solution must use `O(1)` additional space.

**Example 1:**

```
Input: numbers = [1,2,3,4], target = 3

Output: [1,2]
```

Explanation:  
The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.

**Constraints:**

-   `2 <= numbers.length <= 1000`
-   `-1000 <= numbers[i] <= 1000`
-   `-1000 <= target <= 1000`

___

What should be the initial positions of the two pointers for optimal solution?

A) Both at start of array

B) Both at end of array

C) One at start, one at end

D) One at start, one in middle

###### ID63

A:: =============================================  
**Answer**: C

Starting with one pointer at each end is optimal because:
1. We can use the sorted property to move pointers inward
2. If sum is too large, we need a smaller number (move right pointer left)
3. If sum is too small, we need a larger number (move left pointer right)
4. This ensures we don't miss any possible combinations

Q:: =============================================  

##### Two Integer Sum II

Given an array of integers `numbers` that is sorted in **non-decreasing order**.

Return the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.

There will always be **exactly one valid solution**.

Your solution must use `O(1)` additional space.

**Example 1:**

```
Input: numbers = [1,2,3,4], target = 3

Output: [1,2]
```

Explanation:  
The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.

**Constraints:**

-   `2 <= numbers.length <= 1000`
-   `-1000 <= numbers[i] <= 1000`
-   `-1000 <= target <= 1000`

___

Given a sorted array [2,7,11,15] and target=9, which pointer should move after checking sum of elements at initial positions (2+15=17)?

A) Left pointer moves right

B) Right pointer moves left

C) Both pointers move

D) Neither pointer moves

###### ID64

A:: =============================================  
**Answer**: B

The right pointer should move left because:
1. Current sum (17) is greater than target (9)
2. Array is sorted in non-decreasing order
3. Moving right pointer left will decrease the sum
4. Moving left pointer right would only increase the sum, taking us further from target

Q:: =============================================  

##### Two Integer Sum II

Given an array of integers `numbers` that is sorted in **non-decreasing order**.

Return the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.

There will always be **exactly one valid solution**.

Your solution must use `O(1)` additional space.

**Example 1:**

```
Input: numbers = [1,2,3,4], target = 3

Output: [1,2]
```

Explanation:  
The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.

**Constraints:**

-   `2 <= numbers.length <= 1000`
-   `-1000 <= numbers[i] <= 1000`
-   `-1000 <= target <= 1000`

___

What is the time complexity of the optimal two-pointer solution?

A) O(log n)

B) O(n)

C) O(n log n)

D) O(n^2)

###### ID65

A:: =============================================  
**Answer**: B

The time complexity is O(n) because:
1. Each element is visited at most once
2. Both pointers move inward, never going back
3. In worst case, we might need to traverse entire array
4. No nested loops or additional operations needed

Q:: =============================================  

##### Two Integer Sum II

Given an array of integers `numbers` that is sorted in **non-decreasing order**.

Return the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.

There will always be **exactly one valid solution**.

Your solution must use `O(1)` additional space.

**Example 1:**

```
Input: numbers = [1,2,3,4], target = 3

Output: [1,2]
```

Explanation:  
The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.

**Constraints:**

-   `2 <= numbers.length <= 1000`
-   `-1000 <= numbers[i] <= 1000`
-   `-1000 <= target <= 1000`

___

Why can we guarantee that we won't miss the solution using the two-pointer approach?

A) Because we check every possible combination

B) Because the array is sorted and we systematically eliminate impossible combinations

C) Because there's always exactly one solution

D) Because we use both pointers simultaneously

###### ID66

A:: =============================================  
**Answer**: B

We won't miss the solution because:
1. The array is sorted, so moving pointers has predictable effects on sum
2. When sum is too large, all combinations with right pointer's current position are too large
3. When sum is too small, all combinations with left pointer's current position are too small
4. We systematically eliminate impossible combinations while maintaining completeness

Q:: =============================================  

##### Two Integer Sum II

Given an array of integers `numbers` that is sorted in **non-decreasing order**.

Return the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.

There will always be **exactly one valid solution**.

Your solution must use `O(1)` additional space.

**Example 1:**

```
Input: numbers = [1,2,3,4], target = 3

Output: [1,2]
```

Explanation:  
The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.

**Constraints:**

-   `2 <= numbers.length <= 1000`
-   `-1000 <= numbers[i] <= 1000`
-   `-1000 <= target <= 1000`

___

What is the advantage of having the array sorted in non-decreasing order versus strictly increasing order?

A) It allows for duplicate elements

B) It makes the solution faster

C) It requires less space

D) There is no significant advantage

###### ID67

A:: =============================================  
**Answer**: A

Non-decreasing order is advantageous because:
1. It allows for duplicate elements (equal adjacent values)
2. This matches real-world scenarios where numbers might repeat
3. The solution works the same way for both cases
4. It's more general than strictly increasing order

Q:: =============================================  

##### Two Integer Sum II

Given an array of integers `numbers` that is sorted in **non-decreasing order**.

Return the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.

There will always be **exactly one valid solution**.

Your solution must use `O(1)` additional space.

**Example 1:**

```
Input: numbers = [1,2,3,4], target = 3

Output: [1,2]
```

Explanation:  
The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.

**Constraints:**

-   `2 <= numbers.length <= 1000`
-   `-1000 <= numbers[i] <= 1000`
-   `-1000 <= target <= 1000`

___

Why is binary search not the optimal approach for this problem despite the array being sorted?

A) Because it would require O(n log n) time

B) Because it would require O(n) space

C) Because it wouldn't handle negative numbers

D) Because two pointers is simpler and equally efficient

###### ID68

A:: =============================================  
**Answer**: A

Binary search is not optimal because:
1. We'd need to binary search for each element: O(n log n) time
2. Two pointers achieves O(n) time complexity
3. Two pointers uses O(1) space as required
4. Two pointers is both simpler and more efficient

Q:: =============================================  

##### Two Integer Sum II

Given an array of integers `numbers` that is sorted in **non-decreasing order**.

Return the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.

There will always be **exactly one valid solution**.

Your solution must use `O(1)` additional space.

**Example 1:**

```
Input: numbers = [1,2,3,4], target = 3

Output: [1,2]
```

Explanation:  
The sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.

**Constraints:**

-   `2 <= numbers.length <= 1000`
-   `-1000 <= numbers[i] <= 1000`
-   `-1000 <= target <= 1000`

___

What is the significance of the constraint that indices must be 1-indexed in the returned result?

A) It affects the algorithm's logic

B) It only affects the final returned values

C) It requires additional space

D) It makes the problem more complex

###### ID69

A:: =============================================  
**Answer**: B

The 1-indexed requirement:
1. Only affects how we return the final answer
2. Doesn't change the core algorithm logic
3. Can be handled by adding 1 to found indices
4. Is just a presentation detail, not a computational concern

#### Chapter 3 - 3Sum - [Blind]

Q:: =============================================  

##### Three Integer Sum

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` where `nums[i] + nums[j] + nums[k] == 0`, and the indices `i`, `j` and `k` are all distinct.

The output should _not_ contain any duplicate triplets. You may return the output and the triplets in **any order**.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]

Output: [[-1,-1,2],[-1,0,1]]
```

Explanation:  
`nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.`  
`nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.`  
`nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.`  
The distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.

**Example 2:**

```
Input: nums = [0,1,1]

Output: []
```

Explanation: The only possible triplet does not sum up to 0.

**Example 3:**

```
Input: nums = [0,0,0]

Output: [[0,0,0]]
```

Explanation: The only possible triplet sums up to 0.

**Constraints:**

-   `3 <= nums.length <= 1000`
-   `-10^5 <= nums[i] <= 10^5`

___

What is a brute-force approach to solving this problem and what is the time complexity of this approach?

A) Iterate through all possible combinations of three elements, O(n^3) time complexity

B) Iterate through all elements, creating pair sums in a hash table, O(n^2) time complexity

C) Sort the array and apply binary search for each element, O(n^2 log n) time complexity

###### ID70

A:: =============================================  
**Answer**: A

The brute force approach would be to iterate through all possible triplets in the list and check if their sum is equal to zero. This would involve three nested loops and thus would have a time complexity of O(n^3).

Q:: =============================================  

##### Three Integer Sum

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` where `nums[i] + nums[j] + nums[k] == 0`, and the indices `i`, `j` and `k` are all distinct.

The output should _not_ contain any duplicate triplets. You may return the output and the triplets in **any order**.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]

Output: [[-1,-1,2],[-1,0,1]]
```

Explanation:  
`nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.`  
`nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.`  
`nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.`  
The distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.

**Example 2:**

```
Input: nums = [0,1,1]

Output: []
```

Explanation: The only possible triplet does not sum up to 0.

**Example 3:**

```
Input: nums = [0,0,0]

Output: [[0,0,0]]
```

Explanation: The only possible triplet sums up to 0.

**Constraints:**

-   `3 <= nums.length <= 1000`
-   `-10^5 <= nums[i] <= 10^5`

___

How can we find the optimal solution by using sorting?

A) Sort the array and use two pointers, decreasing the time complexity to O(n^2)

B) Sort the array and use binary search, decreasing the time complexity to O(n^2 log n)

C) Sorting cannot help in optimizing this problem

###### ID71

A:: =============================================  
**Answer**: A

By sorting the array, we can iterate through the array once and then use a two-pointer approach for each iteration. The two pointers can move towards each other until they meet, checking if the sum of the elements at the pointers equals the negative of the current element. This reduces the time complexity to O(n^2). A binary search approach will also work, but is less efficient.

Q:: =============================================  

##### Three Integer Sum

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` where `nums[i] + nums[j] + nums[k] == 0`, and the indices `i`, `j` and `k` are all distinct.

The output should _not_ contain any duplicate triplets. You may return the output and the triplets in **any order**.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]

Output: [[-1,-1,2],[-1,0,1]]
```

Explanation:  
`nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.`  
`nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.`  
`nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.`  
The distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.

**Example 2:**

```
Input: nums = [0,1,1]

Output: []
```

Explanation: The only possible triplet does not sum up to 0.

**Example 3:**

```
Input: nums = [0,0,0]

Output: [[0,0,0]]
```

Explanation: The only possible triplet sums up to 0.

**Constraints:**

-   `3 <= nums.length <= 1000`
-   `-10^5 <= nums[i] <= 10^5`

___

How can we ensure that our solution does not contain duplicate triplets?

A) By checking if a triplet has already been added to a hash set

B) By skipping over duplicate elements in the sorted array

C) Both A and B

###### ID72

A:: =============================================  
**Answer**: C

Both methods can be used to avoid duplicate triplets. We can check if a triplet is already in our solution before adding it, or we can skip over duplicate elements in our sorted array, since any triplet containing these duplicates would have already been found.

Q:: =============================================  

##### Three Integer Sum

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` where `nums[i] + nums[j] + nums[k] == 0`, and the indices `i`, `j` and `k` are all distinct.

The output should _not_ contain any duplicate triplets. You may return the output and the triplets in **any order**.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]

Output: [[-1,-1,2],[-1,0,1]]
```

Explanation:  
`nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.`  
`nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.`  
`nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.`  
The distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.

**Example 2:**

```
Input: nums = [0,1,1]

Output: []
```

Explanation: The only possible triplet does not sum up to 0.

**Example 3:**

```
Input: nums = [0,0,0]

Output: [[0,0,0]]
```

Explanation: The only possible triplet sums up to 0.

**Constraints:**

-   `3 <= nums.length <= 1000`
-   `-10^5 <= nums[i] <= 10^5`

___

How does the two-pointer approach help in eliminating duplicates in the output?

A) It doesn't, duplicates must be handled separately

B) By skipping over duplicate elements in the sorted array after finding a valid triplet, and also when choosing the first number in the triplet

C) By checking if the current triplet is already in the output before adding it

###### ID73

A:: =============================================  
**Answer**: B

When we find a valid triplet, we increment the left pointer until we find a new value. This ensures that we do not add the same triplet multiple times when the array contains duplicates. Additionally, when choosing the first number for our triplet, if this number is the same as the previous number, we can skip it. This is because any valid triplets including this number would have already been found in the previous iteration. These steps effectively eliminate duplicate solutions in the final result set.

Q:: =============================================  

##### Three Integer Sum

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` where `nums[i] + nums[j] + nums[k] == 0`, and the indices `i`, `j` and `k` are all distinct.

The output should _not_ contain any duplicate triplets. You may return the output and the triplets in **any order**.

**Example 1:**

```
Input: nums = [-1,0,1,2,-1,-4]

Output: [[-1,-1,2],[-1,0,1]]
```

Explanation:  
`nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.`  
`nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.`  
`nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.`  
The distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.

**Example 2:**

```
Input: nums = [0,1,1]

Output: []
```

Explanation: The only possible triplet does not sum up to 0.

**Example 3:**

```
Input: nums = [0,0,0]

Output: [[0,0,0]]
```

Explanation: The only possible triplet sums up to 0.

**Constraints:**

-   `3 <= nums.length <= 1000`
-   `-10^5 <= nums[i] <= 10^5`

___

Given the optimized solution using sorting and a two-pointer approach, what is the overall time and space complexity?

```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        
        for i, a in enumerate(nums):
            if i > 0 and a == nums[i - 1]:
                # We already used nums[i] as the 
                # first element, so skip it
                continue

            # Use two pointers on the remaining
            # sorted subarray to solve a + b + c = 0
            l, r = i + 1, len(nums) - 1
            while l < r:
                threeSum = a + nums[l] + nums[r]
                if threeSum > 0:
                    r -= 1
                elif threeSum < 0:
                    l += 1
                else:
                    # Solution found
                    res.append([a, nums[l], nums[r]])
                    l += 1
                    while nums[l] == nums[l - 1] and l < r:
                        # Eliminate duplicates by incrementing 
                        # left ptr until new nums[l] is found
                        l += 1
        return res
```

A) Time complexity: O(n^2), Space complexity: O(1)

B) Time complexity: O(n^2), Space complexity: O(n)

C) Time complexity: O(n log n), Space complexity: O(n)

###### ID74

A:: =============================================  
**Answer**: A

The time complexity is O(n^2) because we iterate through the array once (which is O(n)), and for each iteration, we potentially go through the rest of the array using the two-pointer approach (which is also O(n)), thus resulting in O(n^2). The space complexity is O(1) since we aren't using additional space, other than the output.

#### Chapter 4 - Container With Most Water - [Blind]

Q:: =============================================  

##### Max Water Container

You are given an integer array `heights` where `heights[i]` represents the height of the ithi^{th}ith bar.

You may choose any two bars to form a container. Return the _maximum_ amount of water a container can store.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public)

```
Input: height = [1,7,2,5,4,7,3,6]

Output: 36
```

**Example 2:**

```
Input: height = [2,2,2]

Output: 4
```

**Constraints:**

-   `2 <= height.length <= 1000`
-   `0 <= height[i] <= 1000`

___

The problem is about finding two lines that together with the x-axis form a container such that the container contains the most water. Which of the following is the key factor that determines the amount of water a container can hold?

A) The height of the shortest line

B) The height of the tallest line

C) The distance between the two lines

D) Both A and C

###### ID75

A:: =============================================  
**Answer**: D

The amount of water a container can hold is determined by the height of the shortest line (since water will overflow from the shorter line) and the distance between the two lines (since a wider container can hold more water).

Q:: =============================================  

##### Max Water Container

You are given an integer array `heights` where `heights[i]` represents the height of the ithi^{th}ith bar.

You may choose any two bars to form a container. Return the _maximum_ amount of water a container can store.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public)

```
Input: height = [1,7,2,5,4,7,3,6]

Output: 36
```

**Example 2:**

```
Input: height = [2,2,2]

Output: 4
```

**Constraints:**

-   `2 <= height.length <= 1000`
-   `0 <= height[i] <= 1000`

___

Consider a brute-force solution where you calculate the area for all possible pairs of lines. What would be the time complexity of such an approach?

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(2^n)

###### ID76

A:: =============================================  
**Answer**: C

In a brute-force solution, you would have two nested loops to calculate the area for all pairs of lines. There are n\*(n-1)/2 unique pairs, so the time complexity is O(n^2).

Q:: =============================================  

##### Max Water Container

You are given an integer array `heights` where `heights[i]` represents the height of the ithi^{th}ith bar.

You may choose any two bars to form a container. Return the _maximum_ amount of water a container can store.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public)

```
Input: height = [1,7,2,5,4,7,3,6]

Output: 36
```

**Example 2:**

```
Input: height = [2,2,2]

Output: 4
```

**Constraints:**

-   `2 <= height.length <= 1000`
-   `0 <= height[i] <= 1000`

___

When considering the parameters that affect the amount of water a container can hold, we know that the distance between the two lines is important. Given this, where should we initially place the two pointers in order to maximize the chance of finding the largest possible area?

A) In the middle of the array

B) At the shortest and tallest lines

C) At the two ends of the array

D) At random positions in the array

###### ID77

A:: =============================================  
**Answer**: C

To maximize the initial area, we should start with the widest possible container, by placing the two pointers at the two ends of the array. This allows us to be greedy and maximize the distance between the two lines. From there, we can move the pointers inward to explore other possible containers.

Q:: =============================================  

##### Max Water Container

You are given an integer array `heights` where `heights[i]` represents the height of the ithi^{th}ith bar.

You may choose any two bars to form a container. Return the _maximum_ amount of water a container can store.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public)

```
Input: height = [1,7,2,5,4,7,3,6]

Output: 36
```

**Example 2:**

```
Input: height = [2,2,2]

Output: 4
```

**Constraints:**

-   `2 <= height.length <= 1000`
-   `0 <= height[i] <= 1000`

___

Given the array height = \[1,8,6,2,5,4,8,3,7\], we start with the widest container, i.e., the first and the last line. Why is it impossible for us to find a new maximum area by leaving the left pointer at index = 0, and shifting the right pointer inwards?

A) Because the new container would be narrower but not taller.

B) Because the new container would be both narrower and taller.

C) Because the new container would be wider and not shorter.

###### ID78

A:: =============================================  
**Answer**: A

The amount of water a container can hold is determined by the height of the shorter line. If we move the pointer at the taller line, the new container will be narrower (since the distance between the lines decreases), and it can't be taller (since the height is still limited by the shorter line). Therefore, there’s no need to consider anymore containers where the left pointer is at index = 0, since they will always be smaller than the current maximum.

Q:: =============================================  

##### Max Water Container

You are given an integer array `heights` where `heights[i]` represents the height of the ithi^{th}ith bar.

You may choose any two bars to form a container. Return the _maximum_ amount of water a container can store.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public)

```
Input: height = [1,7,2,5,4,7,3,6]

Output: 36
```

**Example 2:**

```
Input: height = [2,2,2]

Output: 4
```

**Constraints:**

-   `2 <= height.length <= 1000`
-   `0 <= height[i] <= 1000`

___

The two-pointer technique ensures that we don't need to enumerate all n^2 combinations of pointers to find the maximal solution. How does the technique achieve this?

A) By ensuring that every element in the array is guaranteed to have a pointer land on it at some point.

B) By skipping combinations that will never lead to a more maximal solution.

C) Both A and B.

D) None of the above.

###### ID79

A:: =============================================  
**Answer**: C

The two-pointer technique starts with the widest possible container and moves the pointers inward, always choosing the pointer at the shorter line to move. This ensures that every element in the array is guaranteed to have a pointer land on it at some point. It also avoids unnecessary combinations by skipping those that won't lead to a larger area (i.e., those where the container would be narrower but not taller). This solution is based on a ‘proof by contradiction’. Since we are being greedy and only skipping combinations that won’t lead to a new maximum, we are guaranteed to find the solution.

Q:: =============================================  

##### Max Water Container

You are given an integer array `heights` where `heights[i]` represents the height of the ithi^{th}ith bar.

You may choose any two bars to form a container. Return the _maximum_ amount of water a container can store.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public)

```
Input: height = [1,7,2,5,4,7,3,6]

Output: 36
```

**Example 2:**

```
Input: height = [2,2,2]

Output: 4
```

**Constraints:**

-   `2 <= height.length <= 1000`
-   `0 <= height[i] <= 1000`

___

What is the time and space complexity of the solution using the two-pointer technique?

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

D) Time complexity: O(n), Space complexity: O(1)

###### ID80

A:: =============================================  
**Answer**: D

The two-pointer solution has a time complexity of O(n) because you need to iterate through the array once. The space complexity is O(1) as we only use two pointers and a few variables to keep track of the maximum area, regardless of the size of the input array.

#### Chapter 5 - Trapping Rain Water

### Part III - Stack

#### Chapter 1 - Valid Parentheses - [Blind]

Q:: =============================================  

##### Validate Parentheses

You are given a string `s` consisting of the following characters: `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`.

The input string `s` is valid if and only if:

1.  Every open bracket is closed by the same type of close bracket.
2.  Open brackets are closed in the correct order.
3.  Every close bracket has a corresponding open bracket of the same type.

Return `true` if `s` is a valid string, and `false` otherwise.

**Example 1:**

```
Input: s = "[]"

Output: true
```

**Example 2:**

```
Input: s = "([{}])"

Output: true
```

**Example 3:**

```
Input: s = "[(])"

Output: false
```

Explanation: The brackets are not closed in the correct order.

**Constraints:**

-   `1 <= s.length <= 1000`

___

Consider the string s = "( \[ ) \]" . Is this string valid?

A) Yes

B) No

###### ID81

A:: =============================================  
**Answer**: B

Although every opening bracket has a matching closing bracket of the same type, they are not closed in the correct order. The first opening bracket is '(', but the first closing bracket after that is '\]', which is not the correct matching closing bracket.

Q:: =============================================  

##### Validate Parentheses

You are given a string `s` consisting of the following characters: `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`.

The input string `s` is valid if and only if:

1.  Every open bracket is closed by the same type of close bracket.
2.  Open brackets are closed in the correct order.
3.  Every close bracket has a corresponding open bracket of the same type.

Return `true` if `s` is a valid string, and `false` otherwise.

**Example 1:**

```
Input: s = "[]"

Output: true
```

**Example 2:**

```
Input: s = "([{}])"

Output: true
```

**Example 3:**

```
Input: s = "[(])"

Output: false
```

Explanation: The brackets are not closed in the correct order.

**Constraints:**

-   `1 <= s.length <= 1000`

___

At any point in the string, we can only close the most recent open bracket, and after we close a bracket we then want to close the next most recent open bracket. Which data structure would be most useful here?

A) Hashmap

B) Stack

C) Queue

D) Binary Tree

###### ID82

A:: =============================================  
**Answer**: B

A Stack is a LIFO (Last In First Out) data structure, which aligns well with this problem's requirements. When dealing with nested structures, like brackets, the most recently opened bracket must be the first one to be closed. This 'last opened, first closed' pattern is a characteristic behavior of a Stack, making it a suitable data structure to handle such scenarios.

Q:: =============================================  

##### Validate Parentheses

You are given a string `s` consisting of the following characters: `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`.

The input string `s` is valid if and only if:

1.  Every open bracket is closed by the same type of close bracket.
2.  Open brackets are closed in the correct order.
3.  Every close bracket has a corresponding open bracket of the same type.

Return `true` if `s` is a valid string, and `false` otherwise.

**Example 1:**

```
Input: s = "[]"

Output: true
```

**Example 2:**

```
Input: s = "([{}])"

Output: true
```

**Example 3:**

```
Input: s = "[(])"

Output: false
```

Explanation: The brackets are not closed in the correct order.

**Constraints:**

-   `1 <= s.length <= 1000`

___

Assume we iterate through the string s and we maintain a stack. What should we do when we encounter an open bracket?

A) Ignore it.

B) Check if it matches with the top element of the stack.

C) Push it onto the stack.

D) Pop the top element from the stack.

###### ID83

A:: =============================================  
**Answer**: C

When we encounter an open bracket, we should push it onto the stack. The stack is used to keep track of the open brackets that we have encountered but not yet closed.

Q:: =============================================  

##### Validate Parentheses

You are given a string `s` consisting of the following characters: `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`.

The input string `s` is valid if and only if:

1.  Every open bracket is closed by the same type of close bracket.
2.  Open brackets are closed in the correct order.
3.  Every close bracket has a corresponding open bracket of the same type.

Return `true` if `s` is a valid string, and `false` otherwise.

**Example 1:**

```
Input: s = "[]"

Output: true
```

**Example 2:**

```
Input: s = "([{}])"

Output: true
```

**Example 3:**

```
Input: s = "[(])"

Output: false
```

Explanation: The brackets are not closed in the correct order.

**Constraints:**

-   `1 <= s.length <= 1000`

___

Assume we iterate through the string s and we maintain a stack. What should we do when we encounter a closing bracket?

A) Ignore it.

B) Push it onto the stack.

C) Pop the top element from the stack and check if it matches with the current closing bracket.

D) Check if it matches with the bottom element of the stack.

###### ID84

A:: =============================================  
**Answer**: C

When we encounter a closing bracket, we should pop the top element from the stack and check if it is the matching opening bracket for the current closing bracket. If it is, we can continue; if it's not, or if the stack is empty, then the string is not valid.

Q:: =============================================  

##### Validate Parentheses

You are given a string `s` consisting of the following characters: `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`.

The input string `s` is valid if and only if:

1.  Every open bracket is closed by the same type of close bracket.
2.  Open brackets are closed in the correct order.
3.  Every close bracket has a corresponding open bracket of the same type.

Return `true` if `s` is a valid string, and `false` otherwise.

**Example 1:**

```
Input: s = "[]"

Output: true
```

**Example 2:**

```
Input: s = "([{}])"

Output: true
```

**Example 3:**

```
Input: s = "[(])"

Output: false
```

Explanation: The brackets are not closed in the correct order.

**Constraints:**

-   `1 <= s.length <= 1000`

___

After reaching the end of s, how do we know if the string is valid?

A) If the stack is empty.

B) If the stack is not empty.

C) If the last element in the stack is an open bracket.

D) If the last element in the stack is a closing bracket.

###### ID85

A:: =============================================  
**Answer**: A

If we have managed to close all open brackets while iterating through the string, the stack should be empty at the end. If the stack is not empty, it means there are some open brackets that were not closed, so the string is not valid.

Q:: =============================================  

##### Validate Parentheses

You are given a string `s` consisting of the following characters: `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`.

The input string `s` is valid if and only if:

1.  Every open bracket is closed by the same type of close bracket.
2.  Open brackets are closed in the correct order.
3.  Every close bracket has a corresponding open bracket of the same type.

Return `true` if `s` is a valid string, and `false` otherwise.

**Example 1:**

```
Input: s = "[]"

Output: true
```

**Example 2:**

```
Input: s = "([{}])"

Output: true
```

**Example 3:**

```
Input: s = "[(])"

Output: false
```

Explanation: The brackets are not closed in the correct order.

**Constraints:**

-   `1 <= s.length <= 1000`

___

What is the time and space complexity of the solution using a stack? Assume the length of the input string is n.

A) Time: O(n), Space: O(1)

B) Time: O(n), Space: O(n)

C) Time: O(n), Space: O(n^2)

D) Time: O(n^2), Space: O(n)

###### ID86

A:: =============================================  
**Answer**: B

We are iterating through the string only once, where n is the length of the string. For each character, we are performing a constant amount of work (either pushing onto the stack or popping from it). Hence, the time complexity is O(n). In the worst-case scenario, all characters in the string are opening brackets, and we push all of them onto the stack. Hence, the space complexity is O(n), where n is the length of the string.

#### Chapter 2 - Min Stack
#### Chapter 3 - Evaluate Reverse Polish Notation
#### Chapter 4 - Generate Parentheses
#### Chapter 5 - Daily Temperatures
#### Chapter 6 - Car Fleet
#### Chapter 7 - Largest Rectangle In Histogram

### Part IV - Binary Search

#### Chapter 1 - Binary Search
#### Chapter 2 - Search a 2D Matrix
#### Chapter 3 - Koko Eating Bananas
#### Chapter 4 - Find Minimum In Rotated Sorted Array - [Blind]

Q:: =============================================  

##### Find Minimum in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Notice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.

Assuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2]

Output: 1
```

**Example 2:**

```
Input: nums = [4,5,0,1,2,3]

Output: 0
```

**Example 3:**

```
Input: nums = [4,5,6,7]

Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`

___

Suppose we have a _normal_ sorted integer array. What is the time complexity to find the minimum element in this array?

A) O(n)

B) O(log n)

C) O(n^2)

D) O(1)

###### ID87

A:: =============================================  
**Answer**: D

In a sorted array, the minimum element is always at the beginning, which can be found in constant time, O(1).

Q:: =============================================  

##### Find Minimum in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Notice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.

Assuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2]

Output: 1
```

**Example 2:**

```
Input: nums = [4,5,0,1,2,3]

Output: 0
```

**Example 3:**

```
Input: nums = [4,5,6,7]

Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`

___

Now consider a sorted array that has been rotated at an unknown index. What is the time complexity of the _simplest_ (but non-optimal) solution to find the minimum element in this array?

A) O(n)

B) O(log n)

C) O(n^2)

D) O(1)

###### ID88

A:: =============================================  
**Answer**: A

The simplest solution would be to perform a linear search, which has a time complexity of O(n).

Q:: =============================================  

##### Find Minimum in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Notice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.

Assuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2]

Output: 1
```

**Example 2:**

```
Input: nums = [4,5,0,1,2,3]

Output: 0
```

**Example 3:**

```
Input: nums = [4,5,6,7]

Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`

___

In a typical binary search, what is the first element we check to see if it's the target?

A) The first element in the array

B) The last element in the array

C) The middle element in the array

D) The element at a random position in the array

###### ID89

A:: =============================================  
**Answer**: C

In a binary search, we first check the middle element of the array. Depending on the condition, we decide whether to proceed to the left half or the right half.

Q:: =============================================  

##### Find Minimum in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Notice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.

Assuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2]

Output: 1
```

**Example 2:**

```
Input: nums = [4,5,0,1,2,3]

Output: 0
```

**Example 3:**

```
Input: nums = [4,5,6,7]

Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`

___

In this case, our target is the minimum element. Which portion of the array will it be found?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/02eaac7f-445e-4d1c-d51b-48c7c6aa2d00/public)


A) The left sorted portion

B) The right sorted portion

###### ID90

A:: =============================================  
**Answer**: B

The minimum element will be found in the right sorted portion since every element in that portion will be less than every element in the left sorted portion. The minimum element will be the leftmost value in the right sorted portion.

Q:: =============================================  

##### Find Minimum in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Notice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.

Assuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2]

Output: 1
```

**Example 2:**

```
Input: nums = [4,5,0,1,2,3]

Output: 0
```

**Example 3:**

```
Input: nums = [4,5,6,7]

Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`

___

If the current portion of our search range from left to right is already sorted, e.g. `nums[l] < nums[r]`, then which element is the minimum of the current search range?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/958a3861-e7b7-4da8-8561-544714ca8400/public)


A) nums\[m\]

B) nums\[l\]

C) nums\[r\]

D) None of the above.

###### ID91

A:: =============================================  
**Answer**: B

In a normal sorted array, the leftmost element is the minimum. In our case, if the original array is rotated n times, the minimum will be nums\[0\]. Alternatively, as we run binary search, if the current subarray of our search is a normal sorted array, we can end the binary search.

Q:: =============================================  

##### Find Minimum in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Notice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.

Assuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2]

Output: 1
```

**Example 2:**

```
Input: nums = [4,5,0,1,2,3]

Output: 0
```

**Example 3:**

```
Input: nums = [4,5,6,7]

Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`

___

If the middle element is less than the first element of the array, where is the minimum element?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/33828cf2-4d4e-42d0-e429-b03e49111500/public)


A) At the mid point.

B) At the mid point or to the left of mid.

C) To the right of mid.

###### ID92

A:: =============================================  
**Answer**: B

If the middle element is less than the first element, it means the middle element is in the right sorted portion. The smallest element will always be found in the right sorted portion, so either the middle element is the minimum or the minimum is to the left of mid.

Q:: =============================================  

##### Find Minimum in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Notice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.

Assuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2]

Output: 1
```

**Example 2:**

```
Input: nums = [4,5,0,1,2,3]

Output: 0
```

**Example 3:**

```
Input: nums = [4,5,6,7]

Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`

___

If the middle element is greater than or equal to the first element of the array, where is the minimum element?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c5da4e6e-997d-4ccc-952d-9dd0360f9200/public)


A) To the left of mid.

B) To the right of mid.

C) At the mid point.

D) This scenario is not possible.

###### ID93

A:: =============================================  
**Answer**: B

If the middle element is greater than the first element, it means the middle element is in the left sorted portion, but the minimum must be found in the right sorted portion.

Q:: =============================================  

##### Find Minimum in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Notice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.

Assuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2]

Output: 1
```

**Example 2:**

```
Input: nums = [4,5,0,1,2,3]

Output: 0
```

**Example 3:**

```
Input: nums = [4,5,6,7]

Output: 4
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`

___

To summarize, the below code will solve this problem using an augmented binary search solution. What is the time and space complexity?

```python
def findMin(self, nums: List[int]) -> int:
    res = nums[0]
    l, r = 0, len(nums) - 1

    while l <= r:
        if nums[l] < nums[r]:
            return min(res, nums[l])

        m = (l + r) // 2
        res = min(res, nums[m])
        if nums[m] >= nums[l]:
            # We are in the left sorted portion, move right
            l = m + 1
        else:
            # We are in the right sorted portion, move left
            r = m - 1
    return res
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(log n), Space complexity: O(1)

C) Time complexity: O(n log n), Space complexity: O(n)

D) Time complexity: O(n^2), Space complexity: O(n)

###### ID94

A:: =============================================  
**Answer**: B

The binary search approach has a time complexity of O(log n) because in each step, you reduce the problem size by half. The space complexity is O(1) because you are not using any additional space that scales with the input size. You only need a constant amount of space to store the variables left, right, and mid.

#### Chapter 5 - Search In Rotated Sorted Array - [Blind]

Q:: =============================================  

##### Find Target in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Given the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.

You may assume all elements in the sorted rotated array `nums` are **unique**,

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
```

**Example 2:**

```
Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `-1000 <= target <= 1000`

___

Suppose we have a normal sorted integer array. What is normally the optimal time complexity to find an element in it?

A) O(n)

B) O(log n)

C) O(n^2)

D) O(1)

###### ID95

A:: =============================================  
**Answer**: B

For a sorted array, binary search can be applied to find an element. The time complexity of binary search is O(log n).

Q:: =============================================  

##### Find Target in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Given the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.

You may assume all elements in the sorted rotated array `nums` are **unique**,

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
```

**Example 2:**

```
Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `-1000 <= target <= 1000`

___

Now consider a sorted array that has been rotated at an unknown index. What is the time complexity of the _simplest_ (but non-optimal) solution to find an element in this array?

A) O(n)

B) O(log n)

C) O(n^2)

D) O(1)

###### ID96

A:: =============================================  
**Answer**: A

The simplest solution would be to perform a linear search, which has a time complexity of O(n).

Q:: =============================================  

##### Find Target in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Given the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.

You may assume all elements in the sorted rotated array `nums` are **unique**,

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
```

**Example 2:**

```
Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `-1000 <= target <= 1000`

___

In a typical binary search, what is the first element we check to see if it's equal to the target?

A) The first element in the array

B) The last element in the array

C) The middle element in the array

D) The element at a random position in the array

###### ID97

A:: =============================================  
**Answer**: C

In a binary search, we first check the middle element of the array. If the target is equal to it, we're done. If the target is greater, we know our target must be in the right portion of the array, and if it's less, the target must be in the left portion.

Q:: =============================================  

##### Find Target in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Given the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.

You may assume all elements in the sorted rotated array `nums` are **unique**,

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
```

**Example 2:**

```
Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `-1000 <= target <= 1000`

___

As we search the rotated sorted array, how can we use the current middle element to determine which half of the array we are currently inside?

A) Compare the middle element with nums\[0\].

B) Compare the middle element with nums\[length - 1\].

C) Compare the middle element with nums\[mid - 1\].

D) Either A or B.

###### ID98

A:: =============================================  
**Answer**: D

We can determine which half of the array we are currently inside by comparing the middle element with the first element (nums\[0\]) or the last element (nums\[length - 1\]). If the middle element is greater than or equal to nums\[0\], we are in the left portion of the array; otherwise, we are in the right sorted portion. Alternatively, if the middle element is less than or equal to nums\[length - 1\] we are in the right sorted portion, otherwise we are in the left portion.

Q:: =============================================  

##### Find Target in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Given the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.

You may assume all elements in the sorted rotated array `nums` are **unique**,

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
```

**Example 2:**

```
Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `-1000 <= target <= 1000`

___

How can we determine if the target element belongs to the left or right portion of the array?

A) Compare the target with nums\[mid\].

B) Compare the target with nums\[0\] or nums\[length - 1\].

C) Compare the target with nums\[mid - 1\] and nums\[mid + 1\].

D) None of the above.

###### ID99

A:: =============================================  
**Answer**: B

We can determine if the target element belongs to the left or right portion of the array by comparing the target with the first element (nums\[0\]) or the last element (nums\[length - 1\]). If the target is greater than or equal to the first element, it belongs to the left portion of the array. If the target is less than the first element, it belongs to the right portion of the array.

Q:: =============================================  

##### Find Target in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Given the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.

You may assume all elements in the sorted rotated array `nums` are **unique**,

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
```

**Example 2:**

```
Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `-1000 <= target <= 1000`

___

If we are in the left sorted half of the array, but the target element belongs in the right sorted half, where should we search relative to the mid pointer?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/90bcf494-c8c6-4c8e-5119-349868839200/public)


A) To the left of mid.

B) To the right of mid.

C) At the mid point.

D) This scenario is not possible.

###### ID100

A:: =============================================  
**Answer**: B

If we are in the left sorted half of the array, but the target element belongs to the right sorted half, we should continue our search to the right of the mid pointer.

Q:: =============================================  

##### Find Target in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Given the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.

You may assume all elements in the sorted rotated array `nums` are **unique**,

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
```

**Example 2:**

```
Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `-1000 <= target <= 1000`

___

If we are in the right sorted half of the array, but the target element belongs in the left sorted half, where should we search relative to the mid pointer?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/37e384cf-75a6-4148-d389-0beb27f7ee00/public)


A) To the left of mid.

B) To the right of mid.

C) At the mid point.

D) This scenario is not possible.

###### ID101

A:: =============================================  
**Answer**: A

If we are in the right sorted half of the array, but the target element belongs to the left sorted half, we should continue our search to the left of the mid pointer.

Q:: =============================================  

##### Find Target in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Given the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.

You may assume all elements in the sorted rotated array `nums` are **unique**,

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
```

**Example 2:**

```
Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `-1000 <= target <= 1000`

___

If we are in the appropriate half of the array, can we simply perform a normal binary search?

A) Yes

B) No

###### ID102

A:: =============================================  
**Answer**: A

Yes, if we are in the appropriate half of the array, we can simply perform a normal binary search. The normal binary search process involves comparing the target with the middle element and then deciding whether to continue the search in the left portion or the right portion of the array, depending on whether the target is less or greater than the middle element.

Q:: =============================================  

##### Find Target in Rotated Sorted Array

You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:

-   `[3,4,5,6,1,2]` if it was rotated `4` times.
-   `[1,2,3,4,5,6]` if it was rotated `6` times.

Given the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.

You may assume all elements in the sorted rotated array `nums` are **unique**,

A solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?

**Example 1:**

```
Input: nums = [3,4,5,6,1,2], target = 1

Output: 4
```

**Example 2:**

```
Input: nums = [3,5,6,0,1,2], target = 4

Output: -1
```

**Constraints:**

-   `1 <= nums.length <= 1000`
-   `-1000 <= nums[i] <= 1000`
-   `-1000 <= target <= 1000`

___

To summarize, the below code will solve this problem using an augmented binary search solution. What is the time and space complexity?

```python
def search(self, nums: List[int], target: int) -> int:
    left, right = 0, len(nums) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if nums[mid] >= nums[0] and target < nums[0]:
            # We're in left sorted array
            # But target is in right sorted array 
            left = mid + 1
        elif nums[mid] < nums[0] and target >= nums[0]:
            # We're in right sorted array
            # But target is in left sorted array 
            right = mid - 1
        # Otherwise: Normal binary search
        elif target > nums[mid]:
            left = mid + 1
        elif target < nums[mid]:
            right = mid - 1
        else:
            return mid
        
        return -1
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(log n), Space complexity: O(1)

C) Time complexity: O(n log n), Space complexity: O(n)

D) Time complexity: O(n^2), Space complexity: O(n)

###### ID103

A:: =============================================  
**Answer**: B

The binary search approach has a time complexity of O(log n) because in each step, you reduce the problem size by half. The space complexity is O(1) because you are not using any additional space that scales with the input size. You only need a constant amount of space to store the variables left, right, and mid.

#### Chapter 6 - Time Based Key Value Store
#### Chapter 7 - Median of Two Sorted Arrays

### Part V - Sliding Window

#### Chapter 1 - Best Time to Buy And Sell Stock - [Blind]

Q:: =============================================  

##### Buy and Sell Crypto

You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.

You may choose a **single day** to buy one NeetCoin and choose a **different day in the future** to sell it.

Return the maximum profit you can achieve. You may choose to **not make any transactions**, in which case the profit would be `0`.

**Example 1:**

```
Input: prices = [10,1,5,6,7,1]

Output: 6
```

Explanation: Buy `prices[1]` and sell `prices[4]`, `profit = 7 - 1 = 6`.

**Example 2:**

```
Input: prices = [10,8,7,5,2]

Output: 0
```

Explanation: No profitable transactions can be made, thus the max profit is 0.

**Constraints:**

-   `1 <= prices.length <= 100`
-   `0 <= prices[i] <= 100`

___

What is the brute-force approach to solving this problem?

A) Sorting the array and running binary search to find the difference between the minimum and maximum prices.

B) Calculating the profit for each valid pair of buying and selling days, and finding the maximum profit.

C) Sorting the array and finding the difference between the minimum and maximum prices.

D) Creating a new array with the differences between consecutive prices and finding the maximum difference.

###### ID104

A:: =============================================  
**Answer**: B

The correct brute-force approach is to calculate the profit for each valid pair of buying and selling days, and then find the maximum profit. For each day, we calculate the profit for every other day in the future. We keep track of the maximum profit seen.

Q:: =============================================  

##### Buy and Sell Crypto

You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.

You may choose a **single day** to buy one NeetCoin and choose a **different day in the future** to sell it.

Return the maximum profit you can achieve. You may choose to **not make any transactions**, in which case the profit would be `0`.

**Example 1:**

```
Input: prices = [10,1,5,6,7,1]

Output: 6
```

Explanation: Buy `prices[1]` and sell `prices[4]`, `profit = 7 - 1 = 6`.

**Example 2:**

```
Input: prices = [10,8,7,5,2]

Output: 0
```

Explanation: No profitable transactions can be made, thus the max profit is 0.

**Constraints:**

-   `1 <= prices.length <= 100`
-   `0 <= prices[i] <= 100`

___

We can also solve this by iterating through the array once, while keeping track of just two values. What two values should we keep track of to maximize the profit?

A) The maximum and minimum prices in the array.

B) The minimum price found so far and the maximum profit found so far.

C) The difference between each pair of prices and the maximum price found so far.

D) The maximum profit found so far and the index of the minimum price found so far.

###### ID105

A:: =============================================  
**Answer**: B

We should keep track of the minimum price found so far and the maximum profit found so far. By keeping track of these two values, we can calculate the maximum potential profit at each step while iterating through the array.

Q:: =============================================  

##### Buy and Sell Crypto

You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.

You may choose a **single day** to buy one NeetCoin and choose a **different day in the future** to sell it.

Return the maximum profit you can achieve. You may choose to **not make any transactions**, in which case the profit would be `0`.

**Example 1:**

```
Input: prices = [10,1,5,6,7,1]

Output: 6
```

Explanation: Buy `prices[1]` and sell `prices[4]`, `profit = 7 - 1 = 6`.

**Example 2:**

```
Input: prices = [10,8,7,5,2]

Output: 0
```

Explanation: No profitable transactions can be made, thus the max profit is 0.

**Constraints:**

-   `1 <= prices.length <= 100`
-   `0 <= prices[i] <= 100`

___

How will we use the minimum price found so far and the maximum profit found so far to efficiently solve this problem?

A) Using Kadane’s greedy algorithm.

B) Find the minimum price in the array, and for every other price compute the profit, until we find the maximum profit.

C) Iterate through the prices, if we find a new minimum price then update it. Compute the profit between the current price and the minimum price, if it exceeds the maximum profit, then update it.

###### ID106

A:: =============================================  
**Answer**: C

We iterate through the prices, and for each price, if it is lower than the current minimum price, we update the minimum price. Then, we compute the profit by subtracting the current minimum from the current price. If this profit is greater than the current maximum profit, we update the maximum profit.

Q:: =============================================  

##### Buy and Sell Crypto

You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.

You may choose a **single day** to buy one NeetCoin and choose a **different day in the future** to sell it.

Return the maximum profit you can achieve. You may choose to **not make any transactions**, in which case the profit would be `0`.

**Example 1:**

```
Input: prices = [10,1,5,6,7,1]

Output: 6
```

Explanation: Buy `prices[1]` and sell `prices[4]`, `profit = 7 - 1 = 6`.

**Example 2:**

```
Input: prices = [10,8,7,5,2]

Output: 0
```

Explanation: No profitable transactions can be made, thus the max profit is 0.

**Constraints:**

-   `1 <= prices.length <= 100`
-   `0 <= prices[i] <= 100`

___

What is the time complexity of the optimal solution?

A) O(1)

B) O(n)

C) O(n^2)

D) O(2^n)

###### ID107

A:: =============================================  
**Answer**: B

The optimal solution has a time complexity of O(n), where n is the number of days (or the length of the input array). This is because we're iterating through the array just once.

Q:: =============================================  

##### Buy and Sell Crypto

You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.

You may choose a **single day** to buy one NeetCoin and choose a **different day in the future** to sell it.

Return the maximum profit you can achieve. You may choose to **not make any transactions**, in which case the profit would be `0`.

**Example 1:**

```
Input: prices = [10,1,5,6,7,1]

Output: 6
```

Explanation: Buy `prices[1]` and sell `prices[4]`, `profit = 7 - 1 = 6`.

**Example 2:**

```
Input: prices = [10,8,7,5,2]

Output: 0
```

Explanation: No profitable transactions can be made, thus the max profit is 0.

**Constraints:**

-   `1 <= prices.length <= 100`
-   `0 <= prices[i] <= 100`

___

What is the space complexity of the optimal solution?

A) O(1)

B) O(n)

C) O(n^2)

D) O(2^n)

###### ID108

A:: =============================================  
**Answer**: A

The optimal solution has a constant space complexity, O(1), as we are only keeping track of two variables (minimum price and maximum profit), regardless of the size of the input array.

#### Chapter 2 - Longest Substring Without Repeating Characters - [Blind]

Q:: =============================================  

##### Longest Substring Without Duplicates

Given a string `s`, find the _length of the longest substring_ without duplicate characters.

A **substring** is a contiguous sequence of characters within a string.

**Example 1:**

```
Input: s = "zxyzxyz"

Output: 3
```

Explanation: The string "xyz" is the longest without duplicate characters.

**Example 2:**

```
Input: s = "xxxx"

Output: 1
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `s` may consist of printable ASCII characters.

___

What is a brute force solution to this problem?

A) Check each character and its subsequent characters for equality.

B) Generate all possible substrings and check each for repeated characters.

###### ID109

A:: =============================================  
**Answer**: B

The brute force solution for this problem would be to generate all possible substrings of the given string and check each of them for repeated characters. We would then keep track of the length of the longest substring without repeated characters.

Q:: =============================================  

##### Longest Substring Without Duplicates

Given a string `s`, find the _length of the longest substring_ without duplicate characters.

A **substring** is a contiguous sequence of characters within a string.

**Example 1:**

```
Input: s = "zxyzxyz"

Output: 3
```

Explanation: The string "xyz" is the longest without duplicate characters.

**Example 2:**

```
Input: s = "xxxx"

Output: 1
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `s` may consist of printable ASCII characters.

___

As we build a substring, what kind of data structure can we use to keep track of the characters we have already seen?

A) Stack

B) Queue

C) Hash Set

D) Heap

###### ID110

A:: =============================================  
**Answer**: C

A Set is a data structure that maintains a collection of unique elements. It provides constant-time complexity for search, insertion, and deletion, making it a suitable choice for tracking unique characters in a string.

Q:: =============================================  

##### Longest Substring Without Duplicates

Given a string `s`, find the _length of the longest substring_ without duplicate characters.

A **substring** is a contiguous sequence of characters within a string.

**Example 1:**

```
Input: s = "zxyzxyz"

Output: 3
```

Explanation: The string "xyz" is the longest without duplicate characters.

**Example 2:**

```
Input: s = "xxxx"

Output: 1
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `s` may consist of printable ASCII characters.

___

What approach can we use to solve this problem efficiently?

A) Divide and Conquer

B) Sliding Window

C) Recursion

###### ID111

A:: =============================================  
**Answer**: B

The sliding window approach allows us to scan through the string once (linear time complexity) while keeping track of the longest substring without repeating characters. It's an optimal strategy for this problem as it avoids unnecessary repeated computations.

Q:: =============================================  

##### Longest Substring Without Duplicates

Given a string `s`, find the _length of the longest substring_ without duplicate characters.

A **substring** is a contiguous sequence of characters within a string.

**Example 1:**

```
Input: s = "zxyzxyz"

Output: 3
```

Explanation: The string "xyz" is the longest without duplicate characters.

**Example 2:**

```
Input: s = "xxxx"

Output: 1
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `s` may consist of printable ASCII characters.

___

What can we do when we encounter a repeating character while expanding our window?

A) Remove the repeating character from our data structure and continue expanding.

B) Shrink the window from the left until the repeating character is no longer in the window.

C) Discard the current window and start a new window from the next character.

###### ID112

A:: =============================================  
**Answer**: B

When we encounter a repeating character, it means we need to shrink the window from the left until the repeating character is no longer in the window, as we are searching for substrings without repeating characters.

Q:: =============================================  

##### Longest Substring Without Duplicates

Given a string `s`, find the _length of the longest substring_ without duplicate characters.

A **substring** is a contiguous sequence of characters within a string.

**Example 1:**

```
Input: s = "zxyzxyz"

Output: 3
```

Explanation: The string "xyz" is the longest without duplicate characters.

**Example 2:**

```
Input: s = "xxxx"

Output: 1
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `s` may consist of printable ASCII characters.

___

Considering the constraint that `s` consists of English letters, digits, symbols, and spaces, what is the maximum possible size of our window?

A) 26

B) 52

C) 95

###### ID113

A:: =============================================  
**Answer**: C

In ASCII, there are 95 printable characters: 26 lowercase English letters, 26 uppercase English letters, 10 digits (0-9), 32 special characters and symbols, and the space character. This makes a total of 95 unique characters. Even if you don’t know there are exactly 95, it reasonable that there would be more than 52 (26 uppercase, 26 lowercase).

Q:: =============================================  

##### Longest Substring Without Duplicates

Given a string `s`, find the _length of the longest substring_ without duplicate characters.

A **substring** is a contiguous sequence of characters within a string.

**Example 1:**

```
Input: s = "zxyzxyz"

Output: 3
```

Explanation: The string "xyz" is the longest without duplicate characters.

**Example 2:**

```
Input: s = "xxxx"

Output: 1
```

**Constraints:**

-   `0 <= s.length <= 1000`
-   `s` may consist of printable ASCII characters.

___

What is the time and space complexity of the sliding window approach for this problem? Assume `n` is the length of the string, and `m` is the number of distinct characters in the string.

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        char_set = set()
        l, max_len = 0, 0
        
        for r in range(len(s)):
            while s[r] in char_set:
                # Repeating char detected, shrink window
                char_set.remove(s[l])
                l += 1
            char_set.add(s[r])
            max_len = max(max_len, r - l + 1)
        return max_len
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(m)

C) Time complexity: O(n^2), Space complexity: O(m)

###### ID114

A:: =============================================  
**Answer**: B

Using the sliding window approach, we essentially scan through the string once with two pointers, making the time complexity O(n). The space complexity is O(m) because, in the worst-case scenario, the set used to check for repeating characters can contain all the distinct characters in the string, where m is the number of distinct characters.

#### Chapter 3 - Longest Repeating Character Replacement - [Blind]

Q:: =============================================  

##### Longest Repeating Substring With Replacement

You are given a string `s` consisting of only uppercase english characters and an integer `k`. You can choose up to `k` characters of the string and replace them with any other uppercase English character.

After performing at most `k` replacements, return the length of the longest substring which contains only one distinct character.

**Example 1:**

```
Input: s = "XYYX", k = 2

Output: 4
```

Explanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.

**Example 2:**

```
Input: s = "AAABABB", k = 1

Output: 5
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `0 <= k <= s.length`

___

What is a brute force solution to this problem?

A) Iterate from the end of the string to the beginning, checking for duplicate characters.

B) For each substring, find the frequency of the most common character (maxf) and check if the length of the substring minus maxf is less than or equal to k.

###### ID115

A:: =============================================  
**Answer**: B

The brute force solution would be to generate all possible substrings and for each substring, find the frequency of the most common character. If the length of the substring minus the frequency of the most common character is less than or equal to k, then the substring is valid (since we can change at most k characters to make all characters in the substring the same). We would then keep track of the maximum length of such valid substrings.

Q:: =============================================  

##### Longest Repeating Substring With Replacement

You are given a string `s` consisting of only uppercase english characters and an integer `k`. You can choose up to `k` characters of the string and replace them with any other uppercase English character.

After performing at most `k` replacements, return the length of the longest substring which contains only one distinct character.

**Example 1:**

```
Input: s = "XYYX", k = 2

Output: 4
```

Explanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.

**Example 2:**

```
Input: s = "AAABABB", k = 1

Output: 5
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `0 <= k <= s.length`

___

What kind of data structure could help us track the frequency of each character in the current window of our string?

A) Queue

B) Array

C) Hash Map

D) Either B or C

###### ID116

A:: =============================================  
**Answer**: D

Both an Array and a Hash Map can be used to efficiently count the frequency of elements. By keeping a frequency count of characters in our current window, we can determine the most frequent character. In the case of an Array, we could use each index to represent a unique character from the string (i.e., 'A' to 'Z' mapped to 0 to 25). In the case of a Hash Map, we would use the character itself as the key and the frequency as the value. Both methods allow us to update and access the frequency of each character in constant time.

Q:: =============================================  

##### Longest Repeating Substring With Replacement

You are given a string `s` consisting of only uppercase english characters and an integer `k`. You can choose up to `k` characters of the string and replace them with any other uppercase English character.

After performing at most `k` replacements, return the length of the longest substring which contains only one distinct character.

**Example 1:**

```
Input: s = "XYYX", k = 2

Output: 4
```

Explanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.

**Example 2:**

```
Input: s = "AAABABB", k = 1

Output: 5
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `0 <= k <= s.length`

___

Considering an efficient approach, what strategy could we use to solve this problem efficiently?

A) Divide and Conquer

B) Two pointers with sliding window

C) Recursion

###### ID117

A:: =============================================  
**Answer**: B

The two pointers with sliding window strategy allows us to scan through the string in linear time complexity while keeping track of the longest substring with the same letters. The sliding window size changes based on the character frequency and the number of operations allowed.

Q:: =============================================  

##### Longest Repeating Substring With Replacement

You are given a string `s` consisting of only uppercase english characters and an integer `k`. You can choose up to `k` characters of the string and replace them with any other uppercase English character.

After performing at most `k` replacements, return the length of the longest substring which contains only one distinct character.

**Example 1:**

```
Input: s = "XYYX", k = 2

Output: 4
```

Explanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.

**Example 2:**

```
Input: s = "AAABABB", k = 1

Output: 5
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `0 <= k <= s.length`

___

If our current window size minus the frequency of the most common character is greater than k, what should we do?

A) Expand the window from the right

B) Shrink the window from the left

C) Increase k

D) Change the character at the left of the window

###### ID118

A:: =============================================  
**Answer**: B

If the window size minus the frequency of the most common character is greater than k, it means we cannot make all characters the same in this window by changing k characters. Therefore, we need to shrink the window from the left.

Q:: =============================================  

##### Longest Repeating Substring With Replacement

You are given a string `s` consisting of only uppercase english characters and an integer `k`. You can choose up to `k` characters of the string and replace them with any other uppercase English character.

After performing at most `k` replacements, return the length of the longest substring which contains only one distinct character.

**Example 1:**

```
Input: s = "XYYX", k = 2

Output: 4
```

Explanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.

**Example 2:**

```
Input: s = "AAABABB", k = 1

Output: 5
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `0 <= k <= s.length`

___

Considering that the given string only contains uppercase English letters (from A to Z), what would be the time complexity of finding the most frequent character in the window?

A) O(1)

B) O(n)

C) O(logn)

###### ID119

A:: =============================================  
**Answer**: A

Since we know that the string only contains uppercase English letters, there can be at most 26 unique characters. Thus, if we were to iterate through each unique character in our frequency dictionary or array to find the most frequent one, the time complexity would be O(26), which is essentially constant time, O(1).

Q:: =============================================  

##### Longest Repeating Substring With Replacement

You are given a string `s` consisting of only uppercase english characters and an integer `k`. You can choose up to `k` characters of the string and replace them with any other uppercase English character.

After performing at most `k` replacements, return the length of the longest substring which contains only one distinct character.

**Example 1:**

```
Input: s = "XYYX", k = 2

Output: 4
```

Explanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.

**Example 2:**

```
Input: s = "AAABABB", k = 1

Output: 5
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `0 <= k <= s.length`

___

What is the time and space complexity of the sliding window approach for this problem? Assume `n` is the length of the string.

```python
class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        res = 0
        l = 0
        count = [0] * 26
        for r in range(len(s)):
            count[ord(s[r]) - ord('A')] += 1
            while (r - l + 1) - max(count) > k:
                count[ord(s[l]) - ord('A')] -= 1
                l += 1
            res = max(res, r - l + 1)
        return res
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

###### ID120

A:: =============================================  
**Answer**: A

The sliding window approach only scans the string once, and the time complexity is therefore O(n). The space complexity is O(1) because the count array always has a fixed size of 26, corresponding to the number of uppercase English letters. Even though we're dealing with a string of n characters, we're only ever tracking a maximum of 26 different ones.

#### Chapter 4 - Permutation In String
#### Chapter 5 - Minimum Window Substring - [Blind]

Q:: =============================================  

##### Minimum Window With Characters

Given two strings `s` and `t`, return the shortest **substring** of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `""`.

You may assume that the correct output is always unique.

**Example 1:**

```
Input: s = "OUZODYXAZV", t = "XYZ"

Output: "YXAZ"
```

Explanation: `"YXAZ"` is the shortest substring that includes `"X"`, `"Y"`, and `"Z"` from string `t`.

**Example 2:**

```
Input: s = "xyz", t = "xyz"

Output: "xyz"
```

**Example 3:**

```
Input: s = "x", t = "xy"

Output: ""
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `1 <= t.length <= 1000`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

What is a brute force solution for this problem?

A) Check all substrings of s to find if they contain all characters of t

B) Remove each character of s one by one and check if the remaining string contains t

C) Sort both s and t and check if t is a substring of s

###### ID121

A:: =============================================  
**Answer**: A

The brute force solution would be to generate all possible substrings of s and for each substring, check if it contains all characters of t including duplicates. Then we keep the shortest such valid substring.

Q:: =============================================  

##### Minimum Window With Characters

Given two strings `s` and `t`, return the shortest **substring** of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `""`.

You may assume that the correct output is always unique.

**Example 1:**

```
Input: s = "OUZODYXAZV", t = "XYZ"

Output: "YXAZ"
```

Explanation: `"YXAZ"` is the shortest substring that includes `"X"`, `"Y"`, and `"Z"` from string `t`.

**Example 2:**

```
Input: s = "xyz", t = "xyz"

Output: "xyz"
```

**Example 3:**

```
Input: s = "x", t = "xy"

Output: ""
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `1 <= t.length <= 1000`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

What kind of data structure could help us track the frequency of each character in the current window of our string?

A) Linked List

B) Hash Map

C) Stack

###### ID122

A:: =============================================  
**Answer**: B

A Hash Map is a good data structure to efficiently track the frequency of each character in the current window. By using the character itself as the key and the frequency as the value, we can access and update the frequency of each character in constant time.

Q:: =============================================  

##### Minimum Window With Characters

Given two strings `s` and `t`, return the shortest **substring** of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `""`.

You may assume that the correct output is always unique.

**Example 1:**

```
Input: s = "OUZODYXAZV", t = "XYZ"

Output: "YXAZ"
```

Explanation: `"YXAZ"` is the shortest substring that includes `"X"`, `"Y"`, and `"Z"` from string `t`.

**Example 2:**

```
Input: s = "xyz", t = "xyz"

Output: "xyz"
```

**Example 3:**

```
Input: s = "x", t = "xy"

Output: ""
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `1 <= t.length <= 1000`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

Considering an efficient approach, what strategy could we use to solve this problem?

A) Divide and Conquer

B) Two Pointers with Sliding Window

C) Binary Search

###### ID123

A:: =============================================  
**Answer**: B

The Two Pointers with Sliding Window strategy allows us to scan through the string in linear time complexity while keeping track of the smallest valid substring. We maintain a sliding window that always satisfies the condition of containing all characters of `t`.

Q:: =============================================  

##### Minimum Window With Characters

Given two strings `s` and `t`, return the shortest **substring** of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `""`.

You may assume that the correct output is always unique.

**Example 1:**

```
Input: s = "OUZODYXAZV", t = "XYZ"

Output: "YXAZ"
```

Explanation: `"YXAZ"` is the shortest substring that includes `"X"`, `"Y"`, and `"Z"` from string `t`.

**Example 2:**

```
Input: s = "xyz", t = "xyz"

Output: "xyz"
```

**Example 3:**

```
Input: s = "x", t = "xy"

Output: ""
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `1 <= t.length <= 1000`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

What should we do if our current window doesn't contain all characters of `t`?

A) Expand the window from the right

B) Shrink the window from the left

C) Remove the window and create a new one

###### ID124

A:: =============================================  
**Answer**: A

If our current window does not contain all characters of `t`, it means we need to expand the window from the right in hope of including the missing characters.

Q:: =============================================  

##### Minimum Window With Characters

Given two strings `s` and `t`, return the shortest **substring** of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `""`.

You may assume that the correct output is always unique.

**Example 1:**

```
Input: s = "OUZODYXAZV", t = "XYZ"

Output: "YXAZ"
```

Explanation: `"YXAZ"` is the shortest substring that includes `"X"`, `"Y"`, and `"Z"` from string `t`.

**Example 2:**

```
Input: s = "xyz", t = "xyz"

Output: "xyz"
```

**Example 3:**

```
Input: s = "x", t = "xy"

Output: ""
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `1 <= t.length <= 1000`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

If our current window contains all characters of `t`, what should we do to find the smallest valid window?

A) Expand the window from the right

B) Shrink the window from the left

C) Expand the window from the left

###### ID125

A:: =============================================  
**Answer**: B

If our current window already contains all characters of `t`, we try to shrink the window from the left to find the smallest window that still satisfies the condition. If we can't shrink it without losing a necessary character, we move on to expanding it from the right again.

Q:: =============================================  

##### Minimum Window With Characters

Given two strings `s` and `t`, return the shortest **substring** of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `""`.

You may assume that the correct output is always unique.

**Example 1:**

```
Input: s = "OUZODYXAZV", t = "XYZ"

Output: "YXAZ"
```

Explanation: `"YXAZ"` is the shortest substring that includes `"X"`, `"Y"`, and `"Z"` from string `t`.

**Example 2:**

```
Input: s = "xyz", t = "xyz"

Output: "xyz"
```

**Example 3:**

```
Input: s = "x", t = "xy"

Output: ""
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `1 <= t.length <= 1000`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

How can we determine if our current window contains all characters of `t` without iterating through the entire hashmap?

A) By checking if the length of the window is greater than or equal to the length of `t`

B) By keeping track of two variables: the number of unique characters we have from `t` in our current window and the total unique characters needed from `t`

C) By sorting the hashmap and comparing it with `t`

###### ID126

A:: =============================================  
**Answer**: B

By maintaining two variables, `have` and `need`, we can efficiently check if our window contains all characters of `t`. `need` is the number of unique characters in `t`, and `have` is the number of unique characters in `t` that our window currently contains. Each time we add a character to our window that makes the count of that character match what's needed in `t`, we increment `have`. We know our window contains all characters of `t` when `have` equals `need`.

Q:: =============================================  

##### Minimum Window With Characters

Given two strings `s` and `t`, return the shortest **substring** of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `""`.

You may assume that the correct output is always unique.

**Example 1:**

```
Input: s = "OUZODYXAZV", t = "XYZ"

Output: "YXAZ"
```

Explanation: `"YXAZ"` is the shortest substring that includes `"X"`, `"Y"`, and `"Z"` from string `t`.

**Example 2:**

```
Input: s = "xyz", t = "xyz"

Output: "xyz"
```

**Example 3:**

```
Input: s = "x", t = "xy"

Output: ""
```

**Constraints:**

-   `1 <= s.length <= 1000`
-   `1 <= t.length <= 1000`
-   `s` and `t` consist of uppercase and lowercase English letters.

___

Given that the input strings only consist of lowercase or uppercase English characters, what is the time and space complexity of the sliding window approach below? Assume `n` is the length of `s` and `m` is the length of `t`.

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == '': return ''

        countT, window = {}, {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        have, need = 0, len(countT)
        res, resLen = [-1, -1], float('infinity')
        l = 0
        for r in range(len(s)):
            c = s[r]
            window[c] = 1 + window.get(c, 0)

            if c in countT and window[c] == countT[c]:
                have += 1

            while have == need:
                if (r - l + 1) < resLen:
                    res = [l, r]
                    resLen = (r - l + 1)
                window[s[l]] -= 1
                if s[l] in countT and window[s[l]] < countT[s[l]]:
                    have -= 1
                l += 1
        l, r = res
        return s[l:r+1] if resLen != float('infinity') else ''
```

A) Time complexity: O(n+m), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(m)

###### ID127

A:: =============================================  
**Answer**: A

The time complexity is O(n+m) as we go through both s and t once. The space complexity is O(1) because the countT and window dictionaries will at most contain 52 unique keys, corresponding to the 26 lowercase and 26 uppercase English letters, which is a constant number and does not grow with n or m.

#### Chapter 6 - Sliding Window Maximum

### Part VI - Linked List

#### Chapter 1 - Reverse Linked List - [Blind]

Q:: =============================================  

##### Reverse a Linked List

Given the beginning of a singly linked list `head`, reverse the list, and return the new beginning of the list.

**Example 1:**

```
Input: head = [0,1,2,3]

Output: [3,2,1,0]
```

**Example 2:**

```
Input: head = []

Output: []
```

**Constraints:**

-   `0 <= The length of the list <= 1000`.
-   `-1000 <= Node.val <= 1000`

___

If we have a linked list with only one node, what will be the result after reversing it?

A) An empty linked list

B) The same linked list

###### ID128

A:: =============================================  
**Answer**: B

Reversing a linked list with only one node doesn't change anything. It remains the same, as there are no other nodes to rearrange.

Q:: =============================================  

##### Reverse a Linked List

Given the beginning of a singly linked list `head`, reverse the list, and return the new beginning of the list.

**Example 1:**

```
Input: head = [0,1,2,3]

Output: [3,2,1,0]
```

**Example 2:**

```
Input: head = []

Output: []
```

**Constraints:**

-   `0 <= The length of the list <= 1000`.
-   `-1000 <= Node.val <= 1000`

___

In order to reverse a linked list, we need to change the direction of which part of each node?

A) The node's value

B) The node's 'next' reference

###### ID129

A:: =============================================  
**Answer**: B

In a singly linked list, each node has a value and a 'next' reference pointing to the next node in the list. To reverse the list, we need to change the 'next' reference of each node to point to the previous node.

Q:: =============================================  

##### Reverse a Linked List

Given the beginning of a singly linked list `head`, reverse the list, and return the new beginning of the list.

**Example 1:**

```
Input: head = [0,1,2,3]

Output: [3,2,1,0]
```

**Example 2:**

```
Input: head = []

Output: []
```

**Constraints:**

-   `0 <= The length of the list <= 1000`.
-   `-1000 <= Node.val <= 1000`

___

What could be a simple, but also optimal approach to reverse a linked list?

A) Recursively reverse the linked list in-place.

B) Use a stack to reverse the values of the linked list in-place.

C) Traverse the list once, and for each node, set its 'next' to the previous node.

###### ID130

A:: =============================================  
**Answer**: C

Recursion or using a stack would require additional space and isn't necessary. By traversing the list and updating the 'next' reference of each node to point to the previous node, we can achieve the desired result.

Q:: =============================================  

##### Reverse a Linked List

Given the beginning of a singly linked list `head`, reverse the list, and return the new beginning of the list.

**Example 1:**

```
Input: head = [0,1,2,3]

Output: [3,2,1,0]
```

**Example 2:**

```
Input: head = []

Output: []
```

**Constraints:**

-   `0 <= The length of the list <= 1000`.
-   `-1000 <= Node.val <= 1000`

___

What is the time and space complexity of the optimal approach?

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev, curr = None, head
        
        while curr: 
            temp = curr.next
            curr.next = prev
            prev = curr
            curr = temp
        return prev
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n), Space complexity: O(1)

C) Time complexity: O(1), Space complexity: O(1)

###### ID131

A:: =============================================  
**Answer**: B

The time complexity is O(n) because we need to traverse the list once, where n is the number of nodes in the list. The space complexity is O(1) because we are not using any additional space that scales with the size of the input. We only use a few variables to keep track of the previous and current nodes during the process.

#### Chapter 2 - Merge Two Sorted Lists - [Blind]

Q:: =============================================  

##### Merge Two Sorted Linked Lists

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists into one **sorted** linked list and return the head of the new sorted linked list.

The new list should be made up of nodes from `list1` and `list2`.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/51adfea9-493a-4abb-ece7-fbb359d1c800/public)

```
Input: list1 = [1,2,4], list2 = [1,3,5]

Output: [1,1,2,3,4,5]
```

**Example 2:**

```
Input: list1 = [], list2 = [1,2]

Output: [1,2]
```

**Example 3:**

```
Input: list1 = [], list2 = []

Output: []
```

**Constraints:**

-   `0 <= The length of the each list <= 100`.
-   `-100 <= Node.val <= 100`

___

If we have two sorted linked lists, where should we start comparing elements to begin merging them into a single sorted list?

A) From the middle of each list.

B) From the last element of each list.

C) From the first element of each list.

###### ID132

A:: =============================================  
**Answer**: C

As both lists are sorted in non-decreasing order, the smallest elements are at the heads of the lists. Hence, we should start comparing from the first elements of each list to create the new sorted list.

Q:: =============================================  

##### Merge Two Sorted Linked Lists

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists into one **sorted** linked list and return the head of the new sorted linked list.

The new list should be made up of nodes from `list1` and `list2`.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/51adfea9-493a-4abb-ece7-fbb359d1c800/public)

```
Input: list1 = [1,2,4], list2 = [1,3,5]

Output: [1,1,2,3,4,5]
```

**Example 2:**

```
Input: list1 = [], list2 = [1,2]

Output: [1,2]
```

**Example 3:**

```
Input: list1 = [], list2 = []

Output: []
```

**Constraints:**

-   `0 <= The length of the each list <= 100`.
-   `-100 <= Node.val <= 100`

___

When comparing the first nodes of each list, which node should we insert into the output list?

A) The node with the larger value.

B) The node with the smaller value.

C) Any node, the choice doesn't matter.

###### ID133

A:: =============================================  
**Answer**: B

To maintain the sorted order in the output list, we should always insert the node with the smaller value first. If there’s a tie, we can insert either node. This ensures that we are always adding the smallest remaining element to the merged list.

Q:: =============================================  

##### Merge Two Sorted Linked Lists

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists into one **sorted** linked list and return the head of the new sorted linked list.

The new list should be made up of nodes from `list1` and `list2`.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/51adfea9-493a-4abb-ece7-fbb359d1c800/public)

```
Input: list1 = [1,2,4], list2 = [1,3,5]

Output: [1,1,2,3,4,5]
```

**Example 2:**

```
Input: list1 = [], list2 = [1,2]

Output: [1,2]
```

**Example 3:**

```
Input: list1 = [], list2 = []

Output: []
```

**Constraints:**

-   `0 <= The length of the each list <= 100`.
-   `-100 <= Node.val <= 100`

___

How should we proceed after inserting a node from one of the lists into the output list?

A) Insert the node from the other list into the output list.

B) Shift to the next node in both lists and repeat the comparison.

C) Shift to the next node in the list from which we inserted the node and repeat the comparison.

###### ID134

A:: =============================================  
**Answer**: C

After inserting a node from one of the lists into the output list, we should shift to the next node in the same list. We've already considered the inserted node in the sorting process. Now, it's time to compare the next node from this list with the current node from the other list.

Q:: =============================================  

##### Merge Two Sorted Linked Lists

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists into one **sorted** linked list and return the head of the new sorted linked list.

The new list should be made up of nodes from `list1` and `list2`.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/51adfea9-493a-4abb-ece7-fbb359d1c800/public)

```
Input: list1 = [1,2,4], list2 = [1,3,5]

Output: [1,1,2,3,4,5]
```

**Example 2:**

```
Input: list1 = [], list2 = [1,2]

Output: [1,2]
```

**Example 3:**

```
Input: list1 = [], list2 = []

Output: []
```

**Constraints:**

-   `0 <= The length of the each list <= 100`.
-   `-100 <= Node.val <= 100`

___

What if one list becomes empty (all of its nodes are used up) before the other during the merging process?

A) Discard the remaining nodes in the other list.

B) Append the remaining nodes in the other list to the merged list.

C) Pick nodes from the exhausted list randomly to fill up the merged list.

###### ID135

A:: =============================================  
**Answer**: B

If one list becomes empty before the other, we can safely append the remaining nodes from the other list to the merged list. As both lists are sorted, the remaining nodes will also be in sorted order.

Q:: =============================================  

##### Merge Two Sorted Linked Lists

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists into one **sorted** linked list and return the head of the new sorted linked list.

The new list should be made up of nodes from `list1` and `list2`.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/51adfea9-493a-4abb-ece7-fbb359d1c800/public)

```
Input: list1 = [1,2,4], list2 = [1,3,5]

Output: [1,1,2,3,4,5]
```

**Example 2:**

```
Input: list1 = [], list2 = [1,2]

Output: [1,2]
```

**Example 3:**

```
Input: list1 = [], list2 = []

Output: []
```

**Constraints:**

-   `0 <= The length of the each list <= 100`.
-   `-100 <= Node.val <= 100`

___

What is the time complexity and space complexity of this approach? Assume `m` and `n` are the lengths of list1 and list2 respectively.

```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        current = dummy

        while l1 and l2:
            if l1.val <= l2.val:
                current.next = l1
                l1 = l1.next
            else:
                current.next = l2
                l2 = l2.next
            current = current.next

        current.next = l1 if l1 is not None else l2
        return dummy.next
```

A) Time complexity: O(m+n), Space complexity: O(1)

B) Time complexity: O(m\*n), Space complexity: O(m+n)

C) Time complexity: O(m+n), Space complexity: O(m+n)

###### ID136

A:: =============================================  
**Answer**: A

The time complexity is O(m+n) because in the worst case, we'll have to traverse all nodes of both lists once. The space complexity is O(1) because we're not using any additional space that scales with the input size. We are simply rearranging the existing nodes.

#### Chapter 3 - Reorder List - [Blind]

Q:: =============================================  

##### Reorder Linked List

You are given the head of a singly linked-list.

The positions of a linked list of `length = 7` for example, can intially be represented as:

`[0, 1, 2, 3, 4, 5, 6]`

Reorder the nodes of the linked list to be in the following order:

`[0, 6, 1, 5, 2, 4, 3]`

Notice that in the general case for a list of `length = n` the nodes are reordered to be in the following order:

`[0, n-1, 1, n-2, 2, n-3, ...]`

You may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.

**Example 1:**

```
Input: head = [2,4,6,8]

Output: [2,8,4,6]
```

**Example 2:**

```
Input: head = [2,4,6,8,10]

Output: [2,10,4,8,6]
```

**Constraints:**

-   `1 <= Length of the list <= 1000`.
-   `1 <= Node.val <= 1000`

___

Given the list L0 → L1 → … → Ln - 1 → Ln, what is the first step to reorder the list to the following form: L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …?

A) Reversing the entire list.

B) Reversing the second half of the list.

C) Swapping the first and the last node.

###### ID137

A:: =============================================  
**Answer**: B

To get to the required order, we first need to reverse the second half of the list. This is because the second half of the list is to be interweaved with the first half, but in the reverse order.

Q:: =============================================  

##### Reorder Linked List

You are given the head of a singly linked-list.

The positions of a linked list of `length = 7` for example, can intially be represented as:

`[0, 1, 2, 3, 4, 5, 6]`

Reorder the nodes of the linked list to be in the following order:

`[0, 6, 1, 5, 2, 4, 3]`

Notice that in the general case for a list of `length = n` the nodes are reordered to be in the following order:

`[0, n-1, 1, n-2, 2, n-3, ...]`

You may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.

**Example 1:**

```
Input: head = [2,4,6,8]

Output: [2,8,4,6]
```

**Example 2:**

```
Input: head = [2,4,6,8,10]

Output: [2,10,4,8,6]
```

**Constraints:**

-   `1 <= Length of the list <= 1000`.
-   `1 <= Node.val <= 1000`

___

How can you find the middle node of a singly linked list?

A) Starting from the head, move to the next node until you find the middle node.

B) Use two pointers: a slow pointer moving one step at a time, and a fast pointer moving two steps at a time.

###### ID138

A:: =============================================  
**Answer**: B

We use a technique known as the 'tortoise and the hare' to find the middle of a singly linked list. The slow pointer moves one step at a time while the fast pointer moves two steps at a time. By the time the fast pointer reaches the end of the list, the slow pointer will be at the middle.

Q:: =============================================  

##### Reorder Linked List

You are given the head of a singly linked-list.

The positions of a linked list of `length = 7` for example, can intially be represented as:

`[0, 1, 2, 3, 4, 5, 6]`

Reorder the nodes of the linked list to be in the following order:

`[0, 6, 1, 5, 2, 4, 3]`

Notice that in the general case for a list of `length = n` the nodes are reordered to be in the following order:

`[0, n-1, 1, n-2, 2, n-3, ...]`

You may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.

**Example 1:**

```
Input: head = [2,4,6,8]

Output: [2,8,4,6]
```

**Example 2:**

```
Input: head = [2,4,6,8,10]

Output: [2,10,4,8,6]
```

**Constraints:**

-   `1 <= Length of the list <= 1000`.
-   `1 <= Node.val <= 1000`

___

After reversing the second half of the list, how do you reorder the list to the required form?

A) By appending the second half of the list to the first half.

B) By alternating nodes from the first and second half of the list.

C) By concatenating the first half of the list to the second half.

###### ID139

A:: =============================================  
**Answer**: B

After reversing the second half of the list, we reorder the list by alternating nodes from the first and second half of the list.

Q:: =============================================  

##### Reorder Linked List

You are given the head of a singly linked-list.

The positions of a linked list of `length = 7` for example, can intially be represented as:

`[0, 1, 2, 3, 4, 5, 6]`

Reorder the nodes of the linked list to be in the following order:

`[0, 6, 1, 5, 2, 4, 3]`

Notice that in the general case for a list of `length = n` the nodes are reordered to be in the following order:

`[0, n-1, 1, n-2, 2, n-3, ...]`

You may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.

**Example 1:**

```
Input: head = [2,4,6,8]

Output: [2,8,4,6]
```

**Example 2:**

```
Input: head = [2,4,6,8,10]

Output: [2,10,4,8,6]
```

**Constraints:**

-   `1 <= Length of the list <= 1000`.
-   `1 <= Node.val <= 1000`

___

In the code, what approach is used to merge the two halves of the list into the required form?

A) A new list is created and nodes from both halves are added alternately.

B) Corresponding nodes from the first and second half of the list are swapped.

C) At each step, a node is unlinked from the second half and linked into the first half.

###### ID140

A:: =============================================  
**Answer**: C

The provided code merges the two halves by iterating through the first half of the list. At each step, it unlinks a node from the second half and links it into the first half. This results in the desired ordering of nodes.

Q:: =============================================  

##### Reorder Linked List

You are given the head of a singly linked-list.

The positions of a linked list of `length = 7` for example, can intially be represented as:

`[0, 1, 2, 3, 4, 5, 6]`

Reorder the nodes of the linked list to be in the following order:

`[0, 6, 1, 5, 2, 4, 3]`

Notice that in the general case for a list of `length = n` the nodes are reordered to be in the following order:

`[0, n-1, 1, n-2, 2, n-3, ...]`

You may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.

**Example 1:**

```
Input: head = [2,4,6,8]

Output: [2,8,4,6]
```

**Example 2:**

```
Input: head = [2,4,6,8,10]

Output: [2,10,4,8,6]
```

**Constraints:**

-   `1 <= Length of the list <= 1000`.
-   `1 <= Node.val <= 1000`

___

Consider the following code for reordering a linked list. What is its time complexity and space complexity?

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reorderList(self, head: ListNode) -> None:
        # find middle
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next

        # reverse second half
        second = slow.next
        prev = slow.next = None
        while second:
            tmp = second.next
            second.next = prev
            prev = second
            second = tmp

        # merge two halves
        first, second = head, prev
        while second:
            tmp1, tmp2 = first.next, second.next
            first.next = second
            second.next = tmp1
            first, second = tmp1, tmp2
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

###### ID141

A:: =============================================  
**Answer**: A

This approach has a linear time complexity O(n) because we are making a single pass to find the middle, a single pass to reverse the second half, and a single pass to merge the two halves. The space complexity is O(1) because we are rearranging the nodes in-place without using additional storage proportional to the input size.

#### Chapter 4 - Remove Nth Node From End of List - [Blind]

Q:: =============================================  

##### Remove Node From End of Linked List

You are given the beginning of a linked list `head`, and an integer `n`.

Remove the `nth` node from the end of the list and return the beginning of the list.

**Example 1:**

```
Input: head = [1,2,3,4], n = 2

Output: [1,2,4]
```

**Example 2:**

```
Input: head = [5], n = 1

Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 2

Output: [2]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

___

In order to remove a node `x` from a singly linked list, which node do we need access to?

A) Node x

B) Node before x

C) Node after x

###### ID142

A:: =============================================  
**Answer**: B

To remove a node x from a singly linked list, we need access to the node before x. This is because in a singly linked list, we can only navigate in one direction and there's no reference to the previous node from a given node. By having access to the node before x, we can adjust its next reference to bypass x, effectively removing x from the list.

Q:: =============================================  

##### Remove Node From End of Linked List

You are given the beginning of a linked list `head`, and an integer `n`.

Remove the `nth` node from the end of the list and return the beginning of the list.

**Example 1:**

```
Input: head = [1,2,3,4], n = 2

Output: [1,2,4]
```

**Example 2:**

```
Input: head = [5], n = 1

Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 2

Output: [2]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

___

An edge case is where we must remove the first node in the list. What is a simple way to eliminate this edge case?

A) Add a dummy node at the end of the list.

B) Add a dummy node at the beginning of the list.

C) There is no way to eliminate this edge case.

###### ID143

A:: =============================================  
**Answer**: B

To eliminate the edge case of removing the first node in the list, we can add a dummy node at the beginning of the list. This dummy node won't affect the other operations, but allows us to handle the head of the list in a consistent way with other nodes.

Q:: =============================================  

##### Remove Node From End of Linked List

You are given the beginning of a linked list `head`, and an integer `n`.

Remove the `nth` node from the end of the list and return the beginning of the list.

**Example 1:**

```
Input: head = [1,2,3,4], n = 2

Output: [1,2,4]
```

**Example 2:**

```
Input: head = [5], n = 1

Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 2

Output: [2]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

___

If we were to solve this problem without precomputing the length of the list, but instead using two pointers, what should the _offset_ between the two pointers be? Assume we will iterate until the second pointer reaches null.  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c6af2817-4885-47c2-9f04-8e9603192500/public)


A) n

B) n + 1

C) n - 1

###### ID144

A:: =============================================  
**Answer**: B

If we are to solve this problem using two pointers without precomputing the length of the list, the offset between the two pointers should be n + 1. This ensures that the second pointer reaches null right when the first pointer gets to the node before the target node, which is the nth node from the end of the list.

Q:: =============================================  

##### Remove Node From End of Linked List

You are given the beginning of a linked list `head`, and an integer `n`.

Remove the `nth` node from the end of the list and return the beginning of the list.

**Example 1:**

```
Input: head = [1,2,3,4], n = 2

Output: [1,2,4]
```

**Example 2:**

```
Input: head = [5], n = 1

Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 2

Output: [2]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

___

After we have created the offset, by how much should we shift each pointer on each iteration of the loop?

A) First pointer by 1, Second pointer by 2

B) First pointer by 1, Second pointer by 1

###### ID145

A:: =============================================  
**Answer**: B

After we have created the offset, we should shift each pointer by 1 on each iteration of the loop. This ensures that the offset (the gap between the two pointers) remains constant while traversing the list, allowing us to find the node to be removed.

Q:: =============================================  

##### Remove Node From End of Linked List

You are given the beginning of a linked list `head`, and an integer `n`.

Remove the `nth` node from the end of the list and return the beginning of the list.

**Example 1:**

```
Input: head = [1,2,3,4], n = 2

Output: [1,2,4]
```

**Example 2:**

```
Input: head = [5], n = 1

Output: []
```

**Example 3:**

```
Input: head = [1,2], n = 2

Output: [2]
```

**Constraints:**

-   The number of nodes in the list is `sz`.
-   `1 <= sz <= 30`
-   `0 <= Node.val <= 100`
-   `1 <= n <= sz`

___

What is the time and space complexity of the two-pointer approach for this problem? Assume `n` is the length of the list.

```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = ListNode(0, head)
        left = dummy
        right = head

        while n > 0: // Create offset
            right = right.next
            n -= 1

        while right:
            left = left.next
            right = right.next

        left.next = left.next.next // delete
        return dummy.next
```

A) Time complexity: O(n), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

###### ID146

A:: =============================================  
**Answer**: A

The two-pointer approach has a linear time complexity of O(n). We perform a constant amount of work for each node (moving the pointers and eventually deleting a node). The space complexity is O(1) as we are not using any extra space that scales with the input size, we're simply using two pointers to navigate the existing list.

#### Chapter 5 - Copy List With Random Pointer
#### Chapter 6 - Add Two Numbers
#### Chapter 7 - Linked List Cycle - [Blind]
#### Chapter 8 - Find The Duplicate Number
#### Chapter 9 - LRU Cache
#### Chapter 10 - Merge K Sorted Lists - [Blind]

Q:: =============================================  

##### Merge K Sorted Linked Lists

You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.

Return the **sorted** linked list that is the result of merging all of the individual linked lists.

**Example 1:**

```
Input: lists = [[1,2,4],[1,3,5],[3,6]]

Output: [1,1,2,3,3,4,5,6]
```

**Example 2:**

```
Input: lists = []

Output: []
```

**Example 3:**

```
Input: lists = [[]]

Output: []
```

**Constraints:**

-   `0 <= lists.length <= 1000`
-   `0 <= lists[i].length <= 100`
-   `-1000 <= lists[i][j] <= 1000`

___

What would be a straightforward but not necessarily optimal approach to solve this problem?

A) Sequentially merge the linked lists, starting from the first one

B) Reverse each linked list, and then merge

C) Select the last node from each list and create a new sorted list

D) Randomly pick two lists to merge until one list is left

###### ID147

A:: =============================================  
**Answer**: A

A straightforward approach for this problem would involve sequentially merging the linked lists, starting from the first one. This would involve merging the first two lists, then merging the result with the third list, and so on. While this approach is simple, it may not be the most efficient in terms of time complexity.

Q:: =============================================  

##### Merge K Sorted Linked Lists

You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.

Return the **sorted** linked list that is the result of merging all of the individual linked lists.

**Example 1:**

```
Input: lists = [[1,2,4],[1,3,5],[3,6]]

Output: [1,1,2,3,3,4,5,6]
```

**Example 2:**

```
Input: lists = []

Output: []
```

**Example 3:**

```
Input: lists = [[]]

Output: []
```

**Constraints:**

-   `0 <= lists.length <= 1000`
-   `0 <= lists[i].length <= 100`
-   `-1000 <= lists[i][j] <= 1000`

___

What would be the time complexity of the solution where you merge the linked lists one by one into the first linked list? Assume `n` is the total number of nodes, and `k` is the number of linked lists.

A) O(n)

B) O(n log n)

C) O(n^2)

D) O(kn)

###### ID148

A:: =============================================  
**Answer**: D

When you merge two linked lists, the time complexity is proportional to the total number of nodes in the two lists. If you merge the linked lists one by one, you'll end up with a time complexity of O(kn) because each merge operation can potentially traverse all n nodes, and this operation is repeated k times.

Q:: =============================================  

##### Merge K Sorted Linked Lists

You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.

Return the **sorted** linked list that is the result of merging all of the individual linked lists.

**Example 1:**

```
Input: lists = [[1,2,4],[1,3,5],[3,6]]

Output: [1,1,2,3,3,4,5,6]
```

**Example 2:**

```
Input: lists = []

Output: []
```

**Example 3:**

```
Input: lists = [[]]

Output: []
```

**Constraints:**

-   `0 <= lists.length <= 1000`
-   `0 <= lists[i].length <= 100`
-   `-1000 <= lists[i][j] <= 1000`

___

Given that all individual linked lists are already sorted, how can you take advantage of this to improve the time complexity?

A) By using a sorting algorithm that is more efficient on nearly sorted lists

B) By using a two-pointer technique to find pairs of nodes that sum to a target

C) By merging the linked lists two at a time

D) By using a priority queue to select the next smallest node

###### ID149

A:: =============================================  
**Answer**: D

Since all individual linked lists are sorted, you can use a priority queue (also known as a min-heap) to efficiently select the next smallest node from the heads of all the linked lists.

Q:: =============================================  

##### Merge K Sorted Linked Lists

You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.

Return the **sorted** linked list that is the result of merging all of the individual linked lists.

**Example 1:**

```
Input: lists = [[1,2,4],[1,3,5],[3,6]]

Output: [1,1,2,3,3,4,5,6]
```

**Example 2:**

```
Input: lists = []

Output: []
```

**Example 3:**

```
Input: lists = [[]]

Output: []
```

**Constraints:**

-   `0 <= lists.length <= 1000`
-   `0 <= lists[i].length <= 100`
-   `-1000 <= lists[i][j] <= 1000`

___

If you use a priority queue to keep track of the smallest node in each linked list, what would be the time complexity of inserting an element into the queue?

A) O(1)

B) O(log k)

C) O(k)

D) O(n)

###### ID150

A:: =============================================  
**Answer**: B

The time complexity of inserting an element into a priority queue (or min-heap) is O(log k), where k is the number of linked lists (or the current size of the heap). Each insert operation might need to restructure the heap to maintain its properties, which takes logarithmic time.

Q:: =============================================  

##### Merge K Sorted Linked Lists

You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.

Return the **sorted** linked list that is the result of merging all of the individual linked lists.

**Example 1:**

```
Input: lists = [[1,2,4],[1,3,5],[3,6]]

Output: [1,1,2,3,3,4,5,6]
```

**Example 2:**

```
Input: lists = []

Output: []
```

**Example 3:**

```
Input: lists = [[]]

Output: []
```

**Constraints:**

-   `0 <= lists.length <= 1000`
-   `0 <= lists[i].length <= 100`
-   `-1000 <= lists[i][j] <= 1000`

___

If you use a priority queue to select the smallest node from each linked list, what would be the time complexity for merging all the linked lists into one sorted list?

A) O(n log n)

B) O(n log k)

C) O(k log n)

D) O(n)

###### ID151

A:: =============================================  
**Answer**: B

If you use a priority queue, you are essentially removing the smallest element (head of some linked list) and then adding the next element from the same list. Each operation (insert/remove) would take O(log k) time. Since we are doing these operations for all 'n' nodes, the total time complexity would be O(n log k).

Q:: =============================================  

##### Merge K Sorted Linked Lists

You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.

Return the **sorted** linked list that is the result of merging all of the individual linked lists.

**Example 1:**

```
Input: lists = [[1,2,4],[1,3,5],[3,6]]

Output: [1,1,2,3,3,4,5,6]
```

**Example 2:**

```
Input: lists = []

Output: []
```

**Example 3:**

```
Input: lists = [[]]

Output: []
```

**Constraints:**

-   `0 <= lists.length <= 1000`
-   `0 <= lists[i].length <= 100`
-   `-1000 <= lists[i][j] <= 1000`

___

If you use a priority queue to select the smallest node from each linked list, what would be the space complexity for merging all the linked lists into one sorted list?

A) O(1)

B) O(n)

C) O(k)

D) O(n + k)

###### ID152

A:: =============================================  
**Answer**: C

In this case, the space complexity is O(k) because at any point, you only need to store the head nodes of each linked list in the priority queue. Here, k is the number of linked lists.

#### Chapter 11 - Reverse Nodes In K Group

### Part VII - Trees

#### Chapter 1 - Invert Binary Tree - [Blind]

Q:: =============================================  

##### Invert a Binary Tree

You are given the root of a binary tree `root`. Invert the binary tree and return its root.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ac124ee6-207f-41f6-3aaa-dfb35815f200/public)

```
Input: root = [1,2,3,4,5,6,7]

Output: [1,3,2,7,6,5,4]
```

**Example 2:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e39e8d4f-9946-4f99-ee3d-0d4df08d4d00/public)

```
Input: root = [3,2,1]

Output: [3,1,2]
```

**Example 3:**

```
Input: root = []

Output: []
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

What does this binary tree look like after it has been inverted? 

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/3632af86-32d0-4224-fd47-1a9f311a8f00/public)

A) ![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/00d65115-0868-4312-8050-b1b039ecda00/public)

B) ![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/22600c7e-0bb6-4762-9959-370044446b00/public)

###### ID153

A:: =============================================  
**Answer**: B

Inverting a binary tree means to make all left child nodes become right child nodes and vice versa. This is effectively the same as swapping the left and right child nodes for every node in the tree.

Q:: =============================================  

##### Invert a Binary Tree

You are given the root of a binary tree `root`. Invert the binary tree and return its root.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ac124ee6-207f-41f6-3aaa-dfb35815f200/public)

```
Input: root = [1,2,3,4,5,6,7]

Output: [1,3,2,7,6,5,4]
```

**Example 2:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e39e8d4f-9946-4f99-ee3d-0d4df08d4d00/public)

```
Input: root = [3,2,1]

Output: [3,1,2]
```

**Example 3:**

```
Input: root = []

Output: []
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

Which tree traversal can be used to solve this problem?

A) Depth-First Search (DFS)

B) Breadth-First Search (BFS)

C) Neither DFS nor BFS

D) Both DFS and BFS

###### ID154

A:: =============================================  
**Answer**: D

Both Depth-First Search (DFS) and Breadth-First Search (BFS) could be used to solve this problem. Both methods would work because the order in which we visit the nodes doesn't matter in this problem, as long as every node’s children are swapped.

Q:: =============================================  

##### Invert a Binary Tree

You are given the root of a binary tree `root`. Invert the binary tree and return its root.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ac124ee6-207f-41f6-3aaa-dfb35815f200/public)

```
Input: root = [1,2,3,4,5,6,7]

Output: [1,3,2,7,6,5,4]
```

**Example 2:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e39e8d4f-9946-4f99-ee3d-0d4df08d4d00/public)

```
Input: root = [3,2,1]

Output: [3,1,2]
```

**Example 3:**

```
Input: root = []

Output: []
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

If we were to use a recursive DFS approach to solve this problem, what would be the base case?

A) When we encounter a null node

B) When we encounter a leaf node

C) Neither A nor B

D) Either one of A or B would be a sufficient base case

###### ID155

A:: =============================================  
**Answer**: D

The base case for a recursive approach to this problem could be when we encounter a null node. This is because we cannot swap the left and right children of a null node. But an alternative base case could be when we encounter a leaf node, since the node doesn’t have any children to swap.

Q:: =============================================  

##### Invert a Binary Tree

You are given the root of a binary tree `root`. Invert the binary tree and return its root.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ac124ee6-207f-41f6-3aaa-dfb35815f200/public)

```
Input: root = [1,2,3,4,5,6,7]

Output: [1,3,2,7,6,5,4]
```

**Example 2:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e39e8d4f-9946-4f99-ee3d-0d4df08d4d00/public)

```
Input: root = [3,2,1]

Output: [3,1,2]
```

**Example 3:**

```
Input: root = []

Output: []
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

With the recursive approach in mind, how would we invert a binary tree?

A) Swap the left and right children of the root node, then recursively invert the left and right subtrees

B) Recursively invert the left subtree, then the right subtree, then swap the left and right children of the root node

C) Recursively invert the right subtree, then the left subtree, then swap the left and right children of the root node

D) Any of the above.

###### ID156

A:: =============================================  
**Answer**: D

The recursive approach to inverting a binary tree would involve swapping the left and right children of the root node, as well as recursively inverting the left subtree, and the right subtree. But it doesn’t matter the order we execute these operations because none of them interfere with each other.

Q:: =============================================  

##### Invert a Binary Tree

You are given the root of a binary tree `root`. Invert the binary tree and return its root.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ac124ee6-207f-41f6-3aaa-dfb35815f200/public)

```
Input: root = [1,2,3,4,5,6,7]

Output: [1,3,2,7,6,5,4]
```

**Example 2:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e39e8d4f-9946-4f99-ee3d-0d4df08d4d00/public)

```
Input: root = [3,2,1]

Output: [3,1,2]
```

**Example 3:**

```
Input: root = []

Output: []
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

What are the time and space complexities of the recursive solution to this problem? Assume the binary tree is balanced and contains n nodes.

A) Time complexity: O(1), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(log n)

C) Time complexity: O(n), Space complexity: O(n)

D) Time complexity: O(n^2), Space complexity: O(n^2)

###### ID157

A:: =============================================  
**Answer**: B

The time complexity of the recursive solution is O(n), where n is the number of nodes in the tree. This is because we have to visit every node in the tree once in order to swap its left and right children. The space complexity is O(log n) in the average case, because the maximum amount of space we'll need corresponds to the depth of the tree, which in a balanced binary tree is log(n). In the worst case scenario (a completely unbalanced tree), it could be O(n), but generally, we consider the average case for space complexity in recursive solutions.

#### Chapter 2 - Maximum Depth of Binary Tree - [Blind]

Q:: =============================================  

##### Depth of Binary Tree

Given the `root` of a binary tree, return its **depth**.

The **depth** of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5ea6da77-7e43-43e0-dd9d-e879ca0b1600/public)

```
Input: root = [1,2,3,null,null,4]

Output: 3
```

**Example 2:**

```
Input: root = []

Output: 0
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

What is the maximum depth of a binary tree with a single node?

A) 0

B) 1

C) 2

D) The depth is undefined for a single node tree.

###### ID158

A:: =============================================  
**Answer**: B

A tree with a single node (which is also the root) has a maximum depth of 1. The depth of a tree is the number of nodes along the longest path from the root node down to the farthest leaf node. Here, that path consists only of the root node itself.

Q:: =============================================  

##### Depth of Binary Tree

Given the `root` of a binary tree, return its **depth**.

The **depth** of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5ea6da77-7e43-43e0-dd9d-e879ca0b1600/public)

```
Input: root = [1,2,3,null,null,4]

Output: 3
```

**Example 2:**

```
Input: root = []

Output: 0
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

Which tree traversal technique could be utilized to find the maximum depth of a binary tree?

A) Depth-First Search (DFS)

B) Breadth-First Search (BFS)

C) Both DFS and BFS

D) Neither DFS nor BFS

###### ID159

A:: =============================================  
**Answer**: C

Both DFS and BFS can be used to solve this problem. Both methods would work because they both can explore the full depth of the tree. There is no inherent efficiency gain in this particular problem for DFS over BFS or vice versa, as we would need to traverse all nodes to ensure we've found the maximum depth.

Q:: =============================================  

##### Depth of Binary Tree

Given the `root` of a binary tree, return its **depth**.

The **depth** of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5ea6da77-7e43-43e0-dd9d-e879ca0b1600/public)

```
Input: root = [1,2,3,null,null,4]

Output: 3
```

**Example 2:**

```
Input: root = []

Output: 0
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

If we use a recursive DFS approach to solve this problem, what would be a sensible base case?

A) When we encounter a null node

B) When we encounter a node with only one child

C) There is no need for a base case

###### ID160

A:: =============================================  
**Answer**: A

A good base case for this problem could be when we encounter a null node. When we reach a null node, it indicates we've traversed all the way down one path of the tree and we've hit a leaf node in the previous step.

Q:: =============================================  

##### Depth of Binary Tree

Given the `root` of a binary tree, return its **depth**.

The **depth** of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5ea6da77-7e43-43e0-dd9d-e879ca0b1600/public)

```
Input: root = [1,2,3,null,null,4]

Output: 3
```

**Example 2:**

```
Input: root = []

Output: 0
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

Considering the recursive approach, how would we compute the maximum depth of a binary tree?

A) Compare the depth of the left subtree and the right subtree, then return the maximum plus 1

B) Add the depths of the left subtree and the right subtree

C) Return the depth of the left subtree if it is non-null, else return the depth of the right subtree

###### ID161

A:: =============================================  
**Answer**: A

The maximum depth of a binary tree is one more than the maximum of the depths of its left and right subtrees. So, we recursively compute the maximum depths of the left and right subtrees, and the maximum depth of the tree is the maximum of these two depths plus 1.

Q:: =============================================  

##### Depth of Binary Tree

Given the `root` of a binary tree, return its **depth**.

The **depth** of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

**Example 1:**

![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5ea6da77-7e43-43e0-dd9d-e879ca0b1600/public)

```
Input: root = [1,2,3,null,null,4]

Output: 3
```

**Example 2:**

```
Input: root = []

Output: 0
```

**Constraints:**

-   `0 <= The number of nodes in the tree <= 100`.
-   `-100 <= Node.val <= 100`

___

Given the below Python function to solve the problem, what are the time and space complexities? Assume the binary tree is balanced.

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0

        return 1 + max(
            self.maxDepth(root.left),
            self.maxDepth(root.right)
        )
```

A) Time complexity: O(1), Space complexity: O(1)

B) Time complexity: O(n), Space complexity: O(log n)

C) Time complexity: O(n), Space complexity: O(n)

###### ID162

A:: =============================================  
**Answer**: B

The time complexity of the recursive solution is O(n), where n is the number of nodes in the tree. We visit each node once, so the time complexity is proportional to the size of the tree. The space complexity is O(log n) in the average case (for a balanced tree), as we only need to store information up to the depth of the tree, which is log(n) for a balanced binary tree. In the worst case (a completely unbalanced tree), the space complexity could be O(n).

#### Chapter 3 - Diameter of Binary Tree
#### Chapter 4 - Balanced Binary Tree
#### Chapter 5 - Same Tree - [Blind]

Q:: =============================================  

##### Same Tree

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1168b33f-0718-49d2-3991-d2e92b1ae500/public)

```
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/753a6eeb-7153-4c61-096f-438a4ccd9400/public)

```
Input: p = [1,2], q = [1,null,2]
Output: false
```

**Example 3:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/76cda15a-858b-4702-d319-badd1fb6da00/public)

```
Input: p = [1,2,1], q = [1,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in both trees is in the range `[0, 100]`.
-   `10^4 <= Node.val <= 10^4`

___

Which of the following factors would be considered when determining if two binary trees are the same?

A) The structure of the trees.

B) The values of the nodes in the trees.

C) Both A and B.

###### ID163

A:: =============================================  
**Answer**: C

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

Q:: =============================================  

##### Same Tree

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1168b33f-0718-49d2-3991-d2e92b1ae500/public)

```
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/753a6eeb-7153-4c61-096f-438a4ccd9400/public)

```
Input: p = [1,2], q = [1,null,2]
Output: false
```

**Example 3:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/76cda15a-858b-4702-d319-badd1fb6da00/public)

```
Input: p = [1,2,1], q = [1,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in both trees is in the range `[0, 100]`.
-   `10^4 <= Node.val <= 10^4`

___

What would be a base case to check if two subtrees `p` and `q` are the same in the recursive approach to this problem?

A) When both p and q are null.

B) When either p or q is null.

###### ID164

A:: =============================================  
**Answer**: A

The base case for this problem is when both nodes are null. If both nodes are null, then we can say they are the same.

Q:: =============================================  

##### Same Tree

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1168b33f-0718-49d2-3991-d2e92b1ae500/public)

```
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/753a6eeb-7153-4c61-096f-438a4ccd9400/public)

```
Input: p = [1,2], q = [1,null,2]
Output: false
```

**Example 3:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/76cda15a-858b-4702-d319-badd1fb6da00/public)

```
Input: p = [1,2,1], q = [1,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in both trees is in the range `[0, 100]`.
-   `10^4 <= Node.val <= 10^4`

___

What would be a base case to check if two subtrees `p` and `q` are _not_ the same in the recursive approach to this problem?

A) When either p or q is null, but not both.

B) When the values of p and q differ.

C) Both A and B.

###### ID165

A:: =============================================  
**Answer**: C

If only one of them is null, they are not the same. Similarly, if the values of p and q are different, they are not the same.

Q:: =============================================  

##### Same Tree

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1168b33f-0718-49d2-3991-d2e92b1ae500/public)

```
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/753a6eeb-7153-4c61-096f-438a4ccd9400/public)

```
Input: p = [1,2], q = [1,null,2]
Output: false
```

**Example 3:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/76cda15a-858b-4702-d319-badd1fb6da00/public)

```
Input: p = [1,2,1], q = [1,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in both trees is in the range `[0, 100]`.
-   `10^4 <= Node.val <= 10^4`

___

If the base case does _not_ hold, what should be checked to confirm whether the two subtrees are the same?

A) Compare the values of the nodes and check if the left and right subtrees of the nodes are the same.

B) Check if the left subtree of one node is the same as the right subtree of the other node.

C) Compare only the values of the nodes.

###### ID166

A:: =============================================  
**Answer**: A

If both nodes are not null, we need to check if the values of the nodes are the same and if the left subtree of the first node is the same as the left subtree of the second node, and the same for the right subtrees.

Q:: =============================================  

##### Same Tree

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1168b33f-0718-49d2-3991-d2e92b1ae500/public)

```
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/753a6eeb-7153-4c61-096f-438a4ccd9400/public)

```
Input: p = [1,2], q = [1,null,2]
Output: false
```

**Example 3:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/76cda15a-858b-4702-d319-badd1fb6da00/public)

```
Input: p = [1,2,1], q = [1,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in both trees is in the range `[0, 100]`.
-   `10^4 <= Node.val <= 10^4`

___

Considering the below Python function to solve the problem, where `n` and `m` are the number of nodes in the first and second tree respectively, and `h1` and `h2` are the heights of the first and second tree respectively. What are the time and space complexities?

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        if not p or not q or p.val != q.val:
            return False
        return (
            self.isSameTree(p.left, q.left) and
            self.isSameTree(p.right, q.right)
        )
```

A) Time complexity: O(1), Space complexity: O(1)

B) Time complexity: O(min(n, m)), Space complexity: O(min(h1, h2))

C) Time complexity: O(max(n, m)), Space complexity: O(max(h1, h2))

###### ID167

A:: =============================================  
**Answer**: B

The time complexity of the recursive solution is O(min(n, m)), where n and m are the number of nodes in the first and second tree, respectively. We stop as soon as we find a difference between the trees, which could be at a size smaller than the larger tree. The space complexity is O(min(h1, h2)) in the worst case, which is determined by the maximum amount of space required by the recursive stack. The worst-case occurs in situations where the tree is completely unbalanced (e.g., each node only contains a left / right child node), leading to a maximum recursion depth of h (height of the tree). However, because we are comparing two trees, the maximum recursion depth would be the minimum height of the two trees.

#### Chapter 6 - Subtree of Another Tree - [Blind]

Q:: =============================================  

##### Subtree of Another Tree

Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.

A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/52b41f82-273f-4b31-83ea-f6895eb79200/public)

```
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fc852005-42e7-434d-3514-e5c834361b00/public)

```
Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in the `root` tree is in the range `[1, 2000]`.
-   The number of nodes in the `subRoot` tree is in the range `[1, 1000]`.
-   `10^4 <= root.val <= 10^4`
-   `10^4 <= subRoot.val <= 10^4`

___

What is a subtree in the context of binary trees?

A) Any node along with all its descendants in the original tree.

B) A tree that only consists of leaf nodes of the original tree.

C) A smaller tree that has the same root node as the original tree.

###### ID168

A:: =============================================  
**Answer**: A

A subtree of a binary tree is a tree that consists of a node in the original tree and all of this node's descendants. The tree could also be considered a subtree of itself.

Q:: =============================================  

##### Subtree of Another Tree

Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.

A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/52b41f82-273f-4b31-83ea-f6895eb79200/public)

```
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fc852005-42e7-434d-3514-e5c834361b00/public)

```
Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in the `root` tree is in the range `[1, 2000]`.
-   The number of nodes in the `subRoot` tree is in the range `[1, 1000]`.
-   `10^4 <= root.val <= 10^4`
-   `10^4 <= subRoot.val <= 10^4`

___

Considering the problem of finding a subtree within a tree which tree traversal technique could be utilized?

A) Depth-First Search (DFS)

B) Breadth-First Search (BFS)

C) Both DFS and BFS

###### ID169

A:: =============================================  
**Answer**: C

Both DFS and BFS can be used to solve this problem. These tree traversal techniques allow us to check each node in the root tree and compare it with the subRoot tree.

Q:: =============================================  

##### Subtree of Another Tree

Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.

A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/52b41f82-273f-4b31-83ea-f6895eb79200/public)

```
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fc852005-42e7-434d-3514-e5c834361b00/public)

```
Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in the `root` tree is in the range `[1, 2000]`.
-   The number of nodes in the `subRoot` tree is in the range `[1, 1000]`.
-   `10^4 <= root.val <= 10^4`
-   `10^4 <= subRoot.val <= 10^4`

___

When trying to determine if a `subRoot` is a subtree of `root`, which kind of helper function might be beneficial to have?

A) A function to calculate the height of root and subroot

B) A function to compare two trees and check if they are identical

###### ID170

A:: =============================================  
**Answer**: B

A helper function that compares two trees to check if they are identical can be useful. We can use it every time we find a node in `root` that is the same as the root of `subRoot`. We then compare the entire structure starting from this node with `subRoot` using this helper function.

Q:: =============================================  

##### Subtree of Another Tree

Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.

A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/52b41f82-273f-4b31-83ea-f6895eb79200/public)

```
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fc852005-42e7-434d-3514-e5c834361b00/public)

```
Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in the `root` tree is in the range `[1, 2000]`.
-   The number of nodes in the `subRoot` tree is in the range `[1, 1000]`.
-   `10^4 <= root.val <= 10^4`
-   `10^4 <= subRoot.val <= 10^4`

___

Given a tree `root` and a `subRoot`, if we find a node in `root` with the same value as the root of `subRoot`, what should be our next step?

A) Return true as we have found subroot in root

B) Check if the subtree at the found node in root is identical to subroot

C) Check if the left child of the found node in root is identical to the left child of subroot

###### ID171

A:: =============================================  
**Answer**: B

Just finding a node with the same value does not confirm the presence of the subtree. We need to verify if the entire structure of the subtree starting at this node is identical to subroot.

Q:: =============================================  

##### Subtree of Another Tree

Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.

A subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/52b41f82-273f-4b31-83ea-f6895eb79200/public)

```
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fc852005-42e7-434d-3514-e5c834361b00/public)

```
Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
```

**Constraints:**

-   The number of nodes in the `root` tree is in the range `[1, 2000]`.
-   The number of nodes in the `subRoot` tree is in the range `[1, 1000]`.
-   `10^4 <= root.val <= 10^4`
-   `10^4 <= subRoot.val <= 10^4`

___

Given the below Python solution to solve the problem, what are the time and space complexities of the `isSubtree` function? Assume the tree may not be balanced.

```python
class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -> bool:
        if not t: return True
        if not s: return False

        if self.sameTree(s, t):
            return True
        return (self.isSubtree(s.left, t) or
                self.isSubtree(s.right, t))

    def sameTree(self, s, t):
        if not s and not t:
            return True
        if s and t and s.val == t.val:
            return (self.sameTree(s.left, t.left) and
                    self.sameTree(s.right, t.right))
        return False
```

A) Time complexity: O(mn), Space complexity: O(n)

B) Time complexity: O(m+n), Space complexity: O(m+n)

C) Time complexity: O(n), Space complexity: O(log n)

###### ID172

A:: =============================================  
**Answer**: A

The time complexity of this solution is O(mn), where m and n are the number of nodes in root and subroot, respectively. This is because, in the worst case, for each node in root, we may have to traverse all nodes in subroot to check if they form the same tree (i.e., in the sameTree function). The space complexity is O(n) in the worst case (for an unbalanced tree) because of the potential stack space needed for the DFS traversal. However, if the tree is balanced, the space complexity would be O(log n) as the maximum depth of the tree (and thus the maximum stack size) would be log n.

#### Chapter 7 - Lowest Common Ancestor of a Binary Search Tree - [Blind]

Q:: =============================================  

##### Lowest Common Ancestor of a Binary Search Tree

Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6a944957-3b32-4eab-37ab-48b701a70000/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fe9f02bd-c21c-4dac-d6c5-1962775c0800/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

**Constraints:**

-   The number of nodes in the tree is in the range `[2, 10^5]`.
-   `10^9 <= Node.val <= 10^9`
-   All `Node.val` are **unique**.
-   `p != q`
-   `p` and `q` will exist in the BST.

___

In a BST, for any given node `n`, which of the following is true?

A) All nodes in the left subtree of n are greater than n, and all nodes in the right subtree are less than n.

B) All nodes in the left subtree of n are less than n, and all nodes in the right subtree are greater than n.

###### ID173

A:: =============================================  
**Answer**: B

By definition, in a Binary Search Tree, for any given node n, all nodes in the left subtree of n are less than n, and all nodes in the right subtree are greater than n.

Q:: =============================================  

##### Lowest Common Ancestor of a Binary Search Tree

Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6a944957-3b32-4eab-37ab-48b701a70000/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fe9f02bd-c21c-4dac-d6c5-1962775c0800/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

**Constraints:**

-   The number of nodes in the tree is in the range `[2, 10^5]`.
-   `10^9 <= Node.val <= 10^9`
-   All `Node.val` are **unique**.
-   `p != q`
-   `p` and `q` will exist in the BST.

___

If `p` and `q` are both less than the root, where should we search for their `LCA` in a BST?

A) In the root's right subtree.

B) In the root's left subtree.

C) In both the root's left and right subtrees.

D) Only in the root itself.

###### ID174

A:: =============================================  
**Answer**: B

Given the properties of a BST, if both p and q are less than the root, then their LCA must be in the root's left subtree.

Q:: =============================================  

##### Lowest Common Ancestor of a Binary Search Tree

Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6a944957-3b32-4eab-37ab-48b701a70000/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fe9f02bd-c21c-4dac-d6c5-1962775c0800/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

**Constraints:**

-   The number of nodes in the tree is in the range `[2, 10^5]`.
-   `10^9 <= Node.val <= 10^9`
-   All `Node.val` are **unique**.
-   `p != q`
-   `p` and `q` will exist in the BST.

___

If p and q are on different sides of the root (i.e., one is less than the root and the other is greater), where is their LCA?

A) It is the root.

B) It is in the root's left subtree.

C) It is in the root's right subtree.

###### ID175

A:: =============================================  
**Answer**: A

Given the properties of a BST, if p and q are on different sides of the root, the root is the LCA. This is because all values in the left subtree are less than the root, and all values in the right subtree are greater.

Q:: =============================================  

##### Lowest Common Ancestor of a Binary Search Tree

Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6a944957-3b32-4eab-37ab-48b701a70000/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fe9f02bd-c21c-4dac-d6c5-1962775c0800/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

**Constraints:**

-   The number of nodes in the tree is in the range `[2, 10^5]`.
-   `10^9 <= Node.val <= 10^9`
-   All `Node.val` are **unique**.
-   `p != q`
-   `p` and `q` will exist in the BST.

___

If the `cur` node in the search is either **`p`** or **`q`**, then what will be the LCA?

A) The LCA will be the root node.

B) The LCA will be p or q, whichever is the current node.

C) The LCA will be the other node that is not the current node.

###### ID176

A:: =============================================  
**Answer**: B

Given the property of a BST and the definition of LCA, if the current node is either **`p`** or **`q`**, then this node will be the LCA. This is because a node can be a descendant of itself, and this node will be the lowest common node that has both **`p`** and **`q`** as descendants.

Q:: =============================================  

##### Lowest Common Ancestor of a Binary Search Tree

Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes `p` and `q` as the lowest node in `T` that has both `p` and `q` as descendants (where we allow **a node to be a descendant of itself**).”

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6a944957-3b32-4eab-37ab-48b701a70000/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fe9f02bd-c21c-4dac-d6c5-1962775c0800/public)

```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

**Example 3:**

```
Input: root = [2,1], p = 2, q = 1
Output: 2
```

**Constraints:**

-   The number of nodes in the tree is in the range `[2, 10^5]`.
-   `10^9 <= Node.val <= 10^9`
-   All `Node.val` are **unique**.
-   `p != q`
-   `p` and `q` will exist in the BST.

___

Given the below Python function to solve the problem, what are the time and space complexities? Assume there are `n` nodes in the tree and the tree is balanced.

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        cur = root

        while cur:
            if p.val > cur.val and q.val > cur.val:
                cur = cur.right
            elif p.val < cur.val and q.val < cur.val:
                cur = cur.left
            else:
                return cur
```

A) Time complexity: O(log n), Space complexity: O(log n)

B) Time complexity: O(log n), Space complexity: O(1)

C) Time complexity: O(n), Space complexity: O(1)

###### ID177

A:: =============================================  
**Answer**: B

The time complexity of this solution is O(log n), where n is the number of nodes in the tree. This is because we are essentially performing a binary search, narrowing down our search to either the left or right subtrees each time, which gives a log(n) time complexity. The space complexity is O(1), because this approach only uses a constant amount of space and doesn't depend on the size of the input tree.

#### Chapter 8 - Lowest Common Ancestor of a Binary Tree - [Blind] - [Ex] - [ComEx]
#### Chapter 9 - Binary Tree Level Order Traversal - [Blind]

Q:: =============================================  

##### Binary Tree Level Order Traversal

Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e9bf9a5e-fd98-48e2-0967-a1d246f32100/public)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

**Constraints:**

-   The number of nodes in the tree is in the range `[0, 2000]`.
-   `1000 <= Node.val <= 1000`

___

How would you traverse a binary tree in a level order fashion?

A) By using Depth-First Search (DFS)

B) By using Breadth-First Search (BFS)

###### ID178

A:: =============================================  
**Answer**: B

Level order traversal of a binary tree is also known as Breadth-First Search (BFS) traversal.

Q:: =============================================  

##### Binary Tree Level Order Traversal

Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e9bf9a5e-fd98-48e2-0967-a1d246f32100/public)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

**Constraints:**

-   The number of nodes in the tree is in the range `[0, 2000]`.
-   `1000 <= Node.val <= 1000`

___

What data structure is typically used for BFS traversal in a binary tree?

A) Stack

B) Queue

C) LinkedList

D) Array

###### ID179

A:: =============================================  
**Answer**: B

BFS typically uses a Queue data structure. As you visit a node, you would add its children to the queue, then move on to the next node in the queue, continually adding their children. This way, you naturally visit the nodes level by level.

Q:: =============================================  

##### Binary Tree Level Order Traversal

Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e9bf9a5e-fd98-48e2-0967-a1d246f32100/public)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

**Constraints:**

-   The number of nodes in the tree is in the range `[0, 2000]`.
-   `1000 <= Node.val <= 1000`

___

For level order traversal, when do we start a new level in the output?

A) When we have visited all the nodes in the current level

B) When the tree has no more levels to traverse

###### ID180

A:: =============================================  
**Answer**: A

We start a new level in the output when we have visited all the nodes in the current level. This can be tracked by recording the size of the queue before starting a new level, and then dequeueing that many nodes for the current level.

Q:: =============================================  

##### Binary Tree Level Order Traversal

Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e9bf9a5e-fd98-48e2-0967-a1d246f32100/public)

```
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]
```

**Example 2:**

```
Input: root = [1]
Output: [[1]]
```

**Example 3:**

```
Input: root = []
Output: []
```

**Constraints:**

-   The number of nodes in the tree is in the range `[0, 2000]`.
-   `1000 <= Node.val <= 1000`

___

Given the below Python function to solve the problem, what are the time and space complexities? Assume there are `n` nodes in the tree.

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        q = collections.deque()
        if root: q.append(root)

        while q:
            val = []

            for i in range(len(q)):
                node = q.popleft()
                val.append(node.val)
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
            res.append(val)
        return res
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n^2), Space complexity: O(n)

C) Time complexity: O(n), Space complexity: O(log n)

###### ID181

A:: =============================================  
**Answer**: A

The time complexity of a level order traversal (or BFS) is O(n), where n is the number of nodes in the tree, as we need to visit every node. The space complexity is also O(n), as we need to store every node in the queue in the worst-case scenario (consider a full binary tree's last level).

#### Chapter 10 - Binary Tree Right Side View
#### Chapter 11 - Count Good Nodes In Binary Tree
#### Chapter 12 - Validate Binary Search Tree - [Blind]
#### Chapter 13 - Kth Smallest Element In a Bst - [Blind]
#### Chapter 14 - Construct Binary Tree From Preorder And Inorder Traversal - [Blind]
#### Chapter 15 - Binary Tree Maximum Path Sum - [Blind]
#### Chapter 16 - Serialize And Deserialize Binary Tree
#### Chapter 17 - Serialize and Deserialize BST - [Blind] - [Ex]

### Part VIII - Tries

#### Chapter 1 - Implement Trie Prefix Tree - [Blind]
#### Chapter 2 - Design Add And Search Words Data Structure - [Blind]
#### Chapter 3 - Word Search II - [Blind]

### Part IX - Backtracking

#### Chapter 1 - Subsets
#### Chapter 2 - Combination Sum - [Blind]

Q:: =============================================  

##### Combination Sum

Given an array of **distinct** integers `candidates` and a target integer `target`, return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`. You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the  
frequency  
of at least one of the chosen numbers is different.

The test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.

**Example 1:**

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
```

___

In order to find all distinct combinations that sum to the target, can we solve this recursively using a decision tree?

A) Yes

B) No

###### ID182

A:: =============================================  
**Answer**: A

Yes, a recursive approach using a decision tree is a suitable method for this problem. Since we must generate each combination, we can not do better than a brute force approach.

Q:: =============================================  

##### Combination Sum

Given an array of **distinct** integers `candidates` and a target integer `target`, return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`. You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the  
frequency  
of at least one of the chosen numbers is different.

The test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.

**Example 1:**

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
```

___

Other than when our sum == target, when should we stop recursing?

A) When the sum is greater than the target.

B) When we reach the end of the candidates array.

C) When we have exhausted all possible combinations.

D) Both A and B.

###### ID183

A:: =============================================  
**Answer**: D

We should stop recursing when the sum is greater than the target or when we reach the end of the candidates array. In the former case, any further recursion will only increase the sum beyond the target. In the latter case, we've exhausted all possible combinations.

Q:: =============================================  

##### Combination Sum

Given an array of **distinct** integers `candidates` and a target integer `target`, return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`. You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the  
frequency  
of at least one of the chosen numbers is different.

The test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.

**Example 1:**

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
```

___

In our decision tree, for each element in the array we will create a branch, where we choose to either include that element only once or skip it entirely. Will this find all combinations?

A) Yes

B) No

###### ID184

A:: =============================================  
**Answer**: B

No, this won't find all combinations. Because the same number may be chosen from candidates an unlimited number of times, we need to consider including each element more than once.

Q:: =============================================  

##### Combination Sum

Given an array of **distinct** integers `candidates` and a target integer `target`, return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`. You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the  
frequency  
of at least one of the chosen numbers is different.

The test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.

**Example 1:**

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
```

___

In our decision tree, for each element in the array we will create a branch, where we choose to either include that element one or more times, or skip it entirely. Will this find all combinations?

A) Yes

B) No

###### ID185

A:: =============================================  
**Answer**: A

Yes, this will find all combinations. By including each element one or more times, we cover all potential combinations that sum up to the target.

Q:: =============================================  

##### Combination Sum

Given an array of **distinct** integers `candidates` and a target integer `target`, return a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`. You may return the combinations in **any order**.

The **same** number may be chosen from `candidates` an unlimited number of times. Two combinations are unique if the  
frequency  
of at least one of the chosen numbers is different.

The test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.

**Example 1:**

```
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
```

___

What is the time complexity of the previous solution?

A) O(2^target)

B) O(2^(target + n))

C) O(n\*target)

D) O(n^2)

###### ID186

A:: =============================================  
**Answer**: B

The time complexity is O(n^(target + n)), where n is the number of candidates and target is the target sum. This is because, in the worst case the height of our tree may be n + target, since we have a level in the tree for each element in the array. If we have a '1' value, we may choose it 'target' number of times to sum up to the target value, further adding to the height. There will be 2 branches for each node in the tree, one to include the element and one to skip it. Thus, the time complexity is O(2^(n + target)).

#### Chapter 3 - Permutations
#### Chapter 4 - Subsets II
#### Chapter 5 - Combination Sum II
#### Chapter 6 - Word Search - [Blind]
#### Chapter 7 - Palindrome Partitioning
#### Chapter 8 - Letter Combinations of a Phone Number
#### Chapter 9 - N Queens

### Part X - Heap / Priority Queue

#### Chapter 1 - Kth Largest Element In a Stream
#### Chapter 2 - Last Stone Weight
#### Chapter 3 - K Closest Points to Origin
#### Chapter 4 - Kth Largest Element In An Array
#### Chapter 5 - Task Scheduler
#### Chapter 6 - Design Twitter
#### Chapter 7 - Find Median From Data Stream - [Blind]

### Part XI - Graphs

#### Chapter 1 - Number of Islands - [Blind]

Q:: =============================================  

##### Number of Islands

Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

___

Which graph algorithm can be used to solve this problem?

A) Depth-first search

B) Breadth-first search

C) Both DFS and BFS

D) Neither

###### ID187

A:: =============================================  
**Answer**: C

Both depth-first search (DFS) and breadth-first search (BFS) can be used to solve this problem. They can both traverse all the connected '1's (land) starting from any given '1', and thus identify an island.

Q:: =============================================  

##### Number of Islands

Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

___

Assume we are solving this by running a recursive depth-first search on each island. Under what conditions (base cases) should we stop recursing in our search algorithm?

A) When all the cells in the grid have been visited.

B) When we reach a visited land cell.

C) When we reach an unvisited land cell.

D) When we reach a water cell, or reach a visited land cell, or go out of bounds.

###### ID188

A:: =============================================  
**Answer**: D

We should stop the recursion in our search algorithm when we reach a water cell ('0'), or reach a cell that has been already visited, or go out of the bounds of the grid. This ensures we only count connected land ('1's) as part of the same island and we don't overcount or go beyond the grid boundaries.

Q:: =============================================  

##### Number of Islands

Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

___

What happens if we don’t mark a piece of land as visited after visiting it?

A) We will get stuck in an infinite recusive call stack (timeout or stackoverflow).

B) We will count the same island multiple times.

C) We may miss counting some of the islands.

###### ID189

A:: =============================================  
**Answer**: A

If we don't mark a piece of land as visited after visiting it, our DFS or BFS traversal will revisit the same cell again and again. This would eventually result in a timeout or stackoverflow error.

Q:: =============================================  

##### Number of Islands

Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

___

What should be our approach to traverse the grid to find the number of islands?

A) Traverse the entire grid and start a DFS or BFS search from each land cell.

B) Traverse the entire grid and start a DFS or BFS search from each visited land cell.

C) Traverse the entire grid and start a DFS or BFS search from each unvisited land cell.

###### ID190

A:: =============================================  
**Answer**: C

We should traverse the entire grid and start a DFS or BFS search from each unvisited land cell. This approach ensures that we cover all islands, as each unvisited '1' we encounter would represent a new island.

Q:: =============================================  

##### Number of Islands

Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

___

What is the time complexity of the solution for this problem?

A) O(m \* n)

B) O(m^2 \* n^2)

C) O(m + n)

D) O(m \* n \* log(m \* n))

###### ID191

A:: =============================================  
**Answer**: A

The time complexity of the solution is O(m \* n), where m and n are the number of rows and columns in the grid, respectively. This is because in the worst-case scenario, we might have to visit all cells in the grid.

Q:: =============================================  

##### Number of Islands

Given an `m x n` 2D binary grid `grid` which represents a map of '1's (land) and '0's (water), return the number of islands.

An **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**

```
Input: grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
Output: 1
```

___

What is the space complexity of the solution for this problem when using DFS?

A) O(m \* n)

B) O(m + n)

C) O(min(m, n))

D) O(max(m, n))

###### ID192

A:: =============================================  
**Answer**: A

The space complexity of the solution when using DFS is O(m \* n), where m and n are the number of rows and columns in the grid, respectively. This is because in the worst-case scenario, the depth of the recursion (the call stack) could be the number of cells in the grid if every cell is land ('1').

#### Chapter 2 - Max Area of Island
#### Chapter 3 - Clone Graph - [Blind]
#### Chapter 4 - Walls And Gates
#### Chapter 5 - Rotting Oranges
#### Chapter 6 - Pacific Atlantic Water Flow - [Blind]
#### Chapter 7 - Surrounded Regions
#### Chapter 8 - Course Schedule - [Blind]
#### Chapter 9 - Course Schedule II
#### Chapter 10 - Graph Valid Tree - [Blind]
#### Chapter 11 - Number of Connected Components In An Undirected Graph - [Blind]
#### Chapter 12 - Redundant Connection
#### Chapter 13 - Word Ladder

### Part XII - 1-D DP

#### Chapter 1 - Climbing Stairs - [Blind]
#### Chapter 2 - Min Cost Climbing Stairs
#### Chapter 3 - House Robber - [Blind]

Q:: =============================================  

##### House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

___

What are the possible decisions to make when robbing houses along the street?

A) Rob every house.

B) Rob only the houses with the maximum amount of money.

C) Rob houses while skipping one or more houses to avoid adjacent houses.

###### ID193

A:: =============================================  
**Answer**: C

The correct decision is to rob houses while skipping one or more houses to avoid adjacent houses. Since the problem statement mentions that adjacent houses cannot be robbed on the same night, the strategy should involve skipping one or more houses.

Q:: =============================================  

##### House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

___

What is the brute-force solution to this problem?

A) Try every possible combination of non-adjacent houses and find the maximum sum.

B) Rob the house with the maximum amount of money, then move on to the next unrobbed house.

C) Rob houses in a strictly increasing order of money.

D) Rob houses in a strictly decreasing order of money.

###### ID194

A:: =============================================  
**Answer**: A

The brute-force solution is to try every possible combination of non-adjacent houses and find the maximum sum. This involves evaluating all possible combinations of houses where no two houses are adjacent.

Q:: =============================================  

##### House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

___

If we implement the brute-force approach using recursion, what will be our decisions as we go through the array?

A) Choice 1 = Rob the current house and go to the next house and continue making decisions. Choice 2 = Skip the current house altogether.

B) Choice 1 = Rob the current house and skip the next house and continue making decisions. Choice 2 = Skip the current house altogether.

###### ID195

A:: =============================================  
**Answer**: B

This ensures that we don't rob two adjacent houses.

Q:: =============================================  

##### House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

___

What is the time complexity of the recursive solution?

A) O(n)

B) O(n^2)

C) O(n^3)

D) O(2^n)

###### ID196

A:: =============================================  
**Answer**: D

The time complexity of the recursive solution is O(2^n). In the worst case, we might end up exploring each possible combination of houses, leading to an exponential time complexity.

Q:: =============================================  

##### House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

___

We want to use memoization to improve the efficiency of the recursive solution. What subproblem should we cache the result of? Assume we start our recursion at the beginning of the array.

A) If we are at index i, the subproblem is the maximum we can rob only from houses that are at or to the right of index i. We can store this in a hashmap or an array by mapping the index to maximum amount.

B) If we are at index i, the subproblem is the maximum we can rob only from houses that are at or to the left of index i. We can store this in a hashmap or an array by mapping the index to maximum amount.

###### ID197

A:: =============================================  
**Answer**: A

If we start at the beginning of the array, each recursive call is a subproblem of the maximum we can rob only from a postfix of the array. The result of a subproblem allows us to solve a slightly larger subproblem.

Q:: =============================================  

##### House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

___

What is the time complexity of the memoization solution?

A) O(n)

B) O(n^2)

C) O(n^3)

D) O(2^n)

###### ID198

A:: =============================================  
**Answer**: A

The time complexity of the memoization solution is O(n), where n is the number of houses. This is because with memoization, we only solve each subproblem once.

Q:: =============================================  

##### House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

___

How can we solve this problem using dynamic programming? Assume we start robbing at the beginning of the array.

A) If we are at index i, the subproblem is the maximum we can rob only from houses that are at or to the right of index i. We can store this in a hashmap or an array after we compute it.

B) If we are at index i, the subproblem is the maximum we can rob only from houses that are at or to the left of index i. We can store this in a hashmap or an array after we compute it.

###### ID199

A:: =============================================  
**Answer**: B

If we start at the beginning of the array, on each iteration we are solving a new subproblem - a prefix of the array. The result of previous subproblems will be used to compute the next one.

Q:: =============================================  

##### House Robber

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```

___

What is the time complexity of the dynamic programming solution?

A) O(n)

B) O(n^2)

C) O(n^3)

D) O(2^n)

###### ID200

A:: =============================================  
**Answer**: A

The time complexity of the dynamic programming solution is O(n), where n is the number of houses. Each subproblem is solved only once and used for future computations, thus leading to a linear time complexity.

#### Chapter 4 - House Robber II - [Blind]
#### Chapter 5 - Longest Palindromic Substring - [Blind]
#### Chapter 6 - Palindromic Substrings - [Blind]
#### Chapter 7 - Decode Ways - [Blind]
#### Chapter 8 - Coin Change - [Blind]
#### Chapter 9 - Maximum Product Subarray - [Blind]
#### Chapter 10 - Word Break - [Blind]
#### Chapter 11 - Longest Increasing Subsequence - [Blind]
#### Chapter 12 - Partition Equal Subset Sum

### Part XIII - Intervals

#### Chapter 1 - Insert Interval - [Blind]

Q:: =============================================  

##### Insert Interval

You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals` _after the insertion_.

**Example 1:**

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:**

```
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^5`
-   `intervals` is sorted by `starti` in **ascending** order.
-   `newInterval.length == 2`
-   `0 <= start <= end <= 10^5`

___

Is it possible that the `newInterval` overlaps with more than one interval in the list?

A) Yes

B) No

###### ID201

A:: =============================================  
**Answer**: A

Yes, it's possible. The `newInterval` might overlap with multiple intervals in the list if its start time is earlier than the end of one interval and its end time is later than the start of another.

Q:: =============================================  

##### Insert Interval

You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals` _after the insertion_.

**Example 1:**

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:**

```
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^5`
-   `intervals` is sorted by `starti` in **ascending** order.
-   `newInterval.length == 2`
-   `0 <= start <= end <= 10^5`

___

As we iterate through the list of intervals, how do we know if the `newInterval` does not overlap with any of the intervals in the remaining portion of the list? (i.e. it does not overlap with the current interval or any subsequent intervals)  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1f41ea61-3124-453d-7545-b5d5168de700/public)

A) If the end of newInterval is less than the start time of the current interval.

B) If the start of newInterval is greater than the end time of the current interval.

C) Both A and B

D) None of the above

###### ID202

A:: =============================================  
**Answer**: A

If the end of newInterval is less than the start time of the current interval, newInterval does not overlap with the current interval or any subsequent intervals because the list is sorted in ascending order by start times.

Q:: =============================================  

##### Insert Interval

You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals` _after the insertion_.

**Example 1:**

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:**

```
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^5`
-   `intervals` is sorted by `starti` in **ascending** order.
-   `newInterval.length == 2`
-   `0 <= start <= end <= 10^5`

___

How do we know if the `newInterval` is entirely to the right of the current interval?

A) If the start of newInterval is greater than the end of the current interval.

B) If the end of newInterval is less than the start of the current interval.

C) Both A and B

D) None of the above

###### ID203

A:: =============================================  
**Answer**: A

If the start of newInterval is greater than the end of the current interval, newInterval is entirely to the right of the current interval.

Q:: =============================================  

##### Insert Interval

You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals` _after the insertion_.

**Example 1:**

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:**

```
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^5`
-   `intervals` is sorted by `starti` in **ascending** order.
-   `newInterval.length == 2`
-   `0 <= start <= end <= 10^5`

___

If the `newInterval` is not entirely to the left, nor entirely to the right of the current interval, does that guarantee it overlaps with the current interval?

A) No

B) Yes

C) Cannot be determined

###### ID204

A:: =============================================  
**Answer**: B

By definition, the newInterval must be overlapping with the current interval. Otherwise, it would be on the left or on the right of the current interval. (Proof by contradiction).

Q:: =============================================  

##### Insert Interval

You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals` _after the insertion_.

**Example 1:**

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:**

```
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^5`
-   `intervals` is sorted by `starti` in **ascending** order.
-   `newInterval.length == 2`
-   `0 <= start <= end <= 10^5`

___

After merging two intervals, what should be the new interval that we attempt to merge with the remaining overlapping intervals?

A) The original newInterval

B) intervals\[i\] BEFORE it was merged with newInterval

C) intervals\[i\] AFTER it was merged with newInterval

###### ID205

A:: =============================================  
**Answer**: C

After merging two intervals, the new interval to attempt merging with the remaining intervals should have the earliest start time and the latest end time among the merged intervals. This ensures that the new interval covers all the values in the merged intervals.

Q:: =============================================  

##### Insert Interval

You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.

Insert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).

Return `intervals` _after the insertion_.

**Example 1:**

```
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
```

**Example 2:**

```
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^5`
-   `intervals` is sorted by `starti` in **ascending** order.
-   `newInterval.length == 2`
-   `0 <= start <= end <= 10^5`

___

To summarize, the below code will optimally solve this problem. What is the overall time complexity and the space complexity? Assume the output counts as additional space.

```python
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        res = []
        for i in range(len(intervals)):
            if newInterval[1] < intervals[i][0]:
                # newInterval doesn't overlap with remaining list
                res.append(newInterval)
                return res + intervals[i:]
            elif newInterval[0] > intervals[i][1]:
                # newInterval is entirely to right of intervals[i]
                res.append(intervals[i])
            else:
                # newInterval overlaps with current interval
                newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]
        res.append(newInterval)
        return res
```

A) Time complexity: O(1), Space complexity: O(n)

B) Time complexity: O(n), Space complexity: O(1)

C) Time complexity: O(n), Space complexity: O(n)

###### ID206

A:: =============================================  
**Answer**: C

The time complexity is O(n) because we may need to check each interval once, and the space complexity is O(n) because in the worst case, if `newInterval` doesn't overlap with any intervals, the output will be a list with the same length as the input plus one additional interval (`newInterval`). We also need some additional space to store the merged intervals during the process, but this does not change the overall linear space complexity.

#### Chapter 2 - Merge Intervals - [Blind]

Q:: =============================================  

##### Merge Intervals

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^4`

___

Given an unsorted list of intervals, in what order should we arrange the intervals to simplify the process of merging overlaps?

A) Sort by the start times of each interval

B) Sort by the lengths of each interval

C) The order doesn't matter

###### ID207

A:: =============================================  
**Answer**: A

Sorting the intervals by their start times helps simplify the process of detecting and merging overlaps. Any overlapping intervals will be adjacent to each other in the sorted list.

Q:: =============================================  

##### Merge Intervals

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^4`

___

After sorting the intervals by start times, how can we determine if two intervals overlap?

A) End of the first interval > Start of the second interval

B) End of the first interval ≥ Start of the second interval

###### ID208

A:: =============================================  
**Answer**: B

If the intervals are sorted by their start times, then the end of the current interval being greater than or equal to the start of the next interval means they overlap.

Q:: =============================================  

##### Merge Intervals

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^4`

___

What should you do when two intervals overlap?

A) Discard one interval and keep the other.

B) Merge the two intervals into a single interval.

C) Split the intervals into smaller non-overlapping intervals.

###### ID209

A:: =============================================  
**Answer**: B

If two intervals overlap, they represent a continuous range of values and should be merged into a single interval.

Q:: =============================================  

##### Merge Intervals

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^4`

___

_After_ sorting the intervals, what is the time complexity of the step where we _only_ merge overlapping intervals?

A) O(n)

B) O(n log n)

C) O(n^2)

###### ID210

A:: =============================================  
**Answer**: A

Once the intervals are sorted, you can iterate over them once to merge overlapping intervals. Therefore, the time complexity of this step is O(n).

Q:: =============================================  

##### Merge Intervals

Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.

**Example 1:**

```
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
```

**Example 2:**

```
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= starti <= endi <= 10^4`

___

What is the overall time and space complexity of the optimal solution considering the sorting process and the merging process?

```python
class Solution:
  def merge(self, intervals: List[List[int]]) -> List[List[int]]:
    intervals.sort()
    output = [intervals[0]]

    for start, end in intervals[1:]:
      prevEnd = output[-1][1]

      if prevEnd >= start:
        output[-1][1] = max(prevEnd, end) # merge
      else:
        output.append([start, end])

    return output
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n), Space complexity: O(1)

###### ID211

A:: =============================================  
**Answer**: B

The overall time complexity of the solution is determined by the most time-consuming step. Sorting the intervals has a time complexity of O(n log n), while merging has a time complexity of O(n). Therefore, the overall time complexity is O(n log n). The space complexity is O(n) because in the worst-case scenario, if no intervals overlap, the output will be a list with the same length as the input. We also use some additional space for sorting the intervals, but this does not change the overall linear space complexity.

#### Chapter 3 - Non Overlapping Intervals - [Blind]

Q:: =============================================  

##### Non Overlapping Intervals

Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.

**Example 1:**

```
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
```

**Example 2:**

```
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
```

**Example 3:**

```
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^5`
-   `intervals[i].length == 2`
-   `5 * 10^4 <= starti < endi <= 5 * 10^4`

___

Are these two intervals overlapping? `[1,2]` and `[2,3]`

A) Yes

B) No

C) Can't determine

###### ID212

A:: =============================================  
**Answer**: B

In the context of this problem the two intervals are not overlapping (See example 3). Yes, I think it's strange that LC changes the definition of 'overlapping' based on the problem, but example 3 tries to make this clear.

Q:: =============================================  

##### Non Overlapping Intervals

Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.

**Example 1:**

```
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
```

**Example 2:**

```
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
```

**Example 3:**

```
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^5`
-   `intervals[i].length == 2`
-   `5 * 10^4 <= starti < endi <= 5 * 10^4`

___

Since overlapping intervals will be adjacent, which operation can simplify the process of finding overlaps?

A) Sorting the intervals by the start times.

B) Reversing the order of the intervals.

C) Shuffling the intervals randomly.

###### ID213

A:: =============================================  
**Answer**: A

Sorting the intervals by their start times helps in aligning the intervals in increasing order. It simplifies the process of finding overlapping intervals because once the list is sorted, we can simply compare each interval with its next one to check for overlaps.

Q:: =============================================  

##### Non Overlapping Intervals

Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.

**Example 1:**

```
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
```

**Example 2:**

```
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
```

**Example 3:**

```
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^5`
-   `intervals[i].length == 2`
-   `5 * 10^4 <= starti < endi <= 5 * 10^4`

___

As we iterate through the sorted intervals, how do we know if the current interval does _not_ overlap with the previous interval?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/4ba3ef8f-eb81-465b-3c7b-741329d31a00/public)

A) If the end time of the current interval is less than the start time of the previous interval.

B) If the start time of the current interval is greater than or equal to the end time of the previous interval.

C) If the end time of the current interval is equal to the start time of the previous interval.

###### ID214

A:: =============================================  
**Answer**: B

If the start time of the current interval is greater than or equal to the end time of the previous interval, it means there is no overlap. The current interval starts only after the previous one ends.

Q:: =============================================  

##### Non Overlapping Intervals

Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.

**Example 1:**

```
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
```

**Example 2:**

```
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
```

**Example 3:**

```
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^5`
-   `intervals[i].length == 2`
-   `5 * 10^4 <= starti < endi <= 5 * 10^4`

___

When two intervals overlap, which should we remove?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/daf9f6f4-c822-43cd-6d08-63db0a4a4b00/public)

A) The interval with the earliest start time.

B) The interval with the latest end time.

C) The smallest interval.

###### ID215

A:: =============================================  
**Answer**: B

The optimal strategy is to always remove the interval with the latest end time among the overlapping intervals. This is because it leaves more room for the rest of the intervals to fit in without overlapping.

Q:: =============================================  

##### Non Overlapping Intervals

Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.

**Example 1:**

```
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
```

**Example 2:**

```
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
```

**Example 3:**

```
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
```

**Constraints:**

-   `1 <= intervals.length <= 10^5`
-   `intervals[i].length == 2`
-   `5 * 10^4 <= starti < endi <= 5 * 10^4`

___

To summarize, the below code will optimally solve this problem. What is the overall time and space complexity?

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort()
        res = 0
        prevEnd = intervals[0][1]
        for start, end in intervals[1:]:
            if start >= prevEnd:
                # Curr interval is to the right of prev
                prevEnd = end
            else:
                # Intervals overlap, keep interval with smaller end
                res += 1
                prevEnd = min(end, prevEnd)
        return res
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(1)

###### ID216

A:: =============================================  
**Answer**: B

The time complexity of the optimal solution is O(n log n) because you have to sort the intervals first, which takes O(n log n) time. Then, you iterate over the sorted intervals once, which takes O(n) time. The space complexity is O(n) because in the worst-case scenario, you store all n intervals in the input array. The additional space used for sorting does not change the overall linear space complexity.

#### Chapter 4 - Meeting Rooms - [Blind]

Q:: =============================================  

##### Meeting Rooms

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, determine if a person could attend all meetings.

Note: `(0,8),(8,10)` is not a conflict at `8`

**Example1**

```
Input: intervals = [(0,30),(5,10),(15,20)]
Output: false
Explanation:
(0,30), (5,10) and (0,30),(15,20) will conflict
```

**Example2**

```
Input: intervals = [(5,8),(9,15)]
Output: true
Explanation:
Two times will not conflict
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= intervals[i][0] < intervals[i][1] <= 10^6`

___

Given an unsorted list of intervals, what is the first step we should take to determine if a person could attend all meetings?

A) Sort by the start times of each interval

B) Sort by the length of each interval

###### ID217

A:: =============================================  
**Answer**: A

Sorting the intervals by their start times will help us to check the conflicts easily. The intervals will be arranged in a way that their start times are in ascending order.

Q:: =============================================  

##### Meeting Rooms

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, determine if a person could attend all meetings.

Note: `(0,8),(8,10)` is not a conflict at `8`

**Example1**

```
Input: intervals = [(0,30),(5,10),(15,20)]
Output: false
Explanation:
(0,30), (5,10) and (0,30),(15,20) will conflict
```

**Example2**

```
Input: intervals = [(5,8),(9,15)]
Output: true
Explanation:
Two times will not conflict
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= intervals[i][0] < intervals[i][1] <= 10^6`

___

As we iterate through the sorted intervals, how do we know if an adjacent pair of intervals is overlapping?

A) If start of the first interval < end of the second interval

B) If end of the first interval ≥ start of the second interval

C) If end of the first interval > start of the second interval

###### ID218

A:: =============================================  
**Answer**: C

If the intervals are sorted by their start times, then the end of the current interval being greater than the start of the next interval means they overlap and hence create a conflict in the meeting schedule. The reason ≥ doesn’t necessarily work is because a meeting could end as the next one begins, and it would be possible to attend both meetings.

Q:: =============================================  

##### Meeting Rooms

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, determine if a person could attend all meetings.

Note: `(0,8),(8,10)` is not a conflict at `8`

**Example1**

```
Input: intervals = [(0,30),(5,10),(15,20)]
Output: false
Explanation:
(0,30), (5,10) and (0,30),(15,20) will conflict
```

**Example2**

```
Input: intervals = [(5,8),(9,15)]
Output: true
Explanation:
Two times will not conflict
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= intervals[i][0] < intervals[i][1] <= 10^6`

___

What should you do when two intervals overlap?

A) Combine both intervals and consider it as one.

B) Do nothing, proceed to the next pair.

C) Return false, indicating a conflict in the schedule.

###### ID219

A:: =============================================  
**Answer**: C

When two intervals overlap, it signifies a conflict in the meeting schedule. Since our aim is to check if a person could attend all meetings, once a conflict is found, we can return false.

Q:: =============================================  

##### Meeting Rooms

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, determine if a person could attend all meetings.

Note: `(0,8),(8,10)` is not a conflict at `8`

**Example1**

```
Input: intervals = [(0,30),(5,10),(15,20)]
Output: false
Explanation:
(0,30), (5,10) and (0,30),(15,20) will conflict
```

**Example2**

```
Input: intervals = [(5,8),(9,15)]
Output: true
Explanation:
Two times will not conflict
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= intervals[i][0] < intervals[i][1] <= 10^6`

___

What is the overall time and space complexity of the optimal solution for this problem?

```python
class Solution:
    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:
        intervals.sort() # Sort by start times

        for i in range(1, len(intervals)):
            if intervals[i][0] < intervals[i-1][1]: # Check for overlap
                return False # Conflict found

        return True # No conflict found
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n log n), Space complexity: O(1)

###### ID220

A:: =============================================  
**Answer**: C

The overall time complexity of the solution is determined by the most time-consuming step. Sorting the intervals has a time complexity of O(n log n). After sorting, we iterate over the intervals once which has a time complexity of O(n). Therefore, the overall time complexity is O(n log n). The space complexity is O(1) because we do not use any additional data structures whose size depends on the input. Sorting the array in-place ensures that we do not use any extra space.

#### Chapter 5 - Meeting Rooms II - [Blind]

Q:: =============================================  

##### Meeting Rooms II

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, find the minimum number of conference rooms required.

**Example1**

```
Input: intervals = [(0,30),(5,10),(15,20)]
Output: 2
Explanation:
We need two meeting rooms
room1: (0,30)
room2: (5,10),(15,20)
```

**Example2**

```
Input: intervals = [(2,7)]
Output: 1
Explanation:
Only need one meeting room
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= intervals[i][0] < intervals[i][1] <= 10^6`

___

In the context of this problem, what’s an equivalent way of thinking about the minimum number of conference rooms needed?

A) The total number of meetings

B) The maximum number of overlapping intervals at any given point in time

C) The minimum number of overlapping intervals at any given point in time

###### ID221

A:: =============================================  
**Answer**: B

The minimum number of meeting rooms is equivalent to finding the maximum number of overlapping intervals at any given point in time. This is because each overlapping interval would require a separate room.

Q:: =============================================  

##### Meeting Rooms II

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, find the minimum number of conference rooms required.

**Example1**

```
Input: intervals = [(0,30),(5,10),(15,20)]
Output: 2
Explanation:
We need two meeting rooms
room1: (0,30)
room2: (5,10),(15,20)
```

**Example2**

```
Input: intervals = [(2,7)]
Output: 1
Explanation:
Only need one meeting room
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= intervals[i][0] < intervals[i][1] <= 10^6`

___

We can try to iterate through the intervals to count how many meetings are going on at any given point in time. What should be our first step?

A) By sorting the start and end times in separate arrays

B) By sorting the intervals by start time

C) By sorting the intervals by length

###### ID222

A:: =============================================  
**Answer**: A

Sorting the start and end times separately allows us to efficiently track when meetings start and end. This makes it easy to count the number of meetings at any given time.

Q:: =============================================  

##### Meeting Rooms II

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, find the minimum number of conference rooms required.

**Example1**

```
Input: intervals = [(0,30),(5,10),(15,20)]
Output: 2
Explanation:
We need two meeting rooms
room1: (0,30)
room2: (5,10),(15,20)
```

**Example2**

```
Input: intervals = [(2,7)]
Output: 1
Explanation:
Only need one meeting room
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= intervals[i][0] < intervals[i][1] <= 10^6`

___

As we iterate through these sorted arrays, `start` and `end`, how do we know if a new meeting has started?

A) start\[s\] < end\[e\]

B) start\[s\] == end\[e\]

C) start\[s\] > end\[e\]

###### ID223

A:: =============================================  
**Answer**: A

If the start time of the next meeting (start\[s\]) is less than the end time of the current earliest ending meeting (end\[e\]), it indicates a new meeting has started before a current one has ended.

Q:: =============================================  

##### Meeting Rooms II

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, find the minimum number of conference rooms required.

**Example1**

```
Input: intervals = [(0,30),(5,10),(15,20)]
Output: 2
Explanation:
We need two meeting rooms
room1: (0,30)
room2: (5,10),(15,20)
```

**Example2**

```
Input: intervals = [(2,7)]
Output: 1
Explanation:
Only need one meeting room
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= intervals[i][0] < intervals[i][1] <= 10^6`

___

As we iterate through these sorted arrays, `start` and `end`, how do we know if a meeting has ended?

A) start\[s\] < end\[e\]

B) start\[s\] == end\[e\]

C) end\[e\] <= start\[s\]

###### ID224

A:: =============================================  
**Answer**: C

If the end time of the current earliest ending meeting (end\[e\]) is less than or equal to the start time of the next meeting (start\[s\]), it indicates that a current meeting has ended. We don’t necessarily know the start time of this meeting, but we can still keep track of the number of ongoing meetings which is our goal.

Q:: =============================================  

##### Meeting Rooms II

Given an array of meeting time intervals consisting of start and end times `[[s1,e1],[s2,e2],...] (si < ei)`, find the minimum number of conference rooms required.

**Example1**

```
Input: intervals = [(0,30),(5,10),(15,20)]
Output: 2
Explanation:
We need two meeting rooms
room1: (0,30)
room2: (5,10),(15,20)
```

**Example2**

```
Input: intervals = [(2,7)]
Output: 1
Explanation:
Only need one meeting room
```

**Constraints:**

-   `0 <= intervals.length <= 10^4`
-   `intervals[i].length == 2`
-   `0 <= intervals[i][0] < intervals[i][1] <= 10^6`

___

To summarize, the below code will solve this problem optimally. What is the overall time and space complexity?

```python
class Solution:
    def minMeetingRooms(self, intervals):
        # Separate out the start and the end timings and sort them individually.
        start = sorted([i[0] for i in intervals])
        end = sorted(i[1] for i in intervals)

        s = e = 0
        used_rooms, res = 0, 0
        while s < len(intervals):
            if start[s] < end[e]:
                # A new meeting is starting
                used_rooms += 1
                s += 1
            else:
                # A current meeting is ending
                used_rooms -= 1
                e += 1
            res = max(res, used_rooms)

        return res 
```

A) Time complexity: O(n), Space complexity: O(n)

B) Time complexity: O(n log n), Space complexity: O(n)

C) Time complexity: O(n^2), Space complexity: O(n)

###### ID225

A:: =============================================  
**Answer**: B

Sorting the start and end times has a time complexity of O(n log n). The subsequent iteration over the start times doesn't change the time complexity, so the overall time complexity remains O(n log n). The space complexity is O(n) because we store the start times and end times of all meetings separately.

#### Chapter 6 - Minimum Interval to Include Each Query

### Part XIV - Greedy

#### Chapter 1 - Maximum Subarray - [Blind]
#### Chapter 2 - Jump Game - [Blind]
#### Chapter 3 - Jump Game II
#### Chapter 4 - Gas Station
#### Chapter 5 - Hand of Straights
#### Chapter 6 - Merge Triplets to Form Target Triplet
#### Chapter 7 - Partition Labels
#### Chapter 8 - Valid Parenthesis String

### Part XV - Advanced Graphs

#### Chapter 1 - Reconstruct Itinerary
#### Chapter 2 - Min Cost to Connect All Points
#### Chapter 3 - Network Delay Time
#### Chapter 4 - Swim In Rising Water
#### Chapter 5 - Alien Dictionary - [Blind]
#### Chapter 6 - Cheapest Flights Within K Stops

### Part XVI - 2-D DP

#### Chapter 1 - Unique Paths - [Blind]
#### Chapter 2 - Longest Common Subsequence - [Blind]
#### Chapter 3 - Best Time to Buy And Sell Stock With Cooldown
#### Chapter 4 - Coin Change II
#### Chapter 5 - Target Sum
#### Chapter 6 - Interleaving String
#### Chapter 7 - Longest Increasing Path In a Matrix
#### Chapter 8 - Distinct Subsequences
#### Chapter 9 - Edit Distance
#### Chapter 10 - Burst Balloons
#### Chapter 11 - Regular Expression Matching

### Part XVII - Bit Manipulation

#### Chapter 1 - Single Number
#### Chapter 2 - Number of 1 Bits - [Blind]
#### Chapter 3 - Counting Bits - [Blind]
#### Chapter 4 - Reverse Bits - [Blind]
#### Chapter 5 - Missing Number - [Blind]
#### Chapter 6 - Sum of Two Integers - [Blind]
#### Chapter 7 - Reverse Integer

### Part XVIII - Math & Geometry

#### Chapter 1 - Rotate Image - [Blind]

Q:: =============================================  

##### Rotate Image

You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).

You have to rotate the image **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**, which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0e39a867-7e9c-4189-2b4e-1f6335868600/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a7e0dfba-646e-423e-2c4e-a6f0dfc2a500/public)

```
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**Constraints:**

-   `n == matrix.length == matrix[i].length`
-   `1 <= n <= 20`
-   `1000 <= matrix[i][j] <= 1000`

___

Which approach is more suitable for rotating the matrix in-place (without allocating a new matrix)?

A) Swapping elements along the diagonal.

B) Creating a new matrix and copying elements into it.

C) Rotating each layer of the matrix starting from the outside and moving inwards.

###### ID226

A:: =============================================  
**Answer**: C

Rotating each layer of the matrix starting from the outside and moving inwards is the most suitable way to rotate a matrix in-place. The other methods either don't result in a rotated matrix, or require additional space. There are other ways to rotate the matrix in-place, but this is the most intuitive and doesn't require math knowledge.

Q:: =============================================  

##### Rotate Image

You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).

You have to rotate the image **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**, which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0e39a867-7e9c-4189-2b4e-1f6335868600/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a7e0dfba-646e-423e-2c4e-a6f0dfc2a500/public)

```
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**Constraints:**

-   `n == matrix.length == matrix[i].length`
-   `1 <= n <= 20`
-   `1000 <= matrix[i][j] <= 1000`

___

Given an `n x n` square matrix, how many layers will we have to rotate?

A) n layers

B) n/2 layers

C) 2n layers

D) n^2 layers

###### ID227

A:: =============================================  
**Answer**: B

For an nxn matrix, we only need to rotate n/2 layers. This is because with each layer, we are actually rotating 4 sides (top, right, bottom, left) of the square matrix.

Q:: =============================================  

##### Rotate Image

You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).

You have to rotate the image **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**, which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0e39a867-7e9c-4189-2b4e-1f6335868600/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a7e0dfba-646e-423e-2c4e-a6f0dfc2a500/public)

```
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**Constraints:**

-   `n == matrix.length == matrix[i].length`
-   `1 <= n <= 20`
-   `1000 <= matrix[i][j] <= 1000`

___

If we consider a layer-by-layer rotation starting from the corners, which will be the next four elements to be rotated after the four corners?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d01c9636-cfee-4f7c-3fbb-ddb051090300/public)

A) 2nd element in first row, 2nd element in the first column, 2nd element in last row, 2nd element in last column

B) 2nd element in first row, 2nd element in last column, second to last element in last row, second to last element in first column

###### ID228

A:: =============================================  
**Answer**: B

After the corners, we shift one place inward or towards the center on each side. So, the next four elements to rotate are the 2nd element in the first row, the 2nd element in the last column, the second to last element in the last row, and the second to last element in the first column.

Q:: =============================================  

##### Rotate Image

You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).

You have to rotate the image **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**, which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0e39a867-7e9c-4189-2b4e-1f6335868600/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a7e0dfba-646e-423e-2c4e-a6f0dfc2a500/public)

```
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**Constraints:**

-   `n == matrix.length == matrix[i].length`
-   `1 <= n <= 20`
-   `1000 <= matrix[i][j] <= 1000`

___

After we complete a layer, how should we update our pointers?

A) Increment the left pointer and decrement the right pointer.

B) Decrement both the left and right pointers.

C) Increment both the left and right pointers.

D) Decrement the left pointer and increment the right pointer.

###### ID229

A:: =============================================  
**Answer**: A

After we rotate a layer, we move inwards to the next layer. This involves incrementing the left pointer and decrementing the right pointer.

Q:: =============================================  

##### Rotate Image

You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).

You have to rotate the image **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)**, which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0e39a867-7e9c-4189-2b4e-1f6335868600/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a7e0dfba-646e-423e-2c4e-a6f0dfc2a500/public)

```
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

**Constraints:**

-   `n == matrix.length == matrix[i].length`
-   `1 <= n <= 20`
-   `1000 <= matrix[i][j] <= 1000`

___

Considering the method of rotating each layer of the matrix, what would be the time complexity and space complexity of this operation?

```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        l, r = 0, len(matrix) - 1

        while l < r:
            for i in range(r - l):
                top, bottom = l, r

                # save the topleft
                topLeft = matrix[top][l + i]

                # move bottom left into top left
                matrix[top][l + i] = matrix[bottom - i][l]

                # move bottom right into bottom left
                matrix[bottom - i][l] = matrix[bottom][r - i]

                # move top right into bottom right
                matrix[bottom][r - i] = matrix[top + i][r]

                # move top left into top right
                matrix[top + i][r] = topLeft
            r -= 1
            l += 1
```

A) Time complexity: O(1)  
Space complexity: O(n)

B) Time complexity: O(n)  
Space complexity: O(1)

C) Time complexity: O(n^2)  
Space complexity: O(1)

###### ID230

A:: =============================================  
**Answer**: C

The time complexity of the rotation operation is O(n^2). This is because, for each layer of the matrix, we perform a constant amount of work for each element, and there are n^2 total elements. The space complexity is O(1) because we perform the rotation in-place without allocating any additional significant space. The only extra space we use is a couple of variables to keep track of the current position and temporarily hold an element during the rotation.

#### Chapter 2 - Spiral Matrix - [Blind]

Q:: =============================================  

##### Spiral Matrix

Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d23c7df9-a6dd-4b27-1b10-716af9df2c00/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7a94bac6-b2a5-4487-77b0-8313eb6e0900/public)

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Constraints:**

-   `m == matrix.length`
-   `n == matrix[i].length`
-   `1 <= m, n <= 10`
-   `100 <= matrix[i][j] <= 100`

___

What is the correct order of traversal to achieve a spiral order in a matrix?

A) Top row from left to right, rightmost column from top to bottom, bottom row from right to left, leftmost column from bottom to top.

B) Top row from right to left, rightmost column from bottom to top, bottom row from left to right, leftmost column from top to bottom.

###### ID231

A:: =============================================  
**Answer**: A

To achieve a spiral order in a matrix, we start by traversing the top row from left to right, then the rightmost column from top to bottom, then the bottom row from right to left, and finally the leftmost column from bottom to top. This completes one cycle of spiral traversal.

Q:: =============================================  

##### Spiral Matrix

Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d23c7df9-a6dd-4b27-1b10-716af9df2c00/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7a94bac6-b2a5-4487-77b0-8313eb6e0900/public)

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Constraints:**

-   `m == matrix.length`
-   `n == matrix[i].length`
-   `1 <= m, n <= 10`
-   `100 <= matrix[i][j] <= 100`

___

After completing one cycle of spiral traversal in the matrix, what should be the next step?  
![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/cb1d1f77-711b-4fa0-e81f-fd5dfc35b700/public)

A) Repeat the same cycle on the remaining submatrix.

B) Reverse the cycle on the remaining submatrix.

C) Transpose the remaining submatrix and then repeat the same cycle.

###### ID232

A:: =============================================  
**Answer**: A

After completing one cycle of spiral traversal, the remaining submatrix will be smaller, but we should still traverse it in the same order: top row, rightmost column, bottom row, leftmost column.

Q:: =============================================  

##### Spiral Matrix

Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d23c7df9-a6dd-4b27-1b10-716af9df2c00/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7a94bac6-b2a5-4487-77b0-8313eb6e0900/public)

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Constraints:**

-   `m == matrix.length`
-   `n == matrix[i].length`
-   `1 <= m, n <= 10`
-   `100 <= matrix[i][j] <= 100`

___

To traverse an `m x n` matrix in a spiral order, how many pointers do we need and what do they represent?

A) 3 pointers - one for row, one for column, and one for diagonal traversal.

B) 4 pointers - one for each of top, right, bottom, and left boundaries of the current submatrix.

C) 5 pointers - one for each of top, right, bottom, left boundaries and one for the center of the matrix.

###### ID233

A:: =============================================  
**Answer**: B

To traverse a 2D matrix in a spiral order, we need 4 pointers to keep track of the boundaries of the current submatrix we are traversing. These boundaries are top, right, bottom, and left. As we traverse, we progressively move the boundaries inward.

Q:: =============================================  

##### Spiral Matrix

Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d23c7df9-a6dd-4b27-1b10-716af9df2c00/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7a94bac6-b2a5-4487-77b0-8313eb6e0900/public)

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Constraints:**

-   `m == matrix.length`
-   `n == matrix[i].length`
-   `1 <= m, n <= 10`
-   `100 <= matrix[i][j] <= 100`

___

Given the Python code below for traversing a matrix in spiral order, what will be a potential issue when running this code on a non-square matrix? For example, consider what the output would be for `matrix = [[1, 2, 3]]`.

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        left, right = 0, len(matrix[0])
        top, bottom = 0, len(matrix)

        # while pointers have not met
        while left < right and top < bottom:
            # get every val in the top row
            for i in range(left, right):
                res.append(matrix[top][i])
            top += 1
            # get every val in the right col
            for i in range(top, bottom):
                res.append(matrix[i][right - 1])
            right -= 1

            # get every val in the bottom row
            for i in range(right - 1, left - 1, -1):
                res.append(matrix[bottom - 1][i])
            bottom -= 1
            # get every val in the left col
            for i in range(bottom - 1, top - 1, -1):
                res.append(matrix[i][left])
            left += 1

        return res
```

A) The code will fail to traverse the entire matrix.

B) The code will traverse the last submatrix multiple times.

###### ID234

A:: =============================================  
**Answer**: B

The problem with this code is that it does not consider the case where the last submatrix is not square. If the last remaining part of the matrix is not square, the code will traverse the last submatrix multiple times. This is because there's no check to stop the bottom row and left column from being traversed again after the right column has been traversed and reduced. In the above example, the output would be \[1, 2, 3, 2, 1\], instead of \[1, 2, 3\] which is the expected result.

Q:: =============================================  

##### Spiral Matrix

Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.

**Example 1:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d23c7df9-a6dd-4b27-1b10-716af9df2c00/public)

```
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
```

**Example 2:**

![image](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7a94bac6-b2a5-4487-77b0-8313eb6e0900/public)

```
Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```

**Constraints:**

-   `m == matrix.length`
-   `n == matrix[i].length`
-   `1 <= m, n <= 10`
-   `100 <= matrix[i][j] <= 100`

___

Consider the below code snippet. It returns the spiral order of elements in the given matrix without duplicating elements. What is its time and space complexity? Assume we include the output as additional space.

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        res = []
        left, right = 0, len(matrix[0])
        top, bottom = 0, len(matrix)

        # while pointers have not met
        while left < right and top < bottom:
            # get every val in the top row
            for i in range(left, right):
                res.append(matrix[top][i])
            top += 1
            # get every val in the right col
            for i in range(top, bottom):
                res.append(matrix[i][right - 1])
            right -= 1

            if not (left < right and top < bottom):
                # Pointers have met, so the spiral is complete
                break

            # get every val in the bottom row
            for i in range(right - 1, left - 1, -1):
                res.append(matrix[bottom - 1][i])
            bottom -= 1
            # get every val in the left col
            for i in range(bottom - 1, top - 1, -1):
                res.append(matrix[i][left])
            left += 1

        return res
```

A) Time complexity: O(m\*n)  
Space complexity: O(m\*n)

B) Time complexity: O(m^2)  
Space complexity: O(n^2)

C) Time complexity: O(m+n)  
Space complexity: O(m+n)

###### ID235

A:: =============================================  
**Answer**: A

The time complexity of this function is O(m\*n), where m is the number of rows and n is the number of columns in the input matrix. This is because each element is visited and processed exactly once. The space complexity is also O(m\*n), because in the worst case, if all elements are stored in the output list, it will contain m\*n elements.

#### Chapter 3 - Set Matrix Zeroes - [Blind]
#### Chapter 4 - Happy Number
#### Chapter 5 - Plus One
#### Chapter 6 - Pow(x, n)
#### Chapter 7 - Multiply Strings
#### Chapter 8 - Detect Squares

---

DECK INFO

TARGET DECK: Data Structures and Algorithms::Leetcode::MNAB - Neetcode 150 and blind 75 - multi-author

FILE TAGS: #DSA::#Leetcode

Tags:

Reference:

Related:

```dataview
LIST
where file.name = this.file.name
```
